<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ElasticSearch原理简介]]></title>
    <url>%2F2018%2F01%2F18%2F2018-1-18-ElasticSearch-Intro%2F</url>
    <content type="text"><![CDATA[引言 ELK是重要的日志分析系统，在开源的日志分析系统中独占鳌头，最近公司业务用ELK分析告警日志，故系统研究了Elasticsearch的工作原理。 本文是转载的一篇文章加上我自己的整理和分析，某些内容和ELK官网重复，在此感谢作者的整理。 基本概念 简介： ElasticSearch(以下简称ES)是一个基于Lucene构建的开源(open-source)，分布式(distributed)，RESTful，实时(real-time)的搜索与分析(analytics)引擎。 它可以让你在浏览数据时具备非常快的速度和优秀的可扩展性。它用于全文索引、结构化数据索引、数据分析以及三者的结合。 它可以运行在你的笔记本上，或者扩展至数百台的服务器节点上来处理PB级的数据。 ES建立在Lucene的基础之上，但是Lucene仅仅是一个库，如果要发挥它的优势，你必须使用它然后再结合自己的开发来构造一个具体的应用。 更坏的是你必须了解Lucene才能更好的使用它，但是Lucene本身就很复杂。所以ES意在取Lucene的优点，隐蔽其复杂性来构造一个简洁易用的RESTful风格的全文搜索引擎。 与关系型数据库的名词对照 SQL database No-sql database database database table collection row document column field primary key primary key ElasticSearch专用名词解释： document：一行数据； index：一个database，是多个document的集合（和sql数据库的索引的概念不同），在kibana上显示为一组日志； shard：ELK的底层存储是file，shared包含一个或多个file，是数据最小存储单元，一个index被划分为若干shared分片，一个shared可以备份到其他节点上（备份的份数可以自定义）； node：物理节点； cluster：集群； 面向文档(Document Oriented) 在应用程序中的对象(Objects)，不仅仅是keys和values的罗列，更多的是，他们是由更为复杂的数据结构组成的数据构成的。迟早你会将这些对象存储到DataBases(这里指更广义的持久层)。如果你要将这些已经通过复杂的结构体组织好的对象存储到传统的ROWS-COLUMNS的关系型数据库里无疑等于压榨你的财富：因为你必须将这些已经组织好了的复杂结构扁平化来适应传统数据库的表结构(通常是一个列一个字段)，然后以后每次在你要使用这个数据的时候再重组它们。 ES面向文档，这就意味着你可以存储完整的对象或者文档。ES不仅存储它们，并且对它们的每一个文档的内容做了索引以便可以查询到它们。在ES中，你是对文档进行的建索引、查询、排序、过滤，而不是对关系型数据的一行数据。这就是ES处理数据的一个最基本的不同点，这也是ES为什么能处理全文索引的关键。 精确索引VS全文索引 在ES中的数据可以分为两类：精确值(exact values)以及全文(full text)。 精确值：例如日期类型date，若date其有两个值:2014-09-15与2014，那么这两个值不相等。又例如字符串类型foo与Foo不相等。 全文：通常是人类语言写的文本，例如一段tweet信息、email的内容等。 精确值很容易被索引：一个值要么相当要么不等。 索引全文值就需要很多功夫。例如我们不仅要想：这个文档符合我们的查询吗？还要想：这个文档有多符合我们的查询？换句话说就是：这个文档跟我们的查询关联大吗？我们很少精确的去匹配整个全文，我们最想要的是去匹配全文文本的内部信息。除此，我们还希望搜索能够理解我们的意图; 例如,如果你搜索UK，我们需要包含United Kingdom的文本也会被匹配。如果你搜索jump，那么包含jumped,jumps,jumping,更甚者leap的文本会被匹配。 为了更方便的进行全文索引，ES首先要先分析文本，然后使用分析过的文本去创建倒序索引。 倒序索引&amp;文本分析 ES使用倒序索引来加速全文索引。一个倒序索引由两部分组成：在文档中出现的所有不同的词；对每个词，它所出现的文档的列表。 例如：如果我们有两个文档，每一个文档有一个content字段，包含的内容如下： 1.The quick brown fox jumped over the lazy dog2.Quick brown foxes leap over lazy dogs in summer 要创建一个倒序索引，首先要将content分割成单独的词(称为terms or tokens)，创建一个所有terms的列表，然后罗列每一个term出现的文档。此过程称为tokenization。如下图： 现在，如果我们想要搜索 quick brown，我们仅仅只需要找每一个term出现的文档即可。如下图： 每一个文档都匹配到了，但是第一个比第二个要匹配的多。如果我们使用一个简单的相似性算法仅仅只计算匹配的数量，那么我们可以称第一个文档要比第二个匹配的好(与我们的查询更有关联)。但是现在的倒序索引有一些问题： Quick与quick是两个不同的term，但是搜索的用户会认为它们应该是一样的term才是合理的。fox和foxes，dog和dogs是一样的词根，应该列为同一个term。 jumped和leap虽然词根不一样，但是意义却相同。 如果改善了上面的问题，那么倒序索引应该如下图： 但是此时如果用户搜索Quick还会失败，因为term不含精确值Quick。但是，如果我们对QueryString使用与上述改善步骤相同的策略，那么用户搜索的Quick将会被转换为quick，此过程称为normalization。那么将会成功匹配。 对content的处理tokenization和normalization称为analysis过程。ES有很多种内置的analyzer处理这些。 Elasticsearch设计原理一个空的集群 如果我们启动了一个节点，没有索引没有数据，那么看起来就像上图一样。 一个节点Node运行着ES的实例，一个集群由一个或多个使用着同样名字(cluster.name)的节点组成，分享数据和负载。 当Node从集群中添加或删除时，集群会重组自己，使数据平摊的更均匀。 集群中需要有一台master节点。master的作用是掌管集群的管理工作： 例如创建和删除索引。 从集群中添加或删除一台节点。 master节点无需掌管文档级的变更和索引。这也意味着在只有一台master的情况下，随着负载的增加master不会成为瓶颈。 所有的节点都可能变成master。 作为user，我们可以与任何一台节点通信，包括master。每一台节点都知道每一个文档的位置并且可以将user的请求路由到文档所在的节点，并且这台节点负责接收它路由到的node or nodes的响应，并且将数据组织起来返回给用户。这些对用户都是透明的。 创建一个索引—index,shard,cluster 将数据添加到ES的前提是，我们需要一个索引(名词):index——一个存储与这个索引相对应数据的地方。实际上，index仅仅只是一个命名空间来指向一个或多个实际的物理分片(shard)。 一个分片(shard)是一个比较低层的工作单元来处理这个索引(index)的所有数据的一个切片(slice)。一个shard实际上是一个Lucene实例，在它的能力范围内拥有完整的搜索功能(在处理它自己拥有的数据时有所有的功能)。我们所有文档的索引indexed(动词)和存储工作都是在shard上，但这是透明的，我们不需要直接和shard通信，而是和我们创建的index(名词)通信。 shards是ES将数据分布式在你的集群的关键。想象下shards是数据的容器，文档存储在shards里，而shards被分配在集群的每一个节点Node里。当你的集群规模增长和降低时，ES会自动的在Nodes间迁移shards以保持集群的负载均衡。 shard的分类与作用： shard可分为primary shard和replica shard。 在一个index里的每一个文档都属于一个单独的primary shard，所以primary shard的数量决定了你最大能存储的数据量(对应于一个index)。 注意：shard是归属与index的，而不是cluster的。 replica shard是primary shard的拷贝。replica有两个作用： 冗余容灾 提供读请求服务，例如搜索或读取文档primary shard的数量在索引创建时确定后不能修改，replica可以在任何时候修改。 例： 见Figure2，在2.1的集群上创建一个index，拥有3个primary shards以及1个replica shards。 由于只有一台Node，而Primary shard的Replicas与其在同一台节点上毫无意义，所以集群没有初始化replicas，这时添加另外一台Node。见Figure3，每一个primary shard初始化了一个replica。 水平扩容当我们继续添加一台节点时，Node1和Node2中的各取一个shard移动到了Node3.见Figure4 这样，我们每一台Node上只有两个shard。这就意味着每一台Node的硬件资源(CPU,RAM,I/O)将会被更少的shards共享，提高了每一个shard的性能。在这个案例中，6个shards最多可使用6台Node，这样每个shard就可以使用100%的node硬件资源。现在我们修改replica的数量到2，如Figure5 这样我们就有了一个3primary shards，6replica shards的Cluster。我们可将Node提高到9台。水平扩容了集群性能。 容灾ES可以容下当节点宕机情况下的异常。例如现在我们杀掉Node1节点。见Figure6 我们杀掉的是master节点。一个Cluster必须要有master以保证集群的功能正常。所以集群要做的第一件事是选择一个新的master：Node2. 当我们杀掉1节点时，Primary shards 1和2丢失了。如果丢失了primary shard，index(名词)将不能正常的工作。此时P1和P2的拷贝存在Node2和Node3上。所以此时新升级的master(Node2)将做的第一件事就是将NODE2和NODE3上的replica shard1和replica shard2升级为primary shard。此时如果我们杀掉NODE2，整个集群的容灾过程同理，还是可以正常运行。 这时，如果我们重启了NODE1，cluster将会重新分配缺少的两个replica shards(现在每个primary shard只有2个replicas，配置是3个，缺少2个)。如果NODE1的数据是旧的，那么它将会继续利用它们，NODE1只会从现在的Primary Shards拷贝这期间更改的数据。 分布式文档存储Shards文档路由当你对一个文档建立索引时，它仅存储在一个primary shard上。ES是怎么知道一个文档应该属于哪个shard？当你创建一个新的文档时，ES是怎么知道应该把它存储至shard1还是shard2？ 这个过程不能随机无规律的，因为以后我们还要将它取出来。它的路由算法是： shard = hash(routing) % numberofprimary_shards routing的值可以是文档的id，也可以是用户自己设置的一个值。hash将会根据routing算出一个数值然后%primaryshards的数量。这也是为什么primary_shards在index创建时就不能修改的原因。 问题：当看到这里时，产生了一个问题:ES为什么要这样设计路由算法，这样就强制使primaryshards不可变，不利于以后index的扩容，除非事前就要对数据规模有所评估来设计可扩展的index。为什么不能使用一致性hash解决primaryshards改变时的情况呢？ Primary/Replica Shards的交互假如我们有Figure8的集群。我们可以向这个集群的任何一台NODE发送请求，每一个NODE都有能力处理请求。每一个NODE都知道每一个文档所在的位置所以可以直接将请求路由过去。下面的例子，我们将所有的请求都发送到NODE1。 注：最好的实践方式是轮询所有的NODE来发送请求，以达到请求负载均衡。 写操作创建、索引、删除文档都是写操作，这些操作必须在primary shard完全成功后才能拷贝至其对应的replicas上。见Figure9。 1.客户端向Node1发送写操作的请求。2.Node1使用文档的_id来决定这个文档属于shard0，然后将请求路由至NODE3，P0所在的位置。3.Node3在P0上执行了请求。如果请求成功，则将请求并行的路由至NODE1 NODE2的R0上。当所有的replicas报告成功后，NODE3向请求的node(NODE1)发送成功报告，NODE1再报告至Client。当客户端收到执行成功后，操作已经在Primary shard和所有的replica shards上执行成功了。 读操作一个文档可以在primary shard和所有的replica shard上读取。见Figure10 1.客户端发送Get请求到NODE1。2.NODE1使用文档的_id决定文档属于shard 0.shard 0的所有拷贝存在于所有3个节点上。这次，它将请求路由至NODE2。3.NODE2将文档返回给NODE1，NODE1将文档返回给客户端。 对于读请求，请求节点(NODE1)将在每次请求到来时都选择一个不同的replica。shard来达到负载均衡。使用轮询策略轮询所有的replica shards。 更新操作更新操作，结合了以上的两个操作：读、写。见Figure11 1.客户端发送更新操作请求至NODE12.NODE1将请求路由至NODE3，Primary shard所在的位置3.NODE3从P0读取文档，改变source字段的JSON内容，然后试图重新对修改后的数据在P0做索引。如果此时这个文档已经被其他的进程修改了，那么它将重新执行3步骤，这个过程如果超过了retryon_conflict设置的次数，就放弃。4.如果NODE3成功更新了文档，它将并行的将新版本的文档同步到NODE1和NODE2的replica shards重新建立索引。一旦所有的replicashards报告成功，NODE3向被请求的节点(NODE1)返回成功，然后NODE1向客户端返回成功。 Shard以及数据读写方式的设计不变性 写到磁盘的倒序索引是不变的：自从写到磁盘就再也不变。这会有很多好处： 不需要添加锁。如果你从来不用更新索引，那么你就不用担心多个进程在同一时间改变索引。 一旦索引被内核的文件系统做了Cache，它就会待在那因为它不会改变。只要内核有足够的缓冲空间，绝大多数的读操作会直接从内存而不需要经过磁盘。这大大提升了性能。 其他的缓存(例如fiter cache)在索引的生命周期内保持有效，它们不需要每次数据修改时重构，因为数据不变。 写一个单一的大的倒序索引可以让数据压缩，减少了磁盘I/O的消耗以及缓存索引所需的RAM。 当然，索引的不变性也有缺点。如果你想让新修改过的文档可以被搜索到，你必须重新构建整个索引。这在一个index可以容纳的数据量和一个索引可以更新的频率上都是一个限制。 动态更新索引如何在不丢失不变形的好处下让倒序索引可以更改？答案是：使用不只一个的索引。 新添额外的索引来反映新的更改来替代重写所有倒序索引的方案。 Lucene引进了per-segment搜索的概念。一个segment是一个完整的倒序索引的子集，所以现在index在Lucene中的含义就是一个segments的集合，每个segment都包含一些提交点(commit point)。见Figure16。新的文档建立时首先在内存建立索引buffer，见Figure17。然后再被写入到磁盘的segment，见Figure18。 一个per-segment的工作流程如下： 新的文档在内存中组织，见Figure17。 每隔一段时间，buffer将会被提交：一个新的segment(一个额外的新的倒序索引)将被写到磁盘 一个新的提交点(commit point)被写入磁盘，将包含新的segment的名称。 磁盘fsync，所有在内核文件系统中的数据等待被写入到磁盘，来保障它们被物理写入。 新的segment被打开，使它包含的文档可以被索引。 内存中的buffer将被清理，准备接收新的文档。 当一个新的请求来时，会遍历所有的segments。词条分析程序会聚合所有的segments来保障每个文档和词条相关性的准确。通过这种方式，新的文档轻量的可以被添加到对应的索引中。 删除和更新 segments是不变的，所以文档不能从旧的segments中删除，也不能在旧的segments中更新来映射一个新的文档版本。取之的是，每一个提交点都会包含一个.del文件，列举了哪一个segmen的哪一个文档已经被删除了。 当一个文档被”删除”了，它仅仅是在.del文件里被标记了一下。被”删除”的文档依旧可以被索引到，但是它将会在最终结果返回时被移除掉。 文档的更新同理：当文档更新时，旧版本的文档将会被标记为删除，新版本的文档在新的segment中建立索引。也许新旧版本的文档都会本检索到，但是旧版本的文档会在最终结果返回时被移除。 实时索引 在上述的per-segment搜索的机制下，新的文档会在分钟级内被索引，但是还不够快。 瓶颈在磁盘。将新的segment提交到磁盘需要fsync来保障物理写入。但是fsync是很耗时的。它不能在每次文档更新时就被调用，否则性能会很低。 现在需要一种轻便的方式能使新的文档可以被索引，这就意味着不能使用fsync来保障。 在ES和物理磁盘之间是内核的文件系统缓存。之前的描述中,Figure19,Figure20，在内存中索引的文档会被写入到一个新的segment。但是现在我们将segment首先写入到内核的文件系统缓存，这个过程很轻量，然后再flush到磁盘，这个过程很耗时。但是一旦一个segment文件在内核的缓存中，它可以被打开被读取。 更新持久化不使用fsync将数据flush到磁盘，我们不能保障在断电后或者进程死掉后数据不丢失。ES是可靠的，它可以保障数据被持久化到磁盘。 在2.6.2中，一个完全的提交会将segments写入到磁盘，并且写一个提交点，列出所有已知的segments。当ES启动或者重新打开一个index时，它会利用这个提交点来决定哪些segments属于当前的shard。 如果在提交点时，文档被修改会怎么样？不希望丢失这些修改： 当一个文档被索引时，它会被添加到in-memory buffer，并且添加到Translog日志中，见Figure21. refresh操作会让shard处于Figure22的状态：每秒中，shard都会被refreshed，在in-memory buffer中的文档会被写入到一个新的segment，但没有fsync，in-memory buffer被清空。 这个过程将会持续进行：新的文档将被添加到in-memory buffer和translog日志中，见Figure23 一段时间后，当translog变得非常大时，索引将会被flush，新的translog将会建立，一个完全的提交进行完毕。见Figure24 在in-memory中的所有文档将被写入到新的segment. 内核文件系统会被fsync到磁盘。 旧的translog日志被删除 translog日志提供了一个所有还未被flush到磁盘的操作的持久化记录。当ES启动的时候，它会使用最新的commit point从磁盘恢复所有已有的segments，然后将重现所有在translog里面的操作来添加更新，这些更新发生在最新的一次commit的记录之后还未被fsync。 translog日志也可以用来提供实时的CRUD。当你试图通过文档ID来读取、更新、删除一个文档时，它会首先检查translog日志看看有没有最新的更新，然后再从响应的segment中获得文档。这意味着它每次都会对最新版本的文档做操作，并且是实时的。 Segment合并 通过每隔一秒的自动刷新机制会创建一个新的segment，用不了多久就会有很多的segment。segment会消耗系统的文件句柄，内存，CPU时钟。最重要的是，每一次请求都会依次检查所有的segment。segment越多，检索就会越慢。 ES通过在后台merge这些segment的方式解决这个问题。小的segment merge到大的，大的merge到更大的。。。 这个过程也是那些被”删除”的文档真正被清除出文件系统的过程，因为被标记为删除的文档不会被拷贝到大的segment中。合并过程如Figure25： 当在建立索引过程中，refresh进程会创建新的segments然后打开他们以供索引。 merge进程会选择一些小的segments然后merge到一个大的segment中。这个过程不会打断检索和创建索引。 Figure26，一旦merge完成，旧的segments将被删除：新的segment被flush到磁盘，一个新的提交点被写入，包括新的segment，排除旧的小的segments，新的segment打开以供索引旧的segments被删除。 merge大的segments会消耗大量的I/O和CPU，严重影响索引性能。默认，ES会节制merge过程来给留下足够多的系统资源。]]></content>
      <tags>
        <tag>DevOps</tag>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017我的年度书单]]></title>
    <url>%2F2017%2F12%2F10%2Fyear-books%2F</url>
    <content type="text"><![CDATA[引言 今年是工作的第一年，虽然非常忙，但仍然静下心读了几本书。 书籍相比于公众号、博客、各种手机APP等，在获取信息的效率方面确实比较逊色，但是读书的目的远远不仅是获取信息。读书、思考、认识、改变应当是一个有机统一的整体。书中的世界和我们眼中的世界有时是不同的，我想，这可能就是读书的意义所在吧。 读书本身并不是学习，学习有很多渠道，不一定非要读书。如果说读书可以促使人进步，我想，不如说由读书引发的思考使人进步。思考力已经成为在这个飞速发展和变化的社会生存的核心竞争力。 下面，分享我今年读的几本书，如果您对这些书籍或领域也感兴趣，欢迎邮件交流。 2017-我的书单 《经济学基础》 作者：[美] 曼昆 曼昆是美国著名经济学家、哈佛大学经济学教授，本书是美国乃至全球经济学和金融学专业的知名的教科书。 本书最大的特点是将深刻的经济学原理和普通人的生活相结合，深入浅出，用类比的思想讲解经济学的基本原理。 本书涉及了经济学最深刻的本质：经济为何能够成为人类社会生活的一部分？为什么要有经济和金融，它有没有替代品？经济为人性服务还是人性为经济服务？ 如果您能将本书中的西方经济学思想和中国的具体实际相结合，您就会发现当今中国的各种经济现象的本源和基本的解决方案。大到国家层面的大政方针、小到我们每个人的财务支配，经济学原理就像一只无形的手支配着所有人的经济行为。 本书是经济学经典著作《国富论》的延伸和发展，将现代经济学、金融学和西方经济学的思想融为一体，非常值得认真阅读。 《乌合之众》 作者：[法] 居斯塔夫·勒庞 作者勒庞是法国社会心理学家、社会学家、群体心理学创始人，本书是群体心理学的鼻祖。 虽然群体心理学和个体心理学所揭示的心理学基本原理在本质上高度一致，但是群体心理学在研究方法、外在表象、应用实践等方面与个体心理学有着很大的不同。 本书不是心理学教材，而是一本心理学专著，对于没有心理学背景的读者来说，可能不容易领会其中的内涵。建议在阅读本书前先阅读戴维·迈尔斯的《社会心理学》。 本书提出了几个较为深刻的问题，就连勒庞自己也没有给出完美的解答：为什么将个体放在群体中就会出现和个体单独存在时完全不同、甚至截然相反的心理表现？社会和群体存在和意义和价值是什么？不同种族、不同信仰、不同价值观的人如何合作？社会群体和家庭如何影响个体的心理发展？ 如果您对心理学在群体中的表征看兴趣，可以阅读此书。 《合作的进化》 作者：[美] 罗伯特·阿克塞尔罗德 本书很薄，一两周便能够通读完成； 不同于《乌合之众》，本书专注于行为心理学的研究和实践，而不是侧重群体心理学。 阅读完本书您会发现，人类的一切政治、经济、军事、科技、教育、娱乐活动无不暗含着行为心理学的基本原理，可以说行为心理学指导人类进行各种社会活动，社会活动本身反过来也影响人的行为。人的行为在一定程度上是可预测的。 如果您对博弈论感兴趣，建议将本书和博弈论相关书籍一起阅读，您会发现人类行为不知不觉也应用了博弈论的基本原理，并且对企业间、国家间的合作理解得更为深刻和透彻。 《变态心理学》 作者：[美] 德博拉 C.贝德尔 （Deborah C. Beidel） / 辛西娅 M. 布利克（Cynthia M. Bulik） / 梅琳达•斯坦利（Melinda A. Stanley） 本书讲解了非常态心理的基本原理，比如造成孤独症、焦虑症、抑郁症的原因和基本治疗方法。虽然只有心理学相关专业才需要这些知识，但是我还是完整阅读本书，对非常态心理有了基本的理解。 本书不仅包含理论研究，而且还包含了大量生动的例子和临床实践，便于读者了解问题的表象和本质原因。 本书中还有很多概念我不太理解，需要再次阅读其他变态心理学著作配合理解。 《聪明的投资者》 作者：[美] 本杰明·格雷厄姆 本书作者本杰明·格雷厄姆是美国经济学家和投资思想家、价值投资理论奠基人、巴菲特的老师。 本书是价值投资的最为经典的著作，没有之一。 如果您对投资感兴趣，或者准备成为股东，强烈推荐阅读此书。 本书理论部分不多，对于大多数章节，都直接给出作者的观点或者结论，比如投资的基本原则和注意事项、公司或股票的选择原则、如何在股市中盈利和止损等。 本书并没有讲解太多技术面的操作技巧，如果需要了解技术面，不建议阅读本书。 《人人都是经营者》 作者：[中] 刁东平 阿米巴经营模式的核心，是经营哲学、组织结构设计、内部市场、经营会计、人才培养、内部运行等等一整套理论的有机整合，作者认为这是比较适合中国企业的、但尚未在中国企业中广泛应用的一种经营模式。 我个人认为，阿米巴经营模式适用于那种资金流动性大、具有较充足的流动资金、处于朝阳产业并想要扩大生产的中型企业。准备上市的企业也可以参考运用。 任何一种模式都无法代替“实事求是”四个字，应当根据企业的实际情况，使用适合自己的模式。 《巴菲特之道》 作者：[美] 罗伯特·哈格斯特朗 想了解投资大师巴菲特？就读这本书！ 本书介绍了巴菲特的个人经历，以及如果从一位投资小白成长为投资大师的传奇经历，从这段经历中，我们也可以看出巴菲特的投资思想的变迁。 虽说成功不可复制，但是参考巴菲特成功的经历，多多少少有所启发、有所借鉴。 《看见》 作者：[中] 柴静 本书给了读者看中国的另一只眼睛。 本书中所写的都是记者柴静的采访经历，看起来都是一些小事，但却能反映最真实的中国的现状。本书书名为《看见》，的确，读完本书后，我看见了一些以前不曾看见的东西，对中国的改革、发展有了更深刻的认识，对发展中遇到的问题和解决方法有了更深刻的认识。 历史就是一个和另一个的《看见》所书写的，《看见》不仅是为了看见，更是为了改变和进步。]]></content>
      <tags>
        <tag>books</tag>
        <tag>feeling</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我理解的DevOps]]></title>
    <url>%2F2017%2F06%2F15%2F2017-6-15-DevOps%2F</url>
    <content type="text"><![CDATA[引言 DevOps是一种重要的软件开发模式； 我所在的团队正在进行DevOps转型； DevOps极大地提升了开发效率； 本文介绍了我对DevOps的理解； 什么是DevOps DevOps是一种软件开发人员（Research and Dev，RD）和IT运维运营技术人员（Ops）和质量检测（QA）之间沟通合作的模式； DevOps的根本目的是快速频繁的、小步的、自动化便捷的监控和审计的、云端和虚拟化的、可视化的部署，满足“每天部署10次”或者“快速解决bug并上线”的要求； DevOps是敏捷开发、持续交付的基础； DevOps模式和传统的瀑布模型相对应； 我们需要维护什么？ 以我所在的团队为例，我们需要维护的内容如下： 需要维护的环境分为：开发环境，测试环境，准生产环境，生产环境； 每个环境包含若干个scope，每个scope都是整个系统的一部分，由不同的团队进行开发； 使用microsoft微服务架构，每个scope中都有若干service，每个service之间可能还存在相互依赖关系； 每个service都需要若干resource，这些resource包括但不限于： RabbitMQ； Service Fabric； IoTHub； EventHub； ELK； Consule； KeyVault； MongoDB； Postgresql； Cassandra； Storm； Redis； 如果没有DevOps，我们怎样工作？ 没有流水线Pipeline： 开发过程变得非常痛苦，会经常忘记对代码进行单元测试和集成测试； 开发完成的服务，打包后不知道放在何处，别人需要引用时很不方便； 代码质量得不到保证，很多代码没有经过“单元测试覆盖率检测”和“代码重复率检测”，代码可维护性变差； 随着开发的深入进行，开发人员的主要精力不在是编写新的代码，而是处理bug和维护旧的代码，使开发效率逐渐降低； 没有自动化环境部署： 在开发者完成一个微服务的开发后，不知道将自己开发的服务部署到什么环境上去测试； 开发者在测试自己的代码时，会时常发现所依赖的资源没有准备好，比如测试环境缺少MongoDB等资源； 运维人员不能显式的看到自己维护了多少资源，每种资源都在被哪些环境、哪些service引用； 运维人员不能显式的看到资源的使用情况及使用量； 经理不能有效的进行成本控制； 没有自动化监控系统： 运维人员不能在机器、硬件、软件出现故障时得到及时的警告，导致机器挂掉了都还不知道； 不能灵活调配各种资源的使用，导致某些资源极度紧缺、某些资源却有富余； 手动，而不是自动： 从下面的图片可以看出，只需手工运行5条命令的情况下，成功部署的概率就已跌至86%，如需手工运行55条命令，成功部署的概率将跌至22%，如需手工运行100条命令，成功部署的概率将趋近于0（仅2%）！ 为什么要有DevOps 不知道目前发布、部署的进展情况； 没有一套明确的发布、部署流程，急上线时容易出问题，出了问题也没有预案来解决； 自动化程度不够； DevOps工具链 编码：代码开发和审阅，版本控制工具、代码合并工具； 构建：持续集成工具、构建状态统计工具； 测试：通过测试和结果确定绩效的工具； 打包：成品仓库、应用程序部署前暂存； 发布：变更管理、发布审批、发布自动化； 配置：基础架构配置和部署，基础架构即代码工具； 监视：应用程序性能监视、最终用户体验； DevOps的多维度目标 团队维度：拟合开发和运维的鸿沟，支持位于全球多个地点的、包含外包人员的、混合开发/测试/基础设施的团队； 技术维度：拟合多类型的分布式的硬件平台和上面部署的多种应用、多种需求的鸿沟； 需求维度：平衡软件开发过程中对软件用户需求变化、追求稳定性、追求开发效率、降低check-in风险这几个目标； 市场维度：解决软件迭代慢和较高的用户需求的矛盾； 终极目标：从时间和空间两个维度，合理统筹并高效使用现有资源，实现组织目标，最大限度满足用户需求； DevOps需要遵循的基本原则 以人为本，一切工具都是为人服务； 需求细分，及时开发，及时验证； 减少开发的分支，尽量在主干上开发，避免合并分支造成的开销和时间浪费；另外，分支太多的时候不可能做到持续集成； 减少代码积压，代码积压越多、越多的需求和开发成果得不到验证、效率就越低、下次部署的风险就越大； 代码和配置相分离，尽量降低他们在逻辑或者物理上的耦合； 尽早生成二进制包，而不是使用源代码，并确保二进制包不被篡改； 二进制包应当和环境无关； 确保部署流程是幂等的； 对生产和测试环境的修改只能由程序，而不是人完成； 环境管理 环境必须遵循：快速部署和响应（使用docker或者其他虚拟化技术能够更容易做到这一点），可恢复，可支持，可审计； 环境配置项目： 操作系统和配置； 中间件和软件栈及配置：数据库，消息系统，队列； 基础设施软件：代码管理，目录服务，监控； 外部集成：外部系统和服务； 网络：路由，防火墙，交换机，DNS； 团队：开发团队和infra团队之间的协调分工； 自动化的环境部署； 测试环境应当和生产环境尽量一致； 环境的配置文件也应当进行版本控制； 监控 监控的内容： 硬件，物理设备，路由器，代理； 操作系统； 中间件； 应用程序； 日志； 如何监控： 清晰的信息展示； 及时的告警； 可视化的状态呈现； 常用DevOps利器 Jenkins：开源的持续集成工具； SonarQube：开源的代码质量管理系统； Puppet：开源的软件自动化配置和部署工具； Docker：让应用程序布署在软件容器下的工作可以自动化进行； 总结：DevOps到底是什么？ 高效的流水线开发/测试/上线； 自动化的环境部署和管理； 良好和及时的监控/告警/可视化/反馈/日志； 开发团队、运维团队、用户之间良好的沟通协作，快速解决问题的能力； 完整的文档； 任一模块的幂等和可恢复； 良好的审计和评估，良好的成本管理； 整个系统稳定且灵活，高度自动化； 总而言之，DevOps的核心只有三个词：高效、自动、监控； 参考 DevOps的真谛到底是什么？ 持续集成是什么？ 持续交付概述 看板管理]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flasgger使用心得]]></title>
    <url>%2F2017%2F05%2F20%2F2017-5-20-flasgger%2F</url>
    <content type="text"><![CDATA[引言 Flask是一款流行的Python实现的Web开发微框架； Swagger是一款Restful接口的文档在线自动生成+功能测试功能软件； 通过swagger能够清晰、便捷地调试符合Restful规范的API； 在flask框架中使用的swagger即为flasgger，flasgger是flask支持的swagger UI，便于调试使用flask框架搭建的web api接口； 本文介绍了flasgger的用法和不足之处。 使用方法 首先，需要在项目中安装flasgger，具体方法有两种： 方法一：在visual studio中右键工程，搜索flasgger，自动安装； 方法二：使用pip命令，pip install flasgger； 安装后，使用下面的程序框架，搭建最简单的web api： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758app = Flask(__name__)Swagger(app)@app.route('/api/&lt;string:language&gt;/', methods=['GET'])def index(language): """ This is the language awesomeness API Call this api passing a language name and get back its features --- tags: - Awesomeness Language API parameters: - name: language in: path type: string required: true description: The language name - name: size in: query type: integer description: size of awesomeness responses: 500: description: Error The language is not awesome! 200: description: A language with its awesomeness schema: id: awesome properties: language: type: string description: The language name default: Lua features: type: array description: The awesomeness list items: type: string default: ["perfect", "simple", "lovely"] """ language = language.lower().strip() features = [ "awesome", "great", "dynamic", "simple", "powerful", "amazing", "perfect", "beauty", "lovely" ] size = int(request.args.get('size', 1)) if language in ['php', 'vb', 'visualbasic', 'actionscript']: return "An error occurred, invalid language for awesomeness", 500 return jsonify( language=language, features=random.sample(features, size) )app.run(debug=True) 从上面的程序我们可以看出，只要将yaml格式的flasgger描述性程序放置在两组双引号之间的位置，即可实现flasgger的基本功能； 访问http://localhost:5000/apidocs/index.html 即可看到flasgger页面； 当然，上面的yaml描述性程序可以放置在单独的文件中，那么api中用@符号引入这个文件即可： 123456789101112131415161718192021222324252627import randomfrom flask import Flask, jsonify, requestfrom flasgger import Swaggerfrom flasgger.utils import swag_fromapp = Flask(__name__)Swagger(app)@app.route('/api/&lt;string:language&gt;/', methods=['GET'])@swag_from('index.yml')def index(language): language = language.lower().strip() features = [ "awesome", "great", "dynamic", "simple", "powerful", "amazing", "perfect", "beauty", "lovely" ] size = int(request.args.get('size', 1)) if language in ['php', 'vb', 'visualbasic', 'actionscript']: return "An error occurred, invalid language for awesomeness", 500 return jsonify( language=language, features=random.sample(features, size) )app.run(debug=True) flasgger配置文件解析： 在flasgger的配置文件中，以yaml的格式描述了flasgger页面的内容； tags标签中可以放置对这个api的描述和说明； parameters标签中可以放置这个api所需的参数，如果是GET方法，可以放置url中附带的请求参数，如果是POST方法，可以将参数放置在schema子标签下面； responses标签中可以放置返回的信息，以状态码的形式分别列出，每个状态码下可以用schema标签放置返回实体的格式； flasgger的不足 flasgger的配置文件中，对于POST方法，在描述POST body的schema标签中，不支持以yaml格式描述的数组或嵌套的object，这使得页面上面无法显示这类POST body的example； 解决方案：将这类POST body的example放置在description部分（三横杠”—“上面的部分），由于description部分是用html格式解析的，所以可以以html的语法编写； 参考 flasgger介绍 flask文档 flasgger源码 swagger官网]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Flask</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[企业财务报表分析方法]]></title>
    <url>%2F2017%2F05%2F01%2F2017-5-1-investment%2F</url>
    <content type="text"><![CDATA[引言 最近研究投资，看了肖星的一本书读懂财报，做了一些笔记； 结合一些投资的资料，总结了一下投资中，特别是股票投资中，需要知道的一些研判公司经营情况的基础概念和公式，特在本篇博客中加以记录，共大家参考； 这些概念和公式都是纸面上的，需要结合具体情况分析才有价值； 投资活动中，不能偏信任何一个公式、概念或理论，需要结合具体情况，实事求是进行分析； 非常感谢这篇公众号的总结：看过这份最全财务公式表的会计人，月薪还怕破不了5w？ 三张基础财务报表资产负债表资产负债表——所有表格的基础。从某种意义上说，一个公司的资产负债表才是根本。无论是现金流量表还是利润表都是对资产负债表的深入解释。在格雷厄姆的时代，会计准则并没有要求现金流量表。后来的会计准则进一步发展，现金流量表才成为必须。因此在格雷厄姆的《证券分析》一书中对资产负债表的论述与分析是最多的。 现金流量表——资产负债表的变化现金流量表是对资产负债表变化的解释。现金的变化最终反映到资产负债表的现金及等价物一项。而现金的变化源泉则是净利润。净利润经过“经营”、“投资”、“筹资”三项重要的现金变动转变为最终的现金变化。 首先，净利润经过营运资本的变化、摊销折旧等非现金项目、其他项目（财务支出或收入、投资收益等）的调整，最终转换为经营现金流。 其次，投资的支出与收益的现金流量。其中买卖资产对资产负债表的资产项目有影响。 最后，筹资的现金流量。其中，借债与还债会影响资产负债表的借款项目。分红与增发会影响资产负债表的股东权益项目。 利润表——净利润的来源利润表是净利润的来源。而净利润则直接影响资产负债表中股东权益的变化。 这三张表格是一个公司财务状况的精髓与总结。也是公司这个动态系统的简化模型。 财务报表汇总图 企业经营状况分析企业经营状况主要从以下三个方面进行分析： 企业偿债能力； 企业营运能力； 企业盈利能力； 企业财务报表分析公式大全偿债能力分析1、流动比率=流动资产/流动负债*100%。指标越高，企业流动资产流转越快，偿还流动负债能力越强。国际公认200%，我国150%较好。 2、速动比率=速动资产(流动资产-存货)/流动负债*100%。国际标志比率100%我国90%左右。 3、资产负债率=负债总额/资产总额*100%。指标越高负债程度高，经营风险大，能以较低的资金成本进行生产经营。保守比率不高于50%，国际公认较好60%。 4、长期资产适合率=(所有者权益+长期负债)/(固定资产+长期投资)*100% 资本状况分析1、资本保值增值率=扣除客观因素后的年末所有者权益/年初所有者权益*100%，指标越高，资本保全情况越好，企业发展潜力越大，债权人利益越有保障。 2、资本积累率=本年所有者权益增长额/年初所有者权益*100%，指标越高，所有者权益增长越快，资本积累能力越强，保全情况好，持续发展能力越大。 盈利能力分析1、主营业务毛利率=毛利(主营收入-主营成本)/主营业务收入*100%，介于20%-50%之间，一般相对合理稳定，流动性强的商品，毛利率低。设计新颖的特殊商品(时装)毛利率高。 2、主营业务净利率=净利润/主营业务收入*100%，反映企业基本获利能力。 3、主营业务成本率=主营业务成本/主营业务收入*100% 4、 营业费用率=营业费用/主营业务收入*100% 5、主营业务税金率=主营业务税金及附加/主营业务收入*100% 6、资产净利率=税后净利/平均总资产100%=主营业务净利率总资产周转率。指标高低于企业资产结构，经验管理水平有密切关系。 7、净资产收益率=净利润/平均所有者权益*100%。反映投资者投资回报率，股东期望平均年度净资产收益率能超过12%。 8、不良资产比率=年末不良资总额/年末资产总额*100% 9、资产损失比率=待处理资产损失净额/年末资产总额*100% 10、固定资产成新率=平均固定资产净值/平均固定资产原值*100% 11、 流动比率=流动资产/流动负债*100% 12、 速动比率=速动资产/流动负债*100% 13、 资产负债率=负债总额/资产总额*100% 14、长期资产适合率=(所有者权益+长期负债)/(固定资产+长期投资)*100% 15、资本保值增值率=扣除客观因素后的年末所有者权益/年初所有者权益*100% 16、资本积累率=本年所有者权益增长额/年初所有者权益*100% 17、 主营业务毛利率=毛利/主营业务收入*100% 18、 主营业务净利率=净利润/主营业务收入*100% 19、主营业务成本率=主营业务成本/主营业务收入*100% 20、 营业费用率=营业费用/主营业务收入*100% 21、主营业务税金率=主营业务税金及附加/主营业务收入*100% 22、资产净利率=税后净利/平均总资产100%=主营业务净利率总资产周转率 23、 净资产收益率=净利润/平均所有者权益*100% 24、 管理费用率=管理费用/主营业务收入*100% 25、 财务费用率=财务费用/主营业务收入*100% 26、成本、费用利润率=利润总额/(主营业务成本+期间费用)*100% 27、 销售收现比=销售收现/销售额 28、 营运指数=经营现金净流量/经营所得现金 29、 现金比率=现金余额/流动负债*100% 30、现金流动负债比=经营活动净现金流量/流动负债*100% 31、现金债务总额比=经营活动净现金流量/总负债*100% 32、 销售现金比率=经营现金净流量/销售额*100% 33、应收帐款周转率(次数)=赊销收入净额/应收帐款平均余额 34、 应收帐款周转天数 =天数/应收帐款周转次数 =计算期天数*应收帐款平均余额/赊销收入净额 销售收入净额=销售收入-现销收入-销售折扣与折让 35、 存货周转率=销售成本/平均存货 36、 存货周转天数=计算期天数/存货周转率 37、流动资产周转次数(率)=销售收入净额/流动资产平均余额 38、流动资产周转天数=计算期天数/流动资产周转次数 39、总资产周转率=销售收入净额/平均资产总额 40、总资产周转天数=计算期天数/总资产周转率 41、已获利息倍数=(税前利润总额+利息支出)/利息支出 42、总资产报酬率=(利润总额+利息支出)/平均资产总额 营运能力分析1、应收帐款周转率(次数)=赊销收入净额/应收帐款平均余额，指标高说明收帐迅速，账龄期限短，减少企业收帐费用和坏账损失。 2、 应收帐款周转天数 =天数/应收帐款周转次数 =计算期天数*应收帐款平均余额/赊销收入净额 销售收入净额=销售收入-现销收入-销售折扣与折让 3、存货周转率=销售成本/平均存货。一般情况周转速度越快，变现速度越快，占用存货资金少，占用相同数额的存货而实现的销货成本大。 4、存货周转天数=计算期天数(年360天)/存货周转率 5、流动资产周转次数(率)=销售收入净额/流动资产平均余额，指标高表明企业流动资产周转速度快，利用效果好。 6、流动资产周转天数=计算期天数/流动资产周转次数 7、总资产周转率=销售收入净额/平均资产总额。周转速度快，企业的营运能力强;指标低，说明收入不足，或资产闲置浪费。 8、 总资产周转天数=计算期天数/总资产周转率 9、已获利息倍数=(税前利润总额+利息支出)/利息支出 10、总资产报酬率=(利润总额+利息支出)/平均资产总额 综合偿债能力已获利息倍数=(税前利润总额+利息支出)÷利息支出 盈利能力： 主营业务净利率=(净利润÷主营业务收入)×100% 资产净利率=(净利润÷平均总资产)×100%=主营业务净利率*总资产周转率 净资产收益率=(净利润÷平均净资产总额)×100% 总资产报酬率=(利润总额+利息支出)÷平均资产总额 营运能力： 应收帐款周转率=主营业务收入÷应收帐款平均余额(高表明企业收帐迅速，帐龄期限短，可减少收帐费用和坏帐损失，相对增加企业流动资产的投资收益，说明资产流动性大，变现快短期偿债能力强) 存货周转率=主营业务成本÷平均存货余额(高表明企业资产由于销售顺畅而具有较高的流动性存货转现速度快存货占用水平低，过高 存货不足，产品脱销)(慢：必然占用在量的资金，造成资金浪费，营运困难) 流动资产周转率=主营业务收入÷平均资产总额 总资产周转率=主营业务收入÷平均资产总额(过低：收入不足，资产闲置,浪费) 发展能力： 销售增长率=(本年主营业务收入-上年主营业务收入)÷上年主营业务收入 资本积累率=[(年末所有者权益-年初所有者权益)÷年初所有者权益]×100% 主营业务利润 = 主营业务收入 — 主营业务成本 — 主营业务税金及附加 营业利润 = 主营业务利润 + 其他业务利润 — 期间费用 利润总额 = 营业利润 + 投资收益 + 补贴收入 + 营业外收入 — 营业外支出 净利润 = 利润总额 — 所得税]]></content>
      <categories>
        <category>feeling</category>
      </categories>
      <tags>
        <tag>feeling</tag>
        <tag>investment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[武汉游记]]></title>
    <url>%2F2017%2F04%2F30%2F2017-4-30-travel-wuhan%2F</url>
    <content type="text"><![CDATA[引言 五一假期原本准备待在家里，不过按耐不住一颗游玩的心，和女朋友一起来到武汉，近距离欣赏江城的靓丽风景； 武汉是湖北省省会、中部六省唯一的副省级市和特大城市，中国中部地区中心城市，全国重要的工业基地； 武汉地处江汉平原东部，长江中游。世界第三大河长江及其最大支流汉江横贯市境中央，将武汉中心城区一分为三，形成武昌、汉口、汉阳三镇隔江鼎力的格局； 下面，就带您领略武汉的美景。 黄鹤楼 黄鹤楼位于武汉长江南岸的武昌蛇山之巅，为国家5A级旅游景区，享有“天下江山第一楼“、”天下绝景“之称； 黄鹤楼是武汉市标志性建筑，与晴川阁、古琴台并称“武汉三大名胜”，也与湖南岳阳楼、江西南昌滕王阁并称为“江南三大名楼”； 李白的《黄鹤楼送孟浩然之广陵》就出自与此：故人西辞黄鹤楼，烟花三月下扬州，孤帆远影碧空尽，唯见长江天际流。 下图是黄鹤楼，五一人非常多，从楼下到最上层走了一个多小时； 黄鹤楼上的风景很美，可以远眺长江大桥； 长江大桥 武汉长江大桥位于湖北省武汉市武昌蛇山和汉阳龟山之间的长江江面上，是万里长江上的第一座大桥，也是新中国成立后在长江上修建的第一座复线铁路、公路两用桥，被称为“万里长江第一桥”； 武汉长江大桥是苏联援华156项工程之一，于1955年9月动工，1957年10月15日正式通车，全长约1670米。上层为公路桥（107国道），下层为双线铁路桥（京广铁路），桥身共有8墩9孔，每孔跨度为128米，桥下可通万吨巨轮； 1956年6月毛泽东题写的“一桥飞架南北，天堑变通途”，正是对武汉长江大桥沟通中国南北交通这一重要作用的真实写照，作为中国第一个五年计划主要成就，大桥图案入选1962年4月发行的第三套人民币，成为新中国国家建设的重要标志； 下图是站在长江大桥桥头照的： 站在桥上，每当有火车通过时，能够明显感觉到桥的晃动； 户部巷 作为一个吃货，无论到哪里，最重要的就是吃了，户部巷有很多好吃的，当然不能错过； 户部巷位于武昌最繁华的司门口，东靠十里长街，西临浩瀚长江，南枕“天下江山第一楼”黄鹤楼，北接都府堤红色景区，是一处由名街名楼名景名江环绕而成的美食天堂； 热干面是武汉最出名的小吃了，热腾腾的面条上浇上一勺麻酱，别提味道有多好了，除此之外，糊米酒也非常出名，糊米酒是在普通的米酒中加入了黑芝麻，集“米酒”和“芝麻糊”于一身，味道很独特； 来武汉不能不吃武昌鱼，武昌鱼分为清蒸和红烧两种，其中清蒸武昌鱼更能够保持鱼的鲜味；武昌鱼肉非常嫩，蛋白质含量高，是营养和美味的完美结合；毛主席在《水调歌头~游泳》中也曾赞美过武昌鱼的鲜美：才饮长沙水，又食武昌鱼，万里长江横渡，极目楚天舒。 藕汤是武汉挺出名的小吃，汤的味道非常鲜美，加上藕片和排骨熬制而成； 糯米团子，外面是糯米，里面的鲜猪肉； 烧麦，这是香菇大肉馅的烧麦，非常好吃； 豆皮是武汉出名的小吃，制作十分简单，将新鲜的生豆皮放入油锅中煎制即可，配上鲜萝卜丝，非常好吃；]]></content>
      <categories>
        <category>feeling</category>
      </categories>
      <tags>
        <tag>feeling</tag>
        <tag>travel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站安全架构——常用加密方法小结]]></title>
    <url>%2F2017%2F02%2F27%2F2017-2-27-web-encryption%2F</url>
    <content type="text"><![CDATA[引言 在网站的安全性架构中，常常用到各种加密方法和算法； 本文总结了几种加密方法的原理，以备不时之用； 本文不涉及技术细节； 单项散列加密 原理：采取某种算法，使得通过明文可以得到密文，但是不能由密文反推明文；这类算法的特点是，输入变化微小也能引起结果的大幅变化； 应用场景1：为安全起见，用户密码是加密后存入数据库中，验证身份时只对比密文，不对比明文；这种方法常被攻击者用彩虹表攻击（常用密码明文及其密文之间的对应关系表）； 应用场景2：用于生成信息摘要、验证信息的完整性等； 代表算法：MD5，SHA； 对称加密 原理：加密和解密使用同一个密钥，适合对大量数据进行加密； 关键点：密钥的安全性是加密算法有效性的保证； 代表算法：DES，RC； 非对称加密 分为私钥（所有者掌握）和公钥（公开），公钥加密只能私钥解开，私钥加密只能公钥解开； 应用场景1：在传递少量敏感信息时（如验证身份），可以用公钥加密，经传输后，对方使用私钥解密，这样即便传输过程中信息泄露，攻击者也不能获取明文； 应用场景2：签名者用私钥对信息（数字签名）加密，接受者用公钥进行解密，由于只有发送者掌握私钥，所以发送者对该信息不能抵赖； 代表算法：RSA； HTTPS依赖的加密算法 HTTPS(Secure Hypertext Transfer Protocol)安全超文本传输协议 它是一个安全通信通道，它基于HTTP开发，用于在客户计算机和服务器之间交换信息。它使用安全套接字层(SSL)进行信息交换，简单来说它是HTTP的安全版,是使用 TLS/SSL 加密的 HTTP 协议。 HTTP 协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，而协议 TLS/SSL 具有身份验证、信息加密和完整性校验的功能，可以避免此类问题。 TLS/SSL 全称安全传输层协议 Transport Layer Security, 是介于 TCP 和 HTTP 之间的一层安全协议，不影响原有的 TCP 协议和 HTTP 协议，所以使用 HTTPS 基本上不需要对 HTTP 页面进行太多的改造。 TLS/SSL 的功能实现主要依赖于三类基本算法：散列函数 Hash、对称加密和非对称加密，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。 如何保证密钥安全： 决不能把密钥写在源码中； 密钥也尽量不要写在配置文件中； 方案一：将密钥和算法放置在独立的服务器上，甚至做成一个专用的硬件设备，由专人维护，独立提供加密解密服务；这种方法每次都要远程调用服务，性能不太好； 方案二：将加解密算法放在应用系统中，密钥本身放在独立的服务器中，这样可改善性能；]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Safety</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新马泰游记]]></title>
    <url>%2F2017%2F02%2F18%2F2017-2-18-travel-Singapore-Malaysia-Thailand%2F</url>
    <content type="text"><![CDATA[第一次出国 新马泰之行是我第一次出国，趁着尚未正式工作，出去玩一圈长长见识，以后这样的机会就不多了； 出去玩之前，听说新加坡环境很好、马来西亚的水果很好吃、泰国有很多人妖，但这都只是听说，身临其境之后才发现，有很多东西和听说的不完全一样； 2月正值三国的旅游旺季，此时出国正和时宜； 行程整体安排： 2月9日：郑州新郑国际机场出发，经停香港，于当地时间23:45抵达曼谷素万那普国际机场； 2月10日：曼谷； 2月11日-12日：芭提雅； 2月13日：曼谷； 2月14日：曼谷素万那普国际机场出发，与北京时间11:30抵达新加坡樟宜国际机场； 2月14日-15日：新加坡； 2月15日：从新加坡陆路过境到马来西亚，并抵达马六甲； 2月16日：马六甲，并乘车抵达吉隆坡； 2月17日-18日：吉隆坡； 2月18日：从吉隆坡乘车赴新山，并通过陆路口岸过境进入新加坡，从新加坡樟宜国际机场出发，经停香港，返回郑州； 行程总里程：9880公里； 新马泰三国概况 泰国 新加坡 马来西亚 首都 曼谷 新加坡 吉隆坡 面积 513115平方公里相当于四川省大小 683平方公里相当于广州市大小 330257平方公里相当于云南省大小 人口 6800万 553万 3033万 语言 泰语 英语/马来语/华语 马来语 宗教 佛教 佛教/伊斯兰教 伊斯兰教 气候 热带季风气候均温27℃ 热带海洋气候均温33℃ 热带海洋气候均温29℃ 时差 比北京早一个小时 同北京时间 同北京时间 交通 靠左行驶 靠左行驶 靠左行驶 货币 泰铢1泰铢约兑换0.1962人民币 新加坡元1新加坡元约兑换4.8389人民币 林吉特1林吉特约兑换1.5421人民币 电压 220V 220V英式插头 240V英式插头 紧急电话 报警 191火警 199急救 1691 报警 999火警 995急救 995 报警 999火警 994急救 999 泰国 泰国的货币是泰铢，到机场后先兑换了一些： 泰国的饮食酸甜居多，菜里面一般会放一些黄色的尖椒调味，所以菜品普遍偏辣，下图是酒店的自助早餐，包括炒洋葱、炒豆芽等： 泰国议会制的君主立宪制国家。泰国人多信仰佛教。在古代，泰国地区的人看病、上学、结婚等事宜都是在寺庙中完成的。直至今日，泰国的酒店每天早晨都能看到前来化缘的僧人。 泰国国王在民众心目中的地位非常高，举例来说，每到毕业季，国王会巡游77个省、并亲自向大学生颁发毕业证书，普通民众家里如果能拜访一张和泰国国王的合照是非常荣耀的事情。国王的生日2月5日被定为泰国的父亲节。 泰国国王登基的地方就是大皇宫，这是历代王宫保存最完美、规模最大、最有民族特色的王宫，是泰国的”故宫“。大皇宫位于曼谷市中心，紧邻湄南河，及政治、宗教、艺术于一体，堪称世界瑰宝，供奉贴金佛像地方必须脱鞋进入。 大皇宫中建筑金碧辉煌，其实这是金色油漆和彩色玻璃的杰作，但在古代，这可都是真正的黄金和宝石啊！ 参观完大皇宫，旁边就是世界闻名的湄南河，这条河是古时候泰国的通商要道，河道旁边全是商店和餐馆： 湄南河旁边的餐馆中，泰式的炒米饭尤其受欢迎： 在芭提雅的格兰岛，对于像我一样的内地人而言，最重要的一项活动就是看海了，宽广的太平洋一望无际，海水十分清澈。在海里游泳的感觉和在游泳池里大不一样。在这里，我完成了人生的第一次潜水。 在芭提雅滨海的56层高的观光塔上，纵览芭提雅全景，这个三面临海的城市，给我留下深刻印象： 无意中还发现了泰国版的红牛，酸甜可口，非常好喝： 新加坡 从曼谷距新加坡大概1500公里，飞行约3个小时，飞机上的景色非常美，能当屏保了： 新加坡的货币是新元，到机场先换了几张： 到了新加坡，我才知道这些新加坡独有的特色： 新加坡很小，东西最长处仅45公里，所有吃的东西靠进口； 新加坡距赤道仅137公里，每天都下2-3场雨，气候非常湿润； 在新加坡，所有的自来水均可直接饮用，边洗澡边喝水也是可以的； 新加坡实行12年义务教育，小学上课时间07:30-13:30，下午不上课，好幸福； 新加坡贩卖口香糖非法，要罚款5000新币并做9个月的牢； 新加坡生孩子第一胎奖励1.2万新元，第二胎奖励2.4万新元，以此类推，但这个钱家长取不出来，只能供孩子使用； 新加坡所有的电梯没有4和13，不吉利； 新加坡车牌只有10年使用权，过期只能再买； 新加坡房价均价只有1万人民币，不过只卖给本国人，由于太潮，一楼不住人； 新加坡药店很少，所有口服药必须有医生允许才能买到，60岁以上老人体检免费； 新加坡的酒非常贵，而且政府对酒有严格的控制，晚上十点以后不能买酒、所有超市的收银台无法扫描酒类商品（包括烧菜用的料酒）； 新加坡圣淘沙岛上的赌场非常有名，里面聚集了世界各地的土豪，但有三种人不能进入赌场：21岁以下的，被加入黑名单的，本地人不让进(除非买100新元门票才让进，外国人持护照免费进入)，赌场都不是新加坡政府开的，都是外国政府投资； 小心翼翼的进去转了一圈，有几百张赌桌，上面摆放着花花绿绿的筹码，有各种玩法，和电影上看到的差不多。由于赌场内部严禁拍照，所以只能上一张赌场的外景： 圣淘沙岛上有一尊高35米的狮身鱼尾雕塑，夜景非常美： 酒店旁边有很多大排档。新加坡的大排档不像国内给人一种不卫生的感觉，这里非常干净，地板看不到一片污渍或者纸屑。我点了一份烤巴沙鱼，5.5新币，鱼肉滑嫩入味，味道非常鲜美： 新加坡地方虽小，但是整个城市给人干净、整洁、有序的感觉，下图分别是滨海艺术中心、金融区、赌场外景、狮身鱼尾像、国会大厦和高等法院： 马来西亚 吉隆坡以南41公里的太子城是马来西亚耗资81亿美元新建的行政中心，红色的建筑是太子清真寺，由于是用粉红色的大理石建成，故又称粉红清真寺。进入清真寺要脱鞋，光脚踩着滚烫的石阶、高大的穹顶、彩色的琉璃令人流连忘返。 清真寺旁边绿顶的建筑，就是新建的首相府。真是美得无法形容！ 驱车来到吉隆坡，首先参观了位于市中心的吉隆坡塔； 马来西亚曾经是英国和荷兰殖民地，二战期间曾被日本占领，经历了坎坷的民族独立和解放斗争。 马来西亚人多信仰伊斯兰教，故酒店中天花板上一般有一个向西的标志，方便做礼拜，而且酒店卫生间的马桶旁总是放着一个用来解决个人如厕后卫生问题的喷头： 新马泰游小提示 关于行李： 不要带生鲜食品，否则过不了检验检疫； 可以带少量未开封的零食，如小面包、豆干； 托运行李中不要放置打火机、锂电池等物品，锂电池、照相机等电子产品不能托运，需要随身携带； 新加坡只允许携带19根香烟入境，不能携带酒，不能携带口香糖； 可以带一些驱蚊液、防晒霜； 国际航班提前3个小时办理登机手续，不要迟到了； 在国外需要保管好护照，如果丢失护照，需要立即和中国大使馆联系申请临时护照；申请临时护照时，需要用到个人照片，为了以防万一，出发前最好随身携带2张2寸白底近期免冠照； 新马泰三国均为靠左行驶，过马路时需要特别注意，遵守当地交通法规； 泰国是小费制国家，泰国酒店需要给服务生小费，标准：20泰铢/人/天，其他服务（如服务生提行李、参加骑大象活动、当地的导游和司机等）也需要给相应数量的小费；小费必须是纸币，不能给硬币； 参观曼谷大皇宫等景点时，为了表达对国王的尊重，不能穿拖鞋、背心、无袖上衣、短裤等，女士尽量穿着过膝长裙； 以下的app在国外非常好用： 社交类：facebook，twitter； 地图：Google map，Here； 住宿和酒店：Booking，Airbnb； 车辆和交通：Grab； 可以在机场兑换一些当地货币，以免在买水或者零食时遇到麻烦； 大额消费尽量刷卡，这样可以有机会获得优惠的汇率，具体优惠程度参照商店的标准； 国外的通信费较高，中国移动在开通国际漫游后，新马泰三国的移动数据流量费为1元人民币/M，如果游玩天数较多，建议在机场办理当地不限流量的电话卡，或者提前在淘宝上买； 因为宗教信仰等原因，马来西亚的厕所可能没有纸巾，当地人习惯使用马桶旁边的小水管解决如厕后的个人卫生问题，所以记得携带手纸；]]></content>
      <categories>
        <category>feeling</category>
      </categories>
      <tags>
        <tag>feeling</tag>
        <tag>travel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016我的年度书单]]></title>
    <url>%2F2016%2F12%2F12%2Fyear-books%2F</url>
    <content type="text"><![CDATA[引言 2016年，我把所有的精力都放在了找实习和工作上，同时还要完成学校要求的小论文和毕业论文，几乎没什么精力来读“闲书”，下面这些书都是每天临睡前看一会儿，积少成多读完的。 读书能让我静下心，认真思考我自己，认真思考这个世界，思考清楚了，才有“静力”，做起事情来才更有“动力”。 我不喜欢读电子书，下面所有的书我都是买来或者从图书馆借来纸质版的书籍阅读。 我认为自己思想还不够深入、品性还需要磨砺，我读书的目的正是为了修炼性格、磨砺自己。 下面是我的2016书单，欢迎大家赞赏、吐槽、拍砖。 2016-我的书单 《自卑与超越》 作者： [奥地利] 阿弗雷德·阿德勒 本书作者阿弗雷德·阿德勒是弗洛伊德精神分析学派的核心成员之一，他立足于个体心理学，在本书中全面阐释了自卑的含义和意义，对人的自卑心理全面分析，将自卑的产生、发展、认识描绘的淋漓尽致，是对人性中自卑情结最为深刻的刻画。 本书不仅具有较大的理论价值，也具有较大的使用价值。本书从社会生活、商业、人文、教育等多方面分析了自卑情结，深刻揭示了人的行为和内在的自卑情结的联系，深入诠释了接受自卑比克服自卑更加重要这一事实。 本书绝对不仅仅讲了自卑，也绝不是只有自认为自卑的人才需要阅读，本书通过自卑揭示了一些不为人知的心理学原理，而这些原理又是被广泛应用在社会生活中的，我强烈推荐所有对心理学感兴趣的朋友阅读此书！ 《追求意义的意志》 作者: [奥地利] 维克多·弗兰克尔 本书的作者维克多·弗兰克尔出生于奥地利，是美国著名的临床心理学家，获得维也纳大学医学博士和哲学博士学位。他亲历了二战，在希特勒占领奥地利后为了照顾年迈的父母，在获得美国签证的情况下没有逃离险境，而是坚持留在奥地利，最终被送进集中营。在集中营中，他亲眼见证了一个个生命的逝去，在巨大的痛苦和伤痛中不断思考生命的价值和意义，从痛苦、彷徨、抑郁甚至死亡的边缘寻找那一点点的亮光和希望。在那种情境下，生命只是囚服上的号码牌，没有人知道自己什么时候会被送进毒气室，生命的意义和存在的价值到底在哪里？恐怕只有像作者这样的亲历者才有资格回答这个问题。放眼望去，人类所经历的一切痛苦是否是值得的？作为一个个体，在社会中所经历的痛苦是否是值得的？思考这些问题可能会让你暂时感到恐惧和无助，但只有思考清楚了这些问题，我们才能从心底感到希望和快乐，真正明白活着是为了什么、我们现在的所有付出和努力是为了什么。 刚开始阅读本书时，我将书名误认为《追求意志的意义》，读了几章，发现不对劲，回头一看标题，方才豁然开朗，明白了作者的想表达的含义。 文本作者被称之为继弗洛伊德的心理分析、阿德勒的个体心理学之后的维也纳第三心理治疗学派。我强烈建议对心理学感兴趣的朋友们阅读此书。 《脆弱的力量》 作者：[美] 布琳·布朗 本文作者是最受欢迎的5大TED演讲者、美国最具影响力女性之一的布琳·布朗，如果您没有时间阅读本书，建议直接观看作者同一主题的TED演讲视频。 本书从脆弱和羞耻感的角度研究了爱、归属感和人生，将脆弱和力量这两个看似矛盾的词汇完美的统一起来，让人们意识到脆弱的意义和价值所在，也让人们对不确定性和危机感不再恐惧。 《非暴力沟通》 作者：[美] 马歇尔·卢森堡 本书是沟通领域的佳作，从心理学的角度描绘了人的观察和评论的不统一性、体会和表达的不统一性、事实和感受的不统一性。什么时候应该尊重事实？什么时候又应该尊重感受？作者给出了自己的回答。 倾听是解决沟通障碍的良药，怎样有效倾听对方的感受、最大程度地减少伤害？读完本书，您心中自然会有答案。 《钝感力》 作者：[日] 渡边淳一 本书送给像我一样对于他人的看法和感受比较敏感的朋友。 本书的作者是日本著名的医学家、小说家，曾获得医学博士学位。本文从医学的角度描绘了“钝感力”作为一种为人处世的态度及人生智慧，相比激进、张扬、刚硬而言，更易在目前竞争激烈、节奏飞快、错综复杂的现代社会中生存，也更易取得成功。 《亲爱的安德烈》 作者：[中] 龙应台 《目送》、《孩子你慢慢来》、《亲爱的安德烈》是著名作家龙应台的亲情三部曲，其中我最喜欢这本《亲爱的安德烈》。 书中充分和细腻的描述了这位母亲在儿子长大后理性上和感性上的冲突，既希望儿子陪在身边、又希望儿子独立奋斗，既希望儿子理解自己、又怕自己已经和时代脱节。于是，母子俩用了三年时间互相通信，龙应台“认识了人生里第一个十八岁的人”，安德烈“也第一次认识了自己的母亲”。 《思想的星空》 作者: [中] 周国平 本文作者周国平是中国社会科学院哲学研究所研究员，他的作品充满了人生的智慧和哲学的魅力，融理性和激情于一体，笔调清新自然，内涵睿智深刻，在这里同时推荐他的其他作品：《尼采美学文选》、《尼采诗集》、《偶像的黄昏》。 《幸福的方法》 作者：[美] 泰勒·本·沙哈尔 本文作者泰勒·本·沙哈尔是哈佛大学心理学硕士、哲学和组织行为学博士，著名的《幸福课》就是他本人开创的。 本书用充满智慧的语言、科学实证的方法、自助成功的案例和巧妙创新的编排，让人们能够把积极心理学应用到日常生活之中。]]></content>
      <tags>
        <tag>books</tag>
        <tag>feeling</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于leetcode环形链表相关题目的总结]]></title>
    <url>%2F2016%2F07%2F20%2F2016-7-20-roll-linkedlist%2F</url>
    <content type="text"><![CDATA[引言 这几天，博主总结了一些leetcode的链表题目，本文参考了网上大牛的文章，结合自己的想法，总结了环形链表的解决方案，欢迎各位补充／批评指正。 建模 链表头节点是X，环的第一个节点是Y; slow和fast分别是指针，如果从链表头部开始往后移动，且fast指针移动速度为slow指针移动速度的两倍，设第一次的交点是Z； 各段的长度分别是a,b,c，如图所示； 环的长度是L； slow和fast指针的向前移动速度分别是qs,qf； 判断链表是否有环（leetcode 141） fast如果走到了null，证明没有环； fast如果和slow相遇了，证明有环； 代码如下： 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public boolean hasCycle(ListNode head) &#123; ListNode fast = head; ListNode slow = head; while(fast!=null&amp;&amp;fast.next!=null)&#123; slow = slow.next; fast = fast.next.next; if(fast==slow)&#123; return true; &#125; &#125; return false; &#125;&#125; 环长度是多少 方法一：在第一次相遇后，相当于slow和fast的距离是一个环的长度，继续让这两个指针以各自的速度去走，下一次相遇时，走过的节点数即为环的长度； 方法二：第一次相遇后，让fast停着不走了，slow继续走，记录到下次相遇时走过了几个节点，即为环的长度； 方法三：第一次相遇时slow走过的距离：a+b，fast走过的距离：a+b+c+b；因为fast的速度是slow的两倍，所以fast走的距离是slow的两倍，有 2(a+b) = a+b+c+b；可以得到a=c；最终我们得到L=b+c=a+b，也就是说，从一开始到二者第一次相遇，循环的次数就等于环的长度； 找到环中的第一个节点（leetcode 142） 我们已经得到了结论a=c； 那么让两个指针分别从X和Z开始走，每次走一步，那么正好会在Y相遇，也就是环的第一个节点； 代码如下： 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; ListNode fast = head; ListNode slow = head; while(fast!=null&amp;&amp;fast.next!=null)&#123; slow = slow.next; fast = fast.next.next; if(slow==fast)&#123; fast = head; while(fast!=slow)&#123; slow = slow.next; fast = fast.next; &#125; return slow; &#125; &#125; return null; &#125;&#125; 如何将有环的链表变成单链表（解除环） 在上一个问题的最后，将c段中Y点之前的那个节点与Y的链接切断即可； 如何判断两个单链表是否有交点，如何找到第一个相交的节点（leetcode 160） 先判断两个链表是否有环； 如果一个有环一个没环，肯定不相交； 如果两个都没有环，判断两个列表的尾部是否相等； 如果两个都有环，判断一个链表上的Z点是否在另一个链表上； 找到第一个相交的节点方法： 求出两个链表的长度L1,L2（如果有环，则将Y点当做尾节点来算）; 假设L1&lt;L2，用两个指针分别从两个链表的头部开始走; 长度为L2的链表先走(L2-L1)步，然后两个一起走，直到二者相遇； 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public static int getLength(ListNode head)&#123; ListNode point = head; int length = 1; while(point!=null)&#123; length++; point = point.next; &#125; return length; &#125; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; int aLength = getLength(headA); int bLength = getLength(headB); int diff = Math.max(aLength,bLength)-Math.min(aLength,bLength); ListNode pointA = headA; ListNode pointB = headB; while(diff&gt;0)&#123; if(aLength&gt;bLength)&#123; pointA = pointA.next; &#125;else if(aLength&lt;bLength)&#123; pointB = pointB.next; &#125; diff--; &#125; while(pointA!=pointB)&#123; pointA = pointA.next; pointB = pointB.next; &#125; return pointA; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Linkedlist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的遍历]]></title>
    <url>%2F2016%2F05%2F11%2F2016-5-11-tree-traversal%2F</url>
    <content type="text"><![CDATA[引言 本文展示了二叉树的前序遍历、中序遍历、后序遍历; 每种遍历均用递归和非递归的方法实现。 递归的方法明显比非递归的方法容易理解。 非递归的实现方式有很多种，本文给出了用一个栈实现的方法。 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164package test;import java.util.Stack;public class Test &#123; public static class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125; public static TreeNode BinaryTree(int[] array) &#123; return makeBinaryTreeByArray(array, 1); &#125; public static TreeNode makeBinaryTreeByArray(int[] array, int index) &#123; if (index &lt; array.length) &#123; int value = array[index]; if (value != 0) &#123; TreeNode t = new TreeNode(value); array[index] = 0; t.left = makeBinaryTreeByArray(array, index * 2); t.right = makeBinaryTreeByArray(array, index * 2 + 1); return t; &#125; &#125; return null; &#125; //前序遍历 递归实现 public static void preTraversal(TreeNode root)&#123; if(root==null)&#123; return; &#125; System.out.print(root.val+" "); preTraversal(root.left); preTraversal(root.right); &#125; //前序遍历 非递归实现(栈) public static void preTraversal1(TreeNode root)&#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); if(root==null)&#123; return; &#125; stack.push(root); while(!stack.isEmpty())&#123; TreeNode tmp = stack.pop(); System.out.print(tmp.val+" "); if(tmp.right!=null)&#123; stack.push(tmp.right); &#125; if(tmp.left!=null)&#123; stack.push(tmp.left); &#125; &#125; &#125; //中序遍历 递归实现 public static void midTraversal(TreeNode root)&#123; if(root==null)&#123; return; &#125; if(root.left!=null)&#123; midTraversal(root.left); &#125; System.out.print(root.val+" "); if(root.right!=null)&#123; midTraversal(root.right); &#125; &#125; //中序遍历 非递归实现(栈) public static void midTraversal1(TreeNode root)&#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode node = root; while (node != null || stack.size() &gt; 0) &#123; while (node != null) &#123; stack.push(node); node = node.left; &#125; if (stack.size() &gt; 0) &#123; node = stack.pop(); System.out.print(node.val+" "); node = node.right; &#125; &#125; &#125; //后序遍历 递归实现 public static void behTraversal(TreeNode root)&#123; if(root==null)&#123; return; &#125; if(root.left!=null)&#123; behTraversal(root.left); &#125; if(root.right!=null)&#123; behTraversal(root.right); &#125; System.out.print(root.val+" "); &#125; //后序遍历 非递归实现(栈) public static void behTraversal1(TreeNode root)&#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); TreeNode node = root, prev = root; while (node != null || stack.size() &gt; 0) &#123; while (node != null) &#123; stack.push(node); node = node.left; &#125; if (stack.size() &gt; 0) &#123; TreeNode temp = stack.peek().right; if (temp == null || temp == prev) &#123; node = stack.pop(); System.out.print(node.val+" "); prev = node; node = null; &#125; else &#123; node = temp; &#125; &#125; &#125; &#125; /** * 13 * / \ * 65 5 * / \ \ * 97 25 37 * / /\ / * 22 4 28 32 */ public static void main(String[] args) &#123; int[] arr = &#123; 0, 13, 65, 5, 97, 25, 0, 37, 22, 0, 4, 28, 0, 0, 32, 0 &#125;; TreeNode root = BinaryTree(arr); preTraversal(root); //13 65 97 22 25 4 28 5 37 32 System.out.print("\n"); preTraversal1(root); //13 65 97 22 25 4 28 5 37 32 System.out.print("\n"); midTraversal(root); //22 97 65 4 25 28 13 5 32 37 System.out.print("\n"); midTraversal1(root); //22 97 65 4 25 28 13 5 32 37 System.out.print("\n"); behTraversal(root); //22 97 4 28 25 65 32 37 5 13 System.out.print("\n"); behTraversal1(root); //22 97 4 28 25 65 32 37 5 13 &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对Leetcode 264题的一些思考]]></title>
    <url>%2F2016%2F05%2F10%2F2016-5-10-Leetcode-264%2F</url>
    <content type="text"><![CDATA[引言 本文展示了我对于leetcode264题的思考，如有不正确之处，请各位大神多多指教。 题目 Write a program to find the n-th ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers. Note that 1 is typically treated as an ugly number. 解法 思路：下一个丑数是上一个丑数乘以一个数（2 3 5），但是，这样算出来的丑数不一定是有序的，比如，上一个丑数是3，3*2=6也是丑数，但是比他小的4 5也是丑数，就被隔过去了。 所以如果能将上面的思路改写成一个有序的方法就好了。 在丑数的序列中，总能找到这样一个数，它乘2刚刚大于目前序列中最大的丑数，也总能找到这样一个数，它乘3刚刚大于目前序列中最大的丑数，也总能找到这样一个数，它乘4刚刚大于目前序列中最大的丑数，我们要找的“下一个丑数”即为上面三个数中最大的一个。 程序中，我们用m2、m3、m5三个下标，表示上述三个数在已经有序的丑数序列中的位置。 之所以每一循环，三个if均需检测，是因为如果遇到了某个丑数能够有多种方法分解（2 3 5）质因数，那么此时，m2、m3、m5三个下标可能需要同时移动，否则他们乘2（3或5）后就不是刚刚好大于目前序列中最大的丑数了。 程序12345678910111213141516171819202122232425262728public class Solution &#123; public int nthUglyNumber(int n) &#123; if(n==1)&#123; return 1; &#125; int m2 = 0; int m3 = 0; int m5 = 0; int tmp = 0; int count = 1; int[] uglyNumber = new int[n]; uglyNumber[0]=1; while(count&lt;n)&#123; tmp = Math.min(uglyNumber[m2]*2,Math.min(uglyNumber[m3]*3,uglyNumber[m5]*5)); if(tmp==uglyNumber[m2]*2) m2++; if(tmp==uglyNumber[m3]*3) m3++; if(tmp==uglyNumber[m5]*5) m5++; uglyNumber[count] = tmp; count++; &#125; return uglyNumber[n-1]; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表的反转]]></title>
    <url>%2F2016%2F05%2F08%2F2016-5-8-list-transfer%2F</url>
    <content type="text"><![CDATA[引言 本文展示了链表的反转的代码，用递归和非递归的方式实现。 详细的链表反转见leetcode 206的解法。 递归的实现12345678910111213public class Solution &#123; public ListNode reverseList(ListNode head) &#123; if(head==null) return null; if(head.next==null) return head; ListNode p = head.next; ListNode n = reverseList(p); head.next = null; p.next = head; return n; &#125;&#125; 非递归的实现123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode reverseList(ListNode head) &#123; if(head==null)&#123; return null; &#125; ListNode point1 = head; ListNode point2 = head.next; ListNode point3 = (point2==null)?null:point2.next; while(point2!=null)&#123; //System.out.println("----"); point3 = point2.next; point2.next = point1; point1 = point2; point2 = point3; &#125; head.next=null; return point1; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Linkedlist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树的广度优先遍历和深度优先遍历]]></title>
    <url>%2F2016%2F05%2F07%2F2016-5-7-BFT-DFT%2F</url>
    <content type="text"><![CDATA[引言 本文介绍了树的广度优先和深度优先遍历，并给出程序。 原理 广度优先遍历（BFT breadth-first traversal）：广度优先遍历是连通图的一种遍历策略，它的思想是从一个顶点V0开始，辐射状地优先遍历其周围较广的区域，故得名。树的广度优先遍历是指优先遍历完某一层的所有节点，然后再依次向下层遍历。 深度优先遍历（DFT depth-first traversal）：树的深度优先遍历是指首先遍历树的某个分支上的所有节点，在遍历另一个分支的节点，对于节点中的分支也这样处理。 广度优先和深度优先各有其侧重点，在不同的情境下可以选择使用。 本文不讨论广度优先和深度优先的适用场景，只给出两者的具体实现java代码，以供参考。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package test;import java.util.ArrayDeque;import java.util.Queue;import java.util.Stack;public class Test &#123; //树的节点的定义 public static class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125; //构建树 public static TreeNode BinaryTree(int[] array) &#123; return makeBinaryTreeByArray(array, 1); &#125; public static TreeNode makeBinaryTreeByArray(int[] array, int index) &#123; if (index &lt; array.length) &#123; int value = array[index]; if (value != 0) &#123; TreeNode t = new TreeNode(value); array[index] = 0; t.left = makeBinaryTreeByArray(array, index * 2); t.right = makeBinaryTreeByArray(array, index * 2 + 1); return t; &#125; &#125; return null; &#125; public static void levelOrderTraversal(TreeNode root) &#123; // 用队列 if (root == null) &#123; return; &#125; Queue&lt;TreeNode&gt; q1 = new ArrayDeque&lt;&gt;(); q1.add(root); while (!q1.isEmpty()) &#123; TreeNode tmp = q1.poll(); System.out.print(tmp.val+" "); if (tmp.left != null) &#123; q1.add(tmp.left); &#125; if (tmp.right != null) &#123; q1.add(tmp.right); &#125; &#125; &#125; public static void depthOrderTraversal(TreeNode root)&#123; // 用栈 if(root==null)&#123; return; &#125; Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;(); s.push(root); while(!s.isEmpty())&#123; TreeNode tmp = s.pop(); System.out.print(tmp.val+" "); if(tmp.right!=null)&#123; s.push(tmp.right); &#125; if(tmp.left!=null)&#123; s.push(tmp.left); &#125; &#125; &#125; /** * 13 * / \ * 65 5 * / \ \ * 97 25 37 * / /\ / * 22 4 28 32 */ public static void main(String[] args) &#123; int[] arr = &#123;0,13,65,5,97,25,0,37,22,0,4,28,0,0,32,0&#125;; TreeNode root = BinaryTree(arr); levelOrderTraversal(root); //13 65 5 97 25 37 22 4 28 32 System.out.print("\n"); depthOrderTraversal(root); //13 65 97 22 25 4 28 5 37 32 &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库设计原则]]></title>
    <url>%2F2016%2F05%2F06%2F2016-5-6-database-design%2F</url>
    <content type="text"><![CDATA[引言 本文小结了数据设计原则； 数据库设计对于数据库的可维护性、可扩展性至关重要，某些原则必须严格遵守； 数据库设计范式 第一范式：属性具有原子性，不可再分解，即不能表中有表； 第二范式：唯一性约束，每条记录有唯一标示，所有的非主键字段均需依赖于主键字段； 第三范式：冗余性约束，非主键字段间不能相互依赖； 数据库设计原则 完整性： not null声明禁止插入空值； check子句限制属性域； 去冗余： 避免冗余属性，冗余属性会带来数据不一致性； 学生选课系统中，老师可以开课、学生可以选课，数据库设计中，课程可以由课程编号和课程名称等确定； 如果现在维护两个表，一个表A存储课程信息（课程编号、名称、简介、学分、院系等），另一个表B存储开课信息（有哪些课程开课），如果B中重复存储了A的课程名称、简介、学分、院系等信息，一旦A中的信息更新，B中和A中信息便出现不一致； 正确的做法是，B中只存储课程编号，并以此和A相关联； 解耦合： 一个表只存储它应该存储的信息，和此表无关的信息放到另一个表去存储，表之间尽量解耦； 上面的例子中，A中存储且只存储面向课程的信息，另外有表C，存储且只存储面向学生的信息（学号、姓名、性别、年龄、选课id等），对于“课程级别”的信息，应当坚决的存储在A而不是C中，而且尽量避免将A、C合并成一个表（可能刚开始是设计成一个表），而且A、C间尽量解耦； 字段不可再分： 一个字段中不要出现分隔符，或者在一个字段中存储多个信息; 例如，first name和last name不要放在同一个字段中，稳定版本号和临时版本号不要放在同一个字段中； 考虑性能： 上述原则可能造成多表连接查询的情况出现，降低性能； 如果性能成为主要矛盾，则上述原则也不绝对； 数据库命名原则 数据库的命名会直接影响到上层应用的名称，所以要和业务部门仔细讨论、慎重确定； 每个属性名在数据库中只有唯一的含义，number这个属性名可能表示电话号码或是房间号，这是一种容易引起歧义的命名； 数据库的名词要一致，不能在这个地方叫一个名字，到另外一个表又叫另外一个名字； 一般来说，Table命名用单数，Column命名用单数； Table不用Prefix前缀来表示不同的组，而用schema来划分命名空间（postgresql中）； 命名用snake_case，不要有其他特殊字符； 名称中不要有sql关键字； 如果确实需要使用sql关键字，可用双引号包围，比如CREATE TABLE &quot;order&quot;(...)； 主键的名字永远都是同一的，就是id，外键名称才需要加table的名字，诸如xxx_id、yyy_id； 命名不要用缩写，比如date缩写成dt； 用 create_date/update_date/sample_date这些含义更明确的名称代替date这个命名，这样不仅表达更准确，而且避免了用关键字的麻烦； timestamp类型的字段要有timezone（时区），字段名用xxx_date的形式，仅表示年月日用xxx_day，仅表示时分秒用xxx_time； 表示数量、次数等概念的字段名称最好写为xxx_count，不要写为xxx_number/xxx_num/xxx_no等； boolean类型的命名要用is_xxx格式； 数据库设计其他注意事项 每个表都要有主键，名称是id，类型为bigint； 主键的类型是设为integer还是long，取决于这个系统用多长时间，如果要用100年，主键还是设置为long类型较好，这样用的很久以后id也不会超出范围； 一个字段不要有多个用途，空间不是问题，清晰才是重点； 不要过早优化，先把东西做出来再说，遇到性能问题再去优化； 对于varchar类型的字段，当字符串并不是非常明确到底限制是多少的时候，通常选择255这个长度，varchar(50)并不比varchar(255)节省空间，varchar(50)仅仅是表示最多分配50个字符而已； varchar(100)类型在PostgreSQL中代表100个字符，而在Oracle中代表100字节，具体的占用空间数目和语言、编码方式有关； 对外键要加Index； 数据库里面的密码一定要加密，不能保存明文； 用is_deleted=true来表示本条记录的业务上的删除，不要在数据库中真正删除记录，或者仅仅是版本化修改，这样能防止数据丢失； 数据库性能提升方案 使用索引会大大提升查询效率，同时降低在被索引的表上INSERT和DELETE效率； 分离频繁和不频繁使用的数据到多个表中； 例如，原先，一个表中保存用户名、密码、年龄、个人简介、学校等信息，但是发现访问用户名、密码、年龄的频率远高于其他字段，此时就应当将这个表分为两个表，分别存储频繁访问项和非频繁访问项； 数据库安全策略 至少保存3个月的系统访问日志； 数据库中的表可以有创建和更新时间戳，及所创建/修改行的用户标示； 不删除字段，而是打上一个被删除的标记； 版本化修改； 大型数据库设计 负载均衡； 读写分离； 分布式存储； 参考这篇文章；]]></content>
      <categories>
        <category>datebase</category>
      </categories>
      <tags>
        <tag>datebase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库查询优化方案小结]]></title>
    <url>%2F2016%2F05%2F02%2F2016-5-2-database-search%2F</url>
    <content type="text"><![CDATA[引言 本文小结了数据查询的优化方案； 查询耗时点 解析SQL语句时间； 磁盘存取（查询所用CPU时间）； 磁盘IO； 并行/分布式数据库的网络通信时间； 其中，磁盘存取一般认为是耗时最多的点； 数据库层面的优化 优化器设计（可将用户输入语句转换为等价的效率更高的执行语句）； 优化索引设计； 优化查询算法： 在等价的查询语句中，选择读磁盘最少的那个； 对于简单的查询语句，可通过线性扫描和搜索引擎处理； 对于复杂的查询，将它转换为简单查询的并和交； 用外部归并排序算法对大于内存的关系进行排序； 用户层面的优化 避免出现SELECT * FROM table 语句，要明确查出的字段； 在一个SQL语句中，如果一个where条件过滤的数据库记录越多，定位越准确，则该where条件越应该前移； 使用内层限定原则，在拼写SQL语句时，将查询条件分解、分类，并尽量在SQL语句的最里层进行限定，以减少数据的处理量； 在判断有无符合条件的记录时建议不要用SELECT COUNT （*）和select top 1 语句； 小心使用 IN 和 OR，需要注意In集合中的数据量，建议集合中的数据不超过200个； 应绝对避免在order by子句中使用表达式； &lt;&gt; 用 &lt; 、 &gt; 代替，&gt;用&gt;=代替，&lt;用&lt;=代替，这样可以有效的利用索引； 如果需要从关联表读数据，关联的表一般不要超过7个； 在一个事务中，对同一个表的多个insert语句应该集中在一起执行；]]></content>
      <categories>
        <category>datebase</category>
      </categories>
      <tags>
        <tag>datebase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库事务]]></title>
    <url>%2F2016%2F05%2F01%2F2016-5-1-database-transaction%2F</url>
    <content type="text"><![CDATA[引言 事务是数据库的重要概念； 事务处理是数据库的核心机制之一； 本文总结数据库事务的相关概念； 事务的概念可参考这篇文章 事务的性质 事务是数据库并发控制的基本单元； 事务是一个操作序列，不可分割，要么都执行，要么都不执行； 事务开始前和结束后，数据库中的数据应当保持一致性； 对数据库修改的多个事务彼此隔离，每个事务不应当影响或依赖其他事务； 数据库事务的四个特性及含义 性质 含义 原子性（atomicity） 一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节；事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样；可以维护一个日志（或快照）记录事务执行前数据库的状态，如果事务执行失败，则回滚到事务执行前的状态；转账时，不可能发生转出账户扣款了，转入账户未到账的情况； 一致性（consistency） 在事务开始之前和事务结束以后，数据库的完整性没有被破坏；转账时，账户总金额不能多也不能少，保持一致性； 隔离性（isolation） 数据库允许多个并发事务同时对齐数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致；事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable），下面详细讲了； 持久性（durability） 事务处理结束后，对数据的修改就是永久的，即便系统出现故障，即真正持久化到数据库中； 事务执行进度 begin：开始执行事务； aborted：事务执行一半终止了； roll back：事务已经回滚； commited：事务已提交，即执行成功，已经持久化到数据库中； 事务并发产生的问题 脏读： 一个事务读取了另一个事务操作但未提交的数据； 事务T1更新了数据还未提交，这时事务T2来读取相同的数据，则T2读到的数据其实是错误的数据，即脏数据，如果T1回滚的话，T2读到的数据是不可靠的； 基于脏数据所作的操作是不可能正确的； 丢失更新： 事务T1读取了数据，并执行了一些操作，然后更新数据，事务T2也做相同的事，则T1和T2更新数据时可能会覆盖对方的更新，从而引起错误； 用排他锁解决； 不可重复读： 一个事务中的多个相同的查询返回了不同数据； 一个事务的两次读取中，读取相同的资源得到不同的值，当事务T2在事务T1的两次读取之间更新数据，则会发生此种错误（重点在修改）； 用共享锁解决； 幻读： 事务并发执行时，其中一个事务对另一个事务中操作的结果集的影响； 事务T1对一定范围内执行操作，T2对相同的范围内执行不兼容的操作，这时会发生幻读； T1删除符合条件C1的所有数据，T2又插入了一些符合条件C1的数据，则在T1中再次查找符合条件C1的数据还是可以查到，这对T1来说好像是幻觉一样，这时的读取操作称为幻读（重点在新增或删除）； 用排它锁解决； 事务隔离级别 下面是数据库事务从高到低的四个隔离级别； 级别名称 含义 可串行化（Serializable） 提供严格的事务隔离；它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行; 可重复读（Repeatable Read） 事务T1读取一个数据块，另外，事务T2在事务T1未commit的情况下，试图写同样的数据块，此时，T2的写操作会被阻塞，直到T1commit后，写操作才被commit进入数据库； 已提交读（Read committed） 事务T1读取一个数据块，另外，事务T2在事务T1未commit的情况下，成功对同样的数据块进行写操作并commit，事务T1再读这个数据块时，结果和前一次不同；即允许事务T1在两次读操作期间，其他事务对相同的数据块进行写操作； 未提交读（Read uncommitted） 事务T1在事务T2对于一个数据块的写操作未commit的情况下，可以读取T2修改后的结果； 数据库事务隔离级别分别存在的并发问题 隔离级别 是否存在脏读 是否存在不可重复读 是否存在幻读 Read uncommitted 存在 存在 存在 Read committed 不存在 存在 存在 Repeatable Read 不存在 不存在 存在 Serializable 不存在 不存在 不存在 以上所有的隔离级别都不允许脏写（一个数据项已经被另外一个尚未提交或中止的事务写入，则不允许对该数据项执行写操作）； 数据库隔离界别越高，并发性能越低； 事务并发的处理方法 共享锁（S锁）： 获准共享锁的事务职能读取数据，不能修改数据； 如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁； 排他锁（X锁）： 获准排他锁的事务既能读取数据，也能修改数据； 如果事务T对数据A加上排他锁后，则其他事务不能在对A加任何类型的封锁； 死锁及其解决方法 死锁实例1： 现有事务A和B； A在b上拥有排它锁，B正在申请b上的共享锁，故B需要等待A释放b上的排它锁； B在a上拥有共享锁，A正在申请a上的排它锁，故A需要等待B释放a上的共享锁； A和B相互等待，形成死锁； 死锁实例2： 将数据库设置为可重复读的隔离级别； 事务A等待事务B执行完毕，以便commit对对象a的更改（B已经读取了a）； 事务B等待事务A执行完毕，以便commit对对象b的更改（A已经读取了b）； 死锁的解决： 必须有一个事务主动回滚； 回滚的事务自动释放了锁； 另一个未回滚的事务就可以继续向下执行；]]></content>
      <categories>
        <category>datebase</category>
      </categories>
      <tags>
        <tag>datebase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angularjs 指令详解]]></title>
    <url>%2F2016%2F04%2F09%2F2016-4-9-angularjs-directive%2F</url>
    <content type="text"><![CDATA[引言 angularjs有许多内置指令，这些指令主要用于操纵DOM、指定路由、绑定事件处理器、执行数据绑定等等； angularjs不仅有丰富的内置指令，而且可以自定义指令，实现自己需要的功能； angularjs指令系统是angularjs最重要的一个知识点，在本文中加以总结，如有不完善之处请您指出； 非常感谢慕课网的大漠穷秋老师，本文的很多代码复制自大漠穷秋老师在慕课网angularjs课程的示例代码； 内置指令 angularjs以ng开头的指令均为内置指令，详见官方文档、内置指令总结； 所有内置指令如下： 编写指令 最简单的指令模板如下： 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="testApp"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="lib/bootstrap-3.3.1/css/bootstrap.min.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;div ng-controller="testCtrl"&gt; &lt;hello&gt;&lt;/hello&gt; &lt;div hello&gt;&lt;/div&gt; &lt;div class="hello"&gt;&lt;/div&gt; &lt;!-- directive:hello --&gt;&lt;/div&gt;&lt;script src="lib/bootstrap-3.3.1/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;script src="lib/angular-1.3.3/angular.min.js"&gt;&lt;/script&gt;&lt;script src="test.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910//test.jsvar mod = angular.module('testApp', []);mod.directive('hello',function()&#123; return&#123; restrict:'AEMC', template:'&lt;div&gt;this is a directive test!&lt;/div&gt;', replace:true &#125;&#125;); 自定义指令参数 对自定义指令声明参数的说明： restrict：替换自定义元素类型，E（元素）、C（类）、A（属性）、M（注释）； template：替换的模板，如template: &lt;div&gt;this is a directive test.&lt;/div&gt;; templateURL: 替换的模板的URL，如templateUrl: &#39;hello.html&#39;; replace:true,将自定义标签的内容全部替换掉； transclude:true,自定义标签的内容不会被替换，而是被放置在template中的&lt;div ng-transclude&gt;&lt;/div&gt;中； compile: function(){...},自定义compile函数，一般放置暴露给外部看的（比如其他directive）一些公共函数； link: function(){...}，自定义link函数，一般放置本directive中操纵DOM、添加事件监听器等的代码； 作用域问题：在上述代码中，四个被指令替换的DOM标签其实所在的是同一个作用域，这样做不太安全，如果需要将作用域分开，则在指令中添加scope:{}即可，下面会详细讲解； 独立scope 实现独立scope的方法是在指令中添加scope:{}即可； 代码如下，改动任意一个input标签的内容，其他的directive不受影响，即directive作用域独立： 123456789101112131415&lt;!doctype html&gt;&lt;html ng-app="MyModule"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;link rel="stylesheet" href="css/bootstrap-3.0.0/css/bootstrap.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;hello&gt;&lt;/hello&gt; &lt;hello&gt;&lt;/hello&gt; &lt;hello&gt;&lt;/hello&gt; &lt;hello&gt;&lt;/hello&gt; &lt;/body&gt; &lt;script src="framework/angular-1.3.0.14/angular.js"&gt;&lt;/script&gt; &lt;script src="IsolateScope.js"&gt;&lt;/script&gt;&lt;/html&gt; 12345678910//IsolateScope.jsvar myModule = angular.module("MyModule", []);myModule.directive("hello", function() &#123; return &#123; restrict: 'AE', scope:&#123;&#125;, template: '&lt;div&gt;&lt;input type="text" ng-model="userName"/&gt;&#123;&#123;userName&#125;&#125;&lt;/div&gt;', replace: true &#125;&#125;); 指令和controller的交互 在link函数中完成简单的directive和controller的交互,下面程序实现了在link中添加事件监听器并调用controller的特定方法： 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel="stylesheet" href="css/bootstrap.min.css"&gt; &lt;link rel="stylesheet" href="css/ng-table.css"&gt; &lt;style&gt; &lt;/style&gt;&lt;/head&gt;&lt;body ng-app="myApp"&gt; &lt;div ng-controller="myCtrl"&gt; &lt;hello&gt;滑动加载&lt;/hello&gt; &lt;/div&gt; &lt;script src="js/jquery-2.1.4.js"&gt;&lt;/script&gt; &lt;script src="js/angular.min.js"&gt;&lt;/script&gt; &lt;script src="js/ng-table.js"&gt;&lt;/script&gt; &lt;script src="app.js"&gt;&lt;/script&gt; &lt;script&gt; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819//app.jsvar mod = angular.module('myApp', []);mod.controller("myCtrl",function($scope)&#123; $scope.loadData = function()&#123; console.log("正在加载数据"); &#125;&#125;);mod.directive('hello',function()&#123; return&#123; restrict:'AEMC', link: function(scope, element, attr)&#123; element.bind("mouseenter",function()&#123; scope.loadData(); &#125;); &#125; &#125;&#125;); 一个指令也可同时调用多个controller的函数： 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel="stylesheet" href="css/bootstrap.min.css"&gt; &lt;link rel="stylesheet" href="css/ng-table.css"&gt; &lt;style&gt; &lt;/style&gt;&lt;/head&gt;&lt;body ng-app="myApp"&gt; &lt;div ng-controller="myCtrl"&gt; &lt;hello howtoload="loadData()"&gt;滑动加载&lt;/hello&gt; &lt;/div&gt; &lt;div ng-controller="myCtrl2"&gt; &lt;hello howtoload="loadData2()"&gt;滑动加载2&lt;/hello&gt; &lt;/div&gt; &lt;script src="js/jquery-2.1.4.js"&gt;&lt;/script&gt; &lt;script src="js/angular.min.js"&gt;&lt;/script&gt; &lt;script src="js/ng-table.js"&gt;&lt;/script&gt; &lt;script src="app.js"&gt;&lt;/script&gt; &lt;script&gt; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526//app.jsvar mod = angular.module('myApp', []);mod.controller("myCtrl",function($scope)&#123; $scope.loadData = function()&#123; console.log("正在加载数据"); &#125;&#125;);mod.controller("myCtrl2",function($scope)&#123; $scope.loadData2 = function()&#123; console.log("正在加载数据...2222"); &#125;&#125;);mod.directive('hello',function()&#123; return&#123; restrict:'AEMC', link: function(scope, element, attrs)&#123; element.bind("mouseenter",function(event)&#123; scope.$apply(attrs.howtoload); //一律小写，不用驼峰法则，没有括号() &#125;); &#125; &#125;&#125;); 指令间通信 指令间通信的方法是：scope: {}定义独立作用域，controller暴露方法给别的指令，require引用其他指令； 1234567891011121314151617181920212223242526272829&lt;!doctype html&gt;&lt;html ng-app="MyModule"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;link rel="stylesheet" href="css/bootstrap-3.0.0/css/bootstrap.css"&gt; &lt;script src="framework/angular-1.3.0.14/angular.js"&gt;&lt;/script&gt; &lt;script src="Directive&amp;Directive.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="row"&gt; &lt;div class="col-md-3"&gt; &lt;superman strength&gt;动感超人---力量&lt;/superman&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="row"&gt; &lt;div class="col-md-3"&gt; &lt;superman strength speed&gt;动感超人2---力量+敏捷&lt;/superman&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="row"&gt; &lt;div class="col-md-3"&gt; &lt;superman strength speed light&gt;动感超人3---力量+敏捷+发光&lt;/superman&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//Directive&amp;Directive.jsvar myModule = angular.module("MyModule", []);myModule.directive("superman", function() &#123; return &#123; scope: &#123;&#125;, restrict: 'AE', controller: function($scope) &#123; $scope.abilities = []; this.addStrength = function() &#123; $scope.abilities.push("strength"); &#125;; this.addSpeed = function() &#123; $scope.abilities.push("speed"); &#125;; this.addLight = function() &#123; $scope.abilities.push("light"); &#125;; &#125;, link: function(scope, element, attrs) &#123; element.addClass('btn btn-primary'); element.bind("mouseenter", function() &#123; console.log(scope.abilities); &#125;); &#125; &#125;&#125;);myModule.directive("strength", function() &#123; return &#123; require: '^superman', link: function(scope, element, attrs, supermanCtrl) &#123; supermanCtrl.addStrength(); &#125; &#125;&#125;);myModule.directive("speed", function() &#123; return &#123; require: '^superman', link: function(scope, element, attrs, supermanCtrl) &#123; supermanCtrl.addSpeed(); &#125; &#125;&#125;);myModule.directive("light", function() &#123; return &#123; require: '^superman', link: function(scope, element, attrs, supermanCtrl) &#123; supermanCtrl.addLight(); &#125; &#125;&#125;); scope绑定 @绑定：将当前属性作为字符串传递，实现绑定； 下面代码中，flavor:&#39;@&#39;实现的功能可以由注释掉的link函数代替； 1234567891011121314&lt;!doctype html&gt;&lt;html ng-app="MyModule"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;link rel="stylesheet" href="css/bootstrap-3.0.0/css/bootstrap.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-controller="MyCtrl"&gt; &lt;drink flavor="&#123;&#123;ctrlFlavor&#125;&#125;"&gt;&lt;/drink&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src="framework/angular-1.3.0.14/angular.js"&gt;&lt;/script&gt; &lt;script src="ScopeAt.js"&gt;&lt;/script&gt;&lt;/html&gt; 1234567891011121314151617var myModule = angular.module("MyModule", []);myModule.controller('MyCtrl', ['$scope', function($scope)&#123; $scope.ctrlFlavor="百威";&#125;])myModule.directive("drink", function() &#123; return &#123; restrict:'AE', scope:&#123; flavor:'@' &#125;, template:"&lt;div&gt;&#123;&#123;flavor&#125;&#125;&lt;/div&gt;" // , // link:function(scope,element,attrs)&#123; // scope.flavor=attrs.flavor; // &#125; &#125;&#125;); =实现与父scope的属性双向绑定 1234567891011121314151617181920&lt;!doctype html&gt;&lt;html ng-app="MyModule"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;link rel="stylesheet" href="css/bootstrap-3.0.0/css/bootstrap.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-controller="MyCtrl"&gt; Ctrl: &lt;br&gt; &lt;input type="text" ng-model="ctrlFlavor"&gt; &lt;br&gt; Directive: &lt;br&gt; &lt;drink flavor="ctrlFlavor"&gt;&lt;/drink&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src="framework/angular-1.3.0.14/angular.js"&gt;&lt;/script&gt; &lt;script src="ScopeEqual.js"&gt;&lt;/script&gt;&lt;/html&gt; 12345678910111213var myModule = angular.module("MyModule", []);myModule.controller('MyCtrl', ['$scope', function($scope)&#123; $scope.ctrlFlavor="百威";&#125;])myModule.directive("drink", function() &#123; return &#123; restrict:'AE', scope:&#123; flavor:'=' &#125;, template:'&lt;input type="text" ng-model="flavor"/&gt;' &#125;&#125;); &amp;：传递一个父scope的函数，稍后调用 12345678910111213141516&lt;!doctype html&gt;&lt;html ng-app="MyModule"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;link rel="stylesheet" href="css/bootstrap-3.0.0/css/bootstrap.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-controller="MyCtrl"&gt; &lt;greeting greet="sayHello(name)"&gt;&lt;/greeting&gt; &lt;greeting greet="sayHello(name)"&gt;&lt;/greeting&gt; &lt;greeting greet="sayHello(name)"&gt;&lt;/greeting&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src="framework/angular-1.3.0.14/angular.js"&gt;&lt;/script&gt; &lt;script src="ScopeAnd.js"&gt;&lt;/script&gt;&lt;/html&gt; 12345678910111213141516var myModule = angular.module("MyModule", []);myModule.controller('MyCtrl', ['$scope', function($scope)&#123; $scope.sayHello=function(name)&#123; alert("Hello "+name); &#125;&#125;])myModule.directive("greeting", function() &#123; return &#123; restrict:'AE', scope:&#123; greet:'&amp;' &#125;, template:'&lt;input type="text" ng-model="userName" /&gt;&lt;br/&gt;'+ '&lt;button class="btn btn-default" ng-click="greet(&#123;name:userName&#125;)"&gt;Greeting&lt;/button&gt;&lt;br/&gt;' &#125;&#125;); angularjs 初始化过程 理解angularjs的初始化过程有助于我们进一步理解link和compile函数； 初始化过程如下： ng-app寻找angular作用边界，在ng-app作用域范围内创建$rootScope，以后各层级的$scope均在$rootScope基础上创建，实现树形作用域结构； 解析module中的各种组件名称对应的回调函数的注册表，回调函数不被执行，注册表中的组件均可被用于依赖注入； controller立即执行； Compile：根据从服务器获取的或者dierective中的HTML模板编译HTML，对指定的模板进行转换，生成Linking函数，此时DOM是静态DOM； Link：将Compile结果与Scope结合，产生动态视图，包括在元素上注册时间监听，即动态DOM； 对于同一个指定的多个实例(如ng-repeat)，compile只会执行一次，而link对于指令的每个实例都会执行一次；]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Angularjs</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统重点概念汇总]]></title>
    <url>%2F2016%2F04%2F07%2F2016-4-7-Operating-System%2F</url>
    <content type="text"><![CDATA[引言 最近利用下班的空闲时间看了看《现代操作系统》，感觉讲得非常好，虽然某些细节仍不理解，但是受益匪浅，让我对计算机有了全新的认识； 这篇博客总结了操作系统的基本概念，如果以后有用到其中的知识，我准备再深入研究细节； 为什么要有操作系统 空间上，为上层应用程序提供一个清晰的、一致的、友好的硬件抽象，由于硬件种类繁多，软件编写者不可能就各种不同的硬件接口编写不同版本的程序，所以屏蔽硬件的不一致性的任务就交给操作系统； 时间上，保证各个程序有序运行，并充分利用硬件资源，比如时分复用、线程调度等都是具体实现； 有关CPU的概念 CPU的两种模式为内核态和用户态，为了安全，在内核态时CPU可使用全部硬件，用户态时不行； 每种CPU都有自己的指令集，用于执行取指、解码、执行的各个过程； CPU有自己的寄存器，用于存储计算暂时结果，它比内存快很多； 时间多路复用/时分复用/多线程技术/超线程技术：CPU切换执行不同的线程，线程执行进度保存在程序计数器中（本质是一个寄存器），当切换到其他线程前，需要保存所有寄存器的状态，以便下次执行这个线程时重新装入这些寄存器的值； 流水线：CPU的取指、解码和执行单元相互分离，执行指令n时，可以对n+1条指令解码，并读取指令n+2； 超标量技术：CPU的取指、解码和执行这些指令级的运算的并行运算技术，实现超标量的物理基础是CPU的算术逻辑单元、位移单元、乘法器相互分离，可以并行执行多条指令； 多核技术： 一个CPU上装有多个小芯片，每个芯片能够独立完成取指、解码和执行等过程； 进程 进程是正在执行的一个程序； 每个进程有其单独的地址空间，存有：可执行程序、程序的数据、程序的堆栈，如果进程申请的地址空间大于内存，则使用虚拟内存技术来解决； 每个进程有其单独的资源集，包含：程序计数器、堆栈指针、寄存器等； 运行过程：当一个CPU核心切换到某个进程时，为这个进程分配内存资源和CPU核执行时间资源（时间片），当时间片用完后，当前运行的指针被保存下来，进程被暂时挂起，CPU核切换到另一个进程执行； 守护进程：一种在后台执行的进程（电子邮件、web页面、新闻）； 句柄：父进程和子进程之间的通信； 进程状态：就绪、运行、阻塞，在这三种状态间切换叫做进程调度； 进程调度的例子： 某一进程不能继续运行（如进程的输入尚未准备好）–阻塞； 某一进程运行时间太长，CPU需要切换到其他进程–就绪； 某一进程开始执行–运行； 线程 线程是比进程更小的一个概念，一个进程可以包含多个线程； 所线程共享其所在进程的地址空间、内存资源、全局变量、打开文件，但不能同时读取同一块内存（线程锁控制）； 线程自己拥有的只是一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)； 进程和线程的区别： 进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。 具体请参考这篇文章； 进程间通信 为什么进程间要有通信机制？ 考察命令 cat abc.txt | grep &quot;sss&quot;，上述命令中，cat启动一个进程，这个进程的结果要传给grep启动的这个进程，这就需要进程间通信； 两个打印进程如果没有通信（CPU轮训执行这两个进程），同时向打印机的打印队列中放入待打印的文件名，并将打印队列的指针移动一位，就可能出现错误，比如A进程覆盖B进程的待打印文件； 进程间的竞争问题的解决 总的思想：阻止多个进程同时读写共享的数据； 临界区：进程的共享内存或共享文件成为临界区，不得使多个进程同时进入其临界区； 临界区的具体实现方法： 当一个进程进入临界区后，CPU屏蔽中断，此时，CPU无法切换到其他进程，直到当前进程退出临界区； 当一个进程进入临界区后，将锁变量设置为1，表示临界区内有进程，其他进程直到锁变量变为0后才能进入临界区； 上述方法的缺点： 如果当前临界区内有进程，则另一个想要进入临界区的进程就不得不等待，直到临界区内无进程，这非常耗时； 如果有一个高优先级H进程、低优先级L进程，L在临界区中，H在临界区外，H等待L退出临界区，但是由于L优先级比H低，L不会被调度、不会出临界区，则H一直在等待； 信号量和互斥量： 信号量和互斥量是两个非常重要的进程间通信的机制，两者不同，互斥量的本质是二元信号量； 信号量的例子：维护一个打印队列，最长队列为N，最短为0；生产者可以将打印文件名放入队列，消费者可从打印队列中取出文件名；生产者进程维护一个信号量记录队列中占用的槽总数，初始信号量为0，每放入一个信号量加一，信号量为N时生产者进程阻塞；消费者进程维护一个信号量记录队列中空的打印槽，初始信号量为N，每取出一个信号量减一，信号量为0时生产者进程阻塞；另外，为了保证生产者进程、消费者进程不同时修改打印队列（临界区），另外维护一个二元的信号量mutex（即互斥量），它的值只能为0或1，每当有进程进入临界区，其值为1，其他进程不能进入，进入临界区的进程退出后，mutex值变为0，其他进程可以进入临界区； 两者的区别：互斥量用于线程的互斥（二元，要么锁住，要么解锁），信号量用于线程的同步（多元）；从作用域来说，信号量是进程间或线程间(linux仅线程间)，互斥锁是线程间； 进程调度 为什要有进程调度？当CPU要选择执行哪个进程的时候，如果两个或多个进程处于就绪状态，这时就存在选择的问题，需要进程调度解决； 何时启动进程调度机制？ 在创建一个新进程后，决定运行父进程还是子进程； 在一个进程退出时，系统必须选择另外一个处于就绪状态的进程执行，否则会浪费CPU资源； 当一个进程阻塞时，必须选择另一个进程运行； 在一个I/O中断发生时，必须做出调度决策； 进程调度的目标： 公平：地位等价的进程占用CPU资源的程度应当差不多相等； 效率：让CPU以及I/O资源尽可能忙碌，所有部分不要闲着，这就需要对“CPU密集型进程”“I/O密集型进程”进行合理调度； 进程调度的两种策略： 非抢占式：CPU挑选一个进程，让它运行直至被阻塞（阻塞在IO或者等待另一个进程）或自行释放CPU； 抢占式：让一个进程运行一段时间，强行挂起该进程，让另一个进程运行； 具体的进程调度策略： 轮转调度：所有进程排成一个圆圈，转圈圈调度； 优先级调度：动态赋予进程优先级，优先级高的先执行； 多级队列调度：一个进程需要100个时间片才能完成，CPU每次执行它时只执行一个时间片的时间，如果采用轮转调度，要频繁的从磁盘取出和写入进程，但是如果该进程在第一次获得CPU时分配1个时间片、在第二次获得CPU时分配2个时间片、在第三次获得CPU时分配4个时间片、在第四次获得CPU时分配8个时间片等等，这样就能减少磁盘读写，提升CPU密集型的进程的执行效率，这就是多级队列调度； 死锁： 定义：如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么该进程集合就是死锁的； 死锁的条件和避免死锁的方法有严格的逻辑推导，这里不再赘述； 哲学家就餐问题 存储管理 直接使用物理地址的危害： 用户程序可以寻址内存的每个字节，很容易破坏操作系统，除非有特殊的硬件保护； 如果每个用户程序都直接使用内存的所有物理地址，并行的执行多个用户程序变得困难； 解决方法：给每个用户进程分配单独的地址空间； 地址空间： 地址空间是对内存这个硬件的抽象； 具体实现：用基址寄存器和界限寄存器确定进程的地址空间，这两个寄存器是CPU的重要硬件； 交换技术（解决物理内存不够大的问题）：在物理内存不够大时，可以将目前未在执行的进程存回磁盘，运行时再调入内存； 虚拟内存（解决物理内存不够大的问题）：地址空间映射的物理内存在内存条上是不连续的、甚至有些在磁盘中，但是暴露给进程看的虚拟内存地址是连续的； 虚拟内存/分页： 每个进程拥有自己的地址空间； 这个地址空间被分为许多内部地址连续的块，即“页”，和页相关的信息存储在页表中； 每一页都能够映射到物理内存中，“页”在物理地址中称作“页框”，映射关系由内存管理单元（MMU）统一管理，如果要使用一个地址的数据，虚拟地址首先被送到MMU转换为物理地址； 必要时可以有多级的映射关系； 缺页中断：当MMU发现虚拟内存地址映射的物理地址不在内存中时，向CPU发送缺页中断； 页面置换：当发生缺页中断时，必须选择一个页面换出内存，这样才能将磁盘中需要的数据换入内存； 页面置换算法的效率问题：如果一个页面即将被使用但是被换出了内存，这样就很低效，为了提升效率，有如下的页面置换算法：最近未使用页面置换算法、先进先出算法、二次机会页面置换算法、时钟页面置换算法、最近最少使用页面置换算法； 空闲内存管理： 位图：内存被分为若干多个内存单元（几个字-几千字节都可以）进行管理；每个内存单元要么空闲、要么占用，以“0”“1”映射到位图中；搜索位图中的连续空闲地址比较耗时； 链表：维护一个链表，每个节点记录一块空闲的内存区域的起始地址、长度、指向下一个链表的指针；当两个空闲区域相邻时，将链表中的相邻两个结点合并即可；]]></content>
      <categories>
        <category>computer</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angularjs 源码阅读体会]]></title>
    <url>%2F2016%2F03%2F30%2F2016-3-30-Angularjs-source-code%2F</url>
    <content type="text"><![CDATA[说明 本文是我在阅读Angularjs源码时的一些体会，写出来分享给大家，不足之处请多多指正。 本文以angularjs 1.5.x版本源码为例； 本文参考：文章一、系列分析文章 Angularjs在初始化的时候做了什么尝试绑定jQuery对象，如果没有则采用内置的jqLite(30561行)：123//try to bind to jquery now so that one can write jqLite(document).ready()//but we will rebind on bootstrap again.bindJQuery(); publishExternalAPI初始化angular环境,这也是angularjs实现其重要特性–扩展指令、依赖注入的重要步骤： 把一些基础api挂载到angular上(2455行)： 1234567891011121314151617181920212223242526272829303132extend(angular, &#123; 'bootstrap': bootstrap, 'copy': copy, 'extend': extend, 'merge': merge, 'equals': equals, 'element': jqLite, 'forEach': forEach, 'injector': createInjector, 'noop': noop, 'bind': bind, 'toJson': toJson, 'fromJson': fromJson, 'identity': identity, 'isUndefined': isUndefined, 'isDefined': isDefined, 'isString': isString, 'isFunction': isFunction, 'isObject': isObject, 'isNumber': isNumber, 'isElement': isElement, 'isArray': isArray, 'version': version, 'isDate': isDate, 'lowercase': lowercase, 'uppercase': uppercase, 'callbacks': &#123;counter: 0&#125;, 'getTestability': getTestability, '$$minErr': minErr, '$$csp': csp, 'reloadWithDebugInfo': reloadWithDebugInfo &#125;); 在angular上添加了module方法（2488行）： 在window下面创建全局的angular对象,并且返回一个高阶函数，赋值给了angular.module属性； setupModuleLoader返回的内容中包含了provider、factory、service、value、constant、controller、directive等诸多对象，方便用angular.module链式调用这些对象； 1angularModule = setupModuleLoader(window); 1234567//链式调用angular.module('demoApp', []).factory().controller().directive().config().run(); 当dom ready时，开始执行程序的初始化 执行初始化的代码（30708行）： 123jqLite(document).ready(function() &#123; angularInit(document, bootstrap);&#125;); angularInit函数(1591行): 获取ng-app的应用根节点（含有xx-app属性的dom）； 获取启动模块（xx-app的值xx为 [‘ng-‘, ‘data-ng-‘, ‘ng:’, ‘x-ng-‘] 任一一种; 将上述结果传给bootstrap函数：bootstrap(appElement, module ? [module] : [], config); 123456789101112131415161718// The element `element` has priority over any other elementforEach(ngAttrPrefixes, function(prefix) &#123; var name = prefix + 'app'; if (!appElement &amp;&amp; element.hasAttribute &amp;&amp; element.hasAttribute(name)) &#123; appElement = element; module = element.getAttribute(name); &#125;&#125;);forEach(ngAttrPrefixes, function(prefix) &#123; var name = prefix + 'app'; var candidate; if (!appElement &amp;&amp; (candidate = element.querySelector('[' + name.replace(':', '\\:') + ']'))) &#123; appElement = candidate; module = candidate.getAttribute(name); &#125;&#125;); boostrap函数（1679行）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960function bootstrap(element, modules, config) &#123; // ...省略若干代码 var doBootstrap = function() &#123; element = jqLite(element); // 首先判断该dom是否已经被注入（即这个dom已经被bootstrap过） // 注意这里的injector方法是Angular为jqLite中提供的，区别于一般的jQuery api if (element.injector()) &#123; var tag = (element[0] === document) ? 'document' : startingTag(element); //Encode angle brackets to prevent input from being sanitized to empty string #8683 throw ngMinErr( 'btstrpd', "App Already Bootstrapped with this Element '&#123;0&#125;'", tag.replace(/&lt;/,'&lt;').replace(/&gt;/,'&gt;')); &#125; modules = modules || []; // 添加匿名模块 modules.unshift(['$provide', function($provide) &#123; $provide.value('$rootElement', element); &#125;]); if (config.debugInfoEnabled) &#123; // Pushing so that this overrides `debugInfoEnabled` setting defined in user's `modules`. modules.push(['$compileProvider', function($compileProvider) &#123; $compileProvider.debugInfoEnabled(true); &#125;]); &#125; // 添加ng模块 modules.unshift('ng'); // 到这里modules可能是: ['ng', [$provide, function($provide)&#123;...&#125;], 'xx'] // xx: ng-app="xx" // 创建injector对象，注册所有的内置模块 var injector = createInjector(modules, config.strictDi); // 利用injector的依赖注入，执行回调 injector.invoke(['$rootScope', '$rootElement', '$compile', '$injector', function bootstrapApply(scope, element, compile, injector) &#123; scope.$apply(function() &#123; // 标记该dom已经被注入 element.data('$injector', injector); // 编译整个dom compile(element)(scope); &#125;); &#125;] ); return injector; &#125;; // ...省略若干代码 if (window &amp;&amp; !NG_DEFER_BOOTSTRAP.test(window.name)) &#123; return doBootstrap(); &#125; // ...省略若干代码&#125; 除了系统会自动调用bootsrap函数，也可以自己手动调用： 12345angular.module('demo', []) .controller('WelcomeController', function($scope) &#123; $scope.greeting = 'Welcome!'; &#125;);angular.bootstrap(document, ['demo']); $get的分析 $get见源码16163行； 构造函数如下： 123456789101112function Scope() &#123; this.$id = nextUid(); this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null; this.$root = this; this.$$destroyed = false; this.$$listeners = &#123;&#125;; this.$$listenerCount = &#123;&#125;; this.$$watchersCount = 0; this.$$isolateBindings = null; &#125; 含义： $id, 通过nextUid方法来生成一个唯一的标识 $$phase, 这是一个状态标识,一般在dirty check时用到，表明现在在哪个阶段 $parent, 代表自己的上级scope属性 $$watchers, 保存scope变量当前所有的监控数据,是一个数组 $$nextSibling, 下一个兄弟scope属性 $$prevSibling, 前一个兄弟scope属性 $$childHead, 第一个子级scope属性 $$childTail, 最后一个子级scope属性 $$destroyed, 表示是否被销毁 $$asyncQueue, 代表异步操作的数组 $$postDigestQueue, 代表一个在dirty check之后执行的数组 $$listeners, 代表scope变量当前所有的监听数据,是一个数组 创建子级作用域是通过$new方法： 12345678910111213141516171819202122232425262728293031323334$new: function(isolate, parent) &#123; var child; parent = parent || this; if (isolate) &#123; child = new Scope(); child.$root = this.$root; &#125; else &#123; // Only create a child scope class if somebody asks for one, // but cache it to allow the VM to optimize lookups. if (!this.$$ChildScope) &#123; this.$$ChildScope = createChildScopeClass(this); &#125; child = new this.$$ChildScope(); &#125; child.$parent = parent; child.$$prevSibling = parent.$$childTail; if (parent.$$childHead) &#123; parent.$$childTail.$$nextSibling = child; parent.$$childTail = child; &#125; else &#123; parent.$$childHead = parent.$$childTail = child; &#125; // When the new scope is not isolated or we inherit from `this`, and // the parent scope is destroyed, the property `$$destroyed` is inherited // prototypically. In all other cases, this property needs to be set // when the parent scope is destroyed. // The listener needs to be added after the parent is set if (isolate || parent != this) child.$on('$destroy', destroyChildScope); return child; &#125; 分析： isolate标识来创建独立作用域,这个在创建指令，并且scope属性定义的情况下，会触发这种情况，还有几种别的特殊情况,假如是独立作用域的话，会多一个$root属性,这个默认是指向rootscope的； 如果不是独立的作用域,则会生成一个内部的构造函数,把此构造函数的prototype指向当前scope实例； 通用的操作就是,设置当前作用域的$$childTail,$$childTail.$$nextSibling,$$childHead,this.$$childTail为生成的子级作用域;设置子级域的$parent为当前作用域,$$prevSibling为当前作用域最后一个子级作用域； $watch的分析 $watch在16452行，具体如下： 12345678910111213141516171819202122232425262728293031323334353637$watch: function(watchExp, listener, objectEquality, prettyPrintExpression) &#123; var get = $parse(watchExp); if (get.$$watchDelegate) &#123; return get.$$watchDelegate(this, listener, objectEquality, get, watchExp); &#125; var scope = this, array = scope.$$watchers, watcher = &#123; fn: listener, last: initWatchVal, get: get, exp: prettyPrintExpression || watchExp, eq: !!objectEquality &#125;; lastDirtyWatch = null; if (!isFunction(listener)) &#123; watcher.fn = noop; &#125; if (!array) &#123; array = scope.$$watchers = []; &#125; // we use unshift since we use a while loop in $digest for speed. // the while loop reads in reverse order. array.unshift(watcher); incrementWatchersCount(this, 1); return function deregisterWatch() &#123; if (arrayRemove(array, watcher) &gt;= 0) &#123; incrementWatchersCount(scope, -1); &#125; lastDirtyWatch = null; &#125;; &#125; 对象含义： fn, 代表监听函数,当监控表达式新旧不相等时会执行此函数 last, 保存最后一次发生变化的监控表达式的值 get, 保存一个监控表达式对应的函数,目的是用来获取表达式的值然后用来进行新旧对比的 exp, 保存一个原始的监控表达式 eq, 保存$watch函数的第三个参数，表示是否进行深度比较 检查传递进来的监听参数是否为函数,如果是一个有效的字符串，则通过parse来解析生成一个函数,否则赋值为一个noop占位函数,最后生成一个包装函数，函数体的内容就是执行刚才生成的监听函数,默认传递当前作用域. 检查监控表达式是否为字符串并且执行表达式的constant为true,代表这个字符串是一个常量,那么，系统在处理这种监听的时候，执行完一次监听函数之后就会删除这个$watch.最后往当前作用域里的$$watchers数组头中添加$watch信息,注意这里的返回值,利用JS的闭包保留了当前的watcher，然后返回一个函数，这个就是用来删除监听用的. $digest分析 见源码16812行； digest方法是dirty check的核心,主要思路是先执行$$asyncQueue队列中的表达式,然后开启一个loop来的执行所有的watch里的监听函数,前提是前后两次的值是否不相等,假如ttl超过系统默认值，则dirth check结束,最后执行$$postDigestQueue队列里的表达式. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113$digest: function() &#123; var watch, value, last, fn, get, watchers, length, dirty, ttl = TTL, next, current, target = this, watchLog = [], logIdx, asyncTask; beginPhase('$digest'); // Check for changes to browser url that happened in sync before the call to $digest $browser.$$checkUrlChange(); if (this === $rootScope &amp;&amp; applyAsyncId !== null) &#123; // If this is the root scope, and $applyAsync has scheduled a deferred $apply(), then // cancel the scheduled $apply and flush the queue of expressions to be evaluated. $browser.defer.cancel(applyAsyncId); flushApplyAsync(); &#125; lastDirtyWatch = null; do &#123; // "while dirty" loop dirty = false; current = target; while (asyncQueue.length) &#123; try &#123; asyncTask = asyncQueue.shift(); asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals); &#125; catch (e) &#123; $exceptionHandler(e); &#125; lastDirtyWatch = null; &#125; traverseScopesLoop: do &#123; // "traverse the scopes" loop if ((watchers = current.$$watchers)) &#123; // process our watches length = watchers.length; while (length--) &#123; try &#123; watch = watchers[length]; // Most common watches are on primitives, in which case we can short // circuit it with === operator, only when === fails do we use .equals if (watch) &#123; get = watch.get; if ((value = get(current)) !== (last = watch.last) &amp;&amp; !(watch.eq ? equals(value, last) : (typeof value === 'number' &amp;&amp; typeof last === 'number' &amp;&amp; isNaN(value) &amp;&amp; isNaN(last)))) &#123; dirty = true; lastDirtyWatch = watch; watch.last = watch.eq ? copy(value, null) : value; fn = watch.fn; fn(value, ((last === initWatchVal) ? value : last), current); if (ttl &lt; 5) &#123; logIdx = 4 - ttl; if (!watchLog[logIdx]) watchLog[logIdx] = []; watchLog[logIdx].push(&#123; msg: isFunction(watch.exp) ? 'fn: ' + (watch.exp.name || watch.exp.toString()) : watch.exp, newVal: value, oldVal: last &#125;); &#125; &#125; else if (watch === lastDirtyWatch) &#123; // If the most recently dirty watcher is now clean, short circuit since the remaining watchers // have already been tested. dirty = false; break traverseScopesLoop; &#125; &#125; &#125; catch (e) &#123; $exceptionHandler(e); &#125; &#125; &#125; // Insanity Warning: scope depth-first traversal // yes, this code is a bit crazy, but it works and we have tests to prove it! // this piece should be kept in sync with the traversal in $broadcast if (!(next = ((current.$$watchersCount &amp;&amp; current.$$childHead) || (current !== target &amp;&amp; current.$$nextSibling)))) &#123; while (current !== target &amp;&amp; !(next = current.$$nextSibling)) &#123; current = current.$parent; &#125; &#125; &#125; while ((current = next)); // `break traverseScopesLoop;` takes us to here if ((dirty || asyncQueue.length) &amp;&amp; !(ttl--)) &#123; clearPhase(); throw $rootScopeMinErr('infdig', '&#123;0&#125; $digest() iterations reached. Aborting!\n' + 'Watchers fired in the last 5 iterations: &#123;1&#125;', TTL, watchLog); &#125; &#125; while (dirty || asyncQueue.length); clearPhase(); while (postDigestQueue.length) &#123; try &#123; postDigestQueue.shift()(); &#125; catch (e) &#123; $exceptionHandler(e); &#125; &#125; &#125; 核心就是两个loop，外loop保证所有的model都能检测到,内loop则是真实的检测每个watch,watch.get就是计算监控表达式的值,这个用来跟旧值进行对比,假如不相等，则执行监听函数； 比较完之后,把新值传给watch.last,然后执行watch.fn也就是监听函数,传递三个参数,分别是:最新计算的值,上次计算的值(假如是第一次的话,则传递新值),最后一个参数是当前作用域实例,这里有一个设置外loop的条件值，那就是dirty = true,也就是说只要内loop执行了一次watch,则外loop还要接着执行，这是为了保证所有的model都能监测一次，虽然这个有点浪费性能,不过超过ttl设置的值后,dirty check会强制关闭，并抛出异常； 当检查完一个作用域内的所有watch之后，则开始深度遍历当前作用域的子级或者父级,虽然这有些影响性能，就像这里的注释写的那样yes, this code is a bit crazy $apply分析 见源码17121行； 12345678910111213141516171819$apply: function(expr) &#123; try &#123; beginPhase('$apply'); try &#123; return this.$eval(expr); &#125; finally &#123; clearPhase(); &#125; &#125; catch (e) &#123; $exceptionHandler(e); &#125; finally &#123; try &#123; $rootScope.$digest(); &#125; catch (e) &#123; $exceptionHandler(e); throw e; &#125; &#125; &#125; 这个方法一般用在，不在ng的上下文中执行js代码的情况,比如原生的DOM事件中执行想改变ng中某些model的值,这个时候就要使用$apply方法了; 代码中，首先让当前阶段标识为$apply,这个可以防止使用$apply方法时检查是否已经在这个阶段了,然后就是执行$eval方法, 这个方法上面有讲到,最后执行$digest方法,来使ng中的M或者VM改变.]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Angularjs</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery3新特性]]></title>
    <url>%2F2016%2F03%2F10%2F2016-3-10-jQuery3%2F</url>
    <content type="text"><![CDATA[说明 本文为翻译文章，原文在这里 本文作者：Aurelio De Rosa 本文总结了jQuery3新特性，作为jQuery开发者的参考 引言 jQuery影响网页开发已经有十年的时间，它一路走来源于它的诸多优势。 jQuery为用户提供了一个易于使用的与DOM交互方式，比如：执行Ajax请求，创建动画，等等。此外，不同于纯DOM的API，jQuery实现了复合模式。正因为如此，你在不用知道元素数量的前提下，可以方便调用一个jQuery集合或是一个jQuery方法。 在未来的几个星期，一个重要的时间节点将要到来，jQuery将发布版本3，其中修复了很多的bug，增加了新的方法，弃用并删除了一些功能，改变了一些功能的行为。在这篇文章中，我将讲解jQuery3引入的最重要的变化。 新特性 在下面的章节，我将讨论jQuery3中添加的最重要的特性。 FOR…OF LOOP jQuery3将提供for…of 循环来遍历一个jQuery集合的DOM元素。这种新的迭代器是ECMAScript 2015（又名的ECMAScript6）规范的一部分。它可以让你方便的迭代对象（包括阵列，地图，设置，等等）。 当使用这种新的迭代方式的时候，您会收到一个不是jQuery的集合，从中仅可以在同一时间访问一个DOM元素。这个迭代器将使你可以在一个jQuery集合执行操作的方式略有提升。 为了理解这个迭代器是如何工作的，我们举个例子。比如你想分配一个ID给页面的每个输入元素。 jQuery的3之前你可以这样写： 1234var $inputs = $('input');for(var i = 0; i &lt; $inputs.length; i++) &#123; $inputs[i].id = 'input-' + i;&#125; 在jQuery3中可以这样写： 1234var $inputs = $('input');var i = 0; for(var input of $inputs) &#123; input.id = 'input-' + i++;&#125; $.GET() AND $.POST()的新属性 jQuery3增加了$.get()和$.post()的新属性，他们是ajax的具体实现。添加新的属性是： 12$.get([settings])$.post([settings]) setting是一个对象，可以拥有许多属性。你可以给$.ajax()提供相同的对象。要了解更多内容，请参阅$.ajax()。 在给$.get()、$.post()传送对象和给$.ajax()传送对象的最大的区别是方法的属性始终被忽略掉。产生这种情况的原因是$.get()、$.post()对象有一个预设的HTTP方法来执行Ajax请求（GET方法对应$.get()、POST方法对应$.post()）。最基本的一个原则是，你不能尝试通过$.get()去发送POST请求。 1234$.get(&#123; url: 'https://www.audero.it', method: 'POST' // This property is ignored&#125;); 尽管显式设置了请求的方法为POST，这段代码仍将发出GET而非POST请求。 使用REQUESTANIMATIONFRAME()播放动画 所有现代浏览器，包括Internet Explorer10及以上，都支持requestAnimationFrame。在实际操作中，jQuery3播放动画时，使用这个API将使得动画的播放更加平滑，而且消耗更少的CPU资源。 UNWRAP() jQuery3对于unwrap()函数增加了一个可选的选择参数。该方法现在可以这么使用： 1unwrap([selector]) 由于这种变化，你可以在unwrap函数中添加选择器。如果选择器存在匹配的DOM对象，则匹配的子元素是展开；否则，不进行操作。 未来的变化 jQuery3还修改了它的一些功能的行为。 VISIBLE 和 :HIDDEN 新版的jQuery更改了:visible 和:hidden的含义，如果元素存在盒模型（包括那些宽度和高度为零的盒模型），这样的元素将被认为是:visible的。例如，元素和一些没有内容的行内元素在jQuery3中就会被:visible选择器选中。所以，如果您页面上结构如下： 12&lt;div&gt;&lt;/div&gt;&lt;br /&gt; 而且您写了如下的代码： 1console.log($('body :visible').length); 在jQuery1和jQuery2中，您将获取0，在jQuery3中，您将获得2. DATA() 另一个重要变化是关于data()方法的。它已被更改为符合 Dataset API specifications的方法。 jQuery3将所有属性的key值变更为camel case。要理解这种变化，请考虑以下代码： 1&lt;div id="container"&gt;&lt;/div&gt; 如果您使用的是jQuery3之前的版本，你可以这么写： 123456var $elem = $('#container');$elem.data(&#123; 'my-property': 'hello'&#125;);console.log($elem.data()); 在控制台你将得到如下输出： 1&#123;my-property: "hello"&#125; 但是如果您使用jQuery3，将得到： 1&#123;myProperty: "hello"&#125; 注意，jQuery3属性的名称是camel case的，没有“-”符号，而以前的版本则有。 THE DEFERRED OBJECT jQuery3改变了递延对象的行为，是Promise对象的先驱，以提高其与promise/ A+对象的兼容性。这个对象和它的历史是很有趣的。为了更多地了解它，你可以阅读官方文档或阅读我的书,涵盖jQuery3的知识点。 在jQuery1.x和2.x中，回调函数中的未捕获异常被传递给一个异常中止程序的执行。不同于原生的Promise 对象，它会一层一层抛出异常，直到它达到window.onerror对象。如果你还没有为此函数定义事件（这是一种罕见的情况），异常消息会显示出来，程序流被终止。 jQuery3遵循和原生的Promise对象相同的模式。因此，引发的异常被转换成一个rejection 对象并且执行失败情况下的回调函数。一旦完成，该过程继续，并且随后执行成功情况下的回调函数。 为了帮助您了解这种差异，让我们看一个小例子。考虑下面的代码： 123456789101112131415161718192021222324var deferred = $.Deferred();deferred .then(function() &#123; throw new Error('An error'); &#125;) .then( function() &#123; console.log('Success 1'); &#125;, function() &#123; console.log('Failure 1'); &#125; ) .then( function() &#123; console.log('Success 2'); &#125;, function() &#123; console.log('Failure 2'); &#125; );deferred.resolve(); 在jQuery1和jQuery2中，只有第一个函数（抛出异常的那个函数）被执行。另外，因为我们没有定义任何window.onerror的处理函数，控制台消息将输出“Uncaught Error: An error”，程序执行将中止。 在jQuery3中，程序的行为是完全不同的。你会看到控制台消息显示“Failure 1”和“Success 2”。该异常由第一个失败处理函数来处理，一旦它已经被处理，接下来成功的函数可以被执行。 SVG 文件 没有jQuery版本，包括jQuery3，正式支持SVG文件。然而事实是，许多方法都可以工作，比如那些操纵类名称的函数，已在jQuery3中被更新。因此，在这个即将到来的jQuery版本，你就可以使用SVG文档的方法，如addClass()和hasClass()方法。 方法和属性已过时或删除 到目前我们介绍了jQuery3新增的功能，同时它也移除和弃用的几个功能。 弃用 BIND(), UNBIND(), DELEGATE() UNDELEGATE()方法 on()方法以前曾经介绍过，是用来为提供一个统一的接口来代替jQuery的bind()、delegate()和 live()方法。同时，jQuery建议用off()提供的统一的接口来代替unbind(),undelegated()和die()方法。 jQuery3弃用了所有的这些方法，将来的版本也不会重新使用。请在你的项目中专注于使用on() 和off()。 弃用LOAD(), UNLOAD() 和 ERROR()方法 jQuery3弃用了LOAD(), UNLOAD() 和 ERROR()方法。这些方法其实早在jQuery1.8中就被弃用了，但并未被绝对禁止使用。如果你正在使用依赖于一个或一个以上的这些方法，升级到jQuery3则会破坏你的代码的可用性。因此，在决定升级前要注意。 弃用CONTEXT, SUPPORT 和 SELECTOR属性 jQuery3 弃用了context, support和 selector属性。正如我在上一节中提到的，如果你还在项目中使用它们，升级到jQuery3会破坏你的代码的可用性。 Bug的修正 jQuery3修复了以前版本中的一些重要的错误。在下面的部分，我将重点讲解两方面，这将使您的工作方式的巨大变化。 对于 width() 和height()函数不会有更多的四舍五入 jQuery3修复了包括width()和height()等相关函数的bug。这些方法将不再舍入到最近的像素，这使得它在某些情况下难以定位。 要理解这个问题，举例来说，你有一个有100像素宽的容器元素，分成三等份，每一份为宽度为整体的三分之一（即33.333333％）,在jQuery历史版本中，如果你要按照下面的代码获取每一份的宽度,你将会得到四舍五入后的宽度33像素。jQuery3中修复了这个bug，你将会得到一个浮点数。 12345div class="container"&gt; &lt;div&gt;My name&lt;/div&gt; &lt;div&gt;is&lt;/div&gt; &lt;div&gt;Aurelio De Rosa&lt;/div&gt;&lt;/div&gt; 1$('.container div').width(); WRAPALL()函数 jQuery的新版本修复了一个wrapAll()方法的错误。在jQuery3之前的版本中，当向wrapAll()传递函数时，它独立包装jQuery的集合中的元素。换句话说，它的行为和向wrap()传递函数作用相同。 为了解决这个问题，因为函数被在jQuery3中仅仅被调用了1次，它没有通过jQuery的集合传递元素的索引。最后，函数上下文（this对象）将引用jQuery集合中的第一个元素。 下载jQuery3测试版本1 可通过如下URL下载 非压缩版本: https://code.jquery.com/jquery-3.0.0-beta1.js 压缩版本: https://code.jquery.com/jquery-3.0.0-beta1.min.js 也可用npm下载： 1npm install jquery@3.0.0-beta1 结论 很多人说，jQuery已死，现代Web开发不会用到jQuery了。然而，它的发展仍在继续，但其78.5％的使用率的统计结果违背了这些说法。 在这篇文章中，我已经带您领略了jQuery3的新特性。正如您可能已经注意到，这个版本不会打破任何现有的项目，因为它不会引入许多重大更改。尽管如此，有一些更改在升级前需要牢记。第三方的依赖升级前，该项目的审查会帮助你发现任何异常行为或损坏的功能。 再次声明 本文是这篇文章的翻译，作者是Aurelio De Rosa，译者是饮水思源。 非常感谢作者分享jQuery3新特性，让我们对jQuery有了全新的认识和体验。]]></content>
      <categories>
        <category>translation</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>translation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[九宫格样式的实现]]></title>
    <url>%2F2016%2F03%2F09%2F2016-3-9-sudoku%2F</url>
    <content type="text"><![CDATA[九宫格样式 页面显示九宫格，鼠标放在哪一个格子上，相应的格子的外边框变色； 具体效果如下： 下面先贴出代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;html&gt;&lt;head&gt; &lt;style&gt; #outer&gt;div&#123; width: 100px; height: 100px; float: left; border:5px solid blue; text-align: center; line-height: 100px; position: relative; &#125; #outer&gt;div:hover&#123; border:5px solid red; z-index:999; &#125; .middle&#123; margin-left: -5px; margin-right: -5px; &#125; .middle1&#123; margin-top: -5px; margin-bottom: -5px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div style="width:320px; height:320px;background-color:#eee" id="outer"&gt; &lt;div&gt;1&lt;/div&gt; &lt;div class="middle"&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div class="middle1"&gt;4&lt;/div&gt; &lt;div class="middle middle1"&gt;5&lt;/div&gt; &lt;div class="middle1"&gt;6&lt;/div&gt; &lt;div&gt;7&lt;/div&gt; &lt;div class="middle"&gt;8&lt;/div&gt; &lt;div&gt;9&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 研究 div换行问题： &lt;div&gt;是块级元素，前后有换行符，如果不加任何设置，九个div将垂直排列在页面； 解决方法是，先设置好外层、内层div的宽高，然后对内层div加入float: left;属性，使其向左浮动，去掉div前后的换行符，由于外层div有宽度限制，内层div在达到外层div宽度后，会自动换行，实现九宫格基本样式； 文字的居中问题： 对于文字的左右居中，不需要使用position属性配合left、margin-left属性来设置，只需用特定作用于文字的属性text-align: center;即可，这个属性不仅可以作用于文字，而且还能作用于很多块级元素，美中不足的是，如果父元素设置了text-align属性，它的所有子元素将继承这个属性的值； 对于文字的上下居中，本来也想使用position属性配合left、margin-left属性来设置，但看到网上有牛人直接用line-height就实现了，这个属性用于设置行间距，由于九宫格中的文字只有一行，所以将line-height设置为div的高度即可实现垂直居中效果； 负外边距的问题： 如果不对.middle和.middle1类设置负外边距，效果是下面的样子，即处于上下中间或左右中间的格子，只对自己的外边框变化了颜色，与我们要求的效果有差距； 通过将2、5、8格子的左右的margin设置为负值，4、5、6格子的上下的margin设置为负值，可有效避免相邻格子间的外边距叠加的问题； 将格子的position属性设置为relative，并且将鼠标悬浮时的格子的z-index属性设置为较大的值，可保证鼠标悬浮时，当前格子总是处于最高的层叠位置，否则会出现下图的情况：]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几种排序算法的实现]]></title>
    <url>%2F2016%2F01%2F05%2F2016-1-5-sort-algorithm%2F</url>
    <content type="text"><![CDATA[引言 排序算法是重要的基础算法； 排序算法的效率至关重要； 任何算法的空间效率和时间效率不可兼得，所以没有最好的算法，只有最合适的算法； 本文总结了几种排序算法，并分析了他们的适用场景，使用的语言为java和js； 选择排序（selection sort） 思想：对于一个数组a，找出数组中的最小元素并和a[0]交换，然后忽略a[0]，再次找出数组中的最小元素并与a[1]交换，以此类推； java实现： 123456789101112131415161718192021222324252627package algorithm;public class SelectionSort &#123; public static void main(String[] args) &#123; int[] nums = &#123; 1, 54, 6, 3, 78, 34, 12, 45 &#125;; sort(nums); for (int i = 0; i &lt; nums.length; i++) &#123; System.out.println(nums[i]); &#125; &#125; public static void sort(int[] myArray) &#123; for (int i = 0; i &lt; myArray.length; i++) &#123; int temp = myArray[i]; int position = i; for (int j = i + 1; j &lt; myArray.length; j++) &#123; if (myArray[j] &lt; temp) &#123; temp = myArray[j]; position = j; &#125; &#125; myArray[position] = myArray[i]; myArray[i] = temp; &#125; &#125;&#125; js实现： 1234567891011121314151617181920var nums = [1, 54, 6, 3, 78, 34, 12, 45];var selectionSort = function(nums)&#123; for(var i=0; i&lt;nums.length; i++)&#123; var temp = nums[i]; var position = i; for(var j=i; j&lt;nums.length; j++)&#123; if(nums[j]&lt;temp)&#123; temp = nums[j]; position = j; &#125; &#125; nums[position] = nums[i]; nums[i] = temp; &#125;&#125;selectionSort(nums);for(var number in nums)&#123; console.log(nums[number]);&#125; 插入排序（Insertion sort） 思想：从数组的第二个元素开始，将数组中的每一个元素按照规则插入到已排好序的数组中以达到排序的目的； java排序： 123456789101112131415161718192021222324package algorithm;public class InsertionSort &#123; public static void main(String[] args) &#123; int[] nums = &#123; 1, 54, 6, 3, 78, 34, 12, 45 &#125;; sort(nums); for (int i = 0; i &lt; nums.length; i++) &#123; System.out.println(nums[i]); &#125; &#125; public static void sort(int[] myArray) &#123; int temp = 0; for (int i = 1; i &lt; myArray.length; i++) &#123; int j = i - 1; temp = myArray[i]; for (; j &gt;= 0 &amp;&amp; temp &lt; myArray[j]; j--) &#123; myArray[j + 1] = myArray[j]; // 将大于temp的值整体后移一个单位 &#125; myArray[j + 1] = temp; &#125; &#125;&#125; js实现： 123456789101112131415var nums = [3,4,1,7,2,9,10,0];var insertionSort = function(nums)&#123; for(var i=1; i&lt;nums.length; i++)&#123; var temp = nums[i]; for(var j = i-1; j&gt;=0&amp;&amp;nums[j]&gt;temp; j--)&#123; nums[j+1] = nums[j]; &#125; nums[j+1]=temp; &#125;&#125;insertionSort(nums);for(var number in nums)&#123; console.log(nums[number]);&#125; 希尔排序（shell sort） 希尔排序是改进后的插入排序； 思想：由于数组越接近有序，插入排序时间复杂度越低，所以希尔排序不是直接对数组进行插入排序，而是先对数组分成若干组，对每一组分别进行插入排序，使得数组变得”更加有序”之后再扩大每组的元素个数，再对每组进行插入排序，以此类推，直至元素全部有序，这是一种为了降低时间复杂度的”渐进式”的插入排序； java实现： 12345678910111213141516171819202122232425262728293031323334package algorithm;public class InsertionSort &#123; public static void main(String[] args) &#123; int[] nums = &#123; 1, 54, 6, 3, 78, 34, 12, 45 &#125;; sort(nums); for (int i = 0; i &lt; nums.length; i++) &#123; System.out.println(nums[i]); &#125; &#125; public static void sort(int[] myArray) &#123; double d = myArray.length; while(true)&#123; d = Math.ceil(d/2); int inteval = (int)d; for(int i =0; i&lt;inteval; i++)&#123; for(int j=i+inteval; j&lt;myArray.length; j+=inteval)&#123; int temp = myArray[j]; int k = j-inteval; for(; k&gt;=0&amp;&amp;myArray[k]&gt;temp;k-=inteval)&#123; myArray[k+inteval] = myArray[k]; &#125; myArray[k+inteval] = temp; &#125; &#125; if(inteval==1)&#123; break; &#125; &#125; &#125;&#125; js实现： 12345678910111213141516171819202122232425var nums = [3,1,4,2,7,2,3,10];var shellSort = function(nums)&#123; var d = nums.length; while(true)&#123; d = Math.ceil(d/2); for(var i=0; i&lt;d; i++)&#123; for(var j=i+d; j&lt;nums.length; j++)&#123; var temp = nums[j]; for(var k = j-d; k&gt;=0&amp;&amp;nums[k]&gt;temp;k-=d)&#123; nums[k+d] = nums[k]; &#125; nums[k+d] = temp; &#125; &#125; if(d==1)&#123; break; &#125; &#125;&#125;shellSort(nums);for(var number in nums)&#123; console.log(nums[number]);&#125; 归并排序（Merge Sort） 归并排序是分治法在排序算法中的的典型实现； 归并排序是将一个数组分为两半A、B（或更多部分），对这两半分别排序后，再将他们归并为一个有序数组； 合并的方法：将A数组中的一个元素与B数组中的一个元素相比较，并将较小的元素复制到第三个新数组中，当其中一个数组到达末尾时，将另一个数组中剩余元素复制到第三个数组中即可； java实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package algorithm;public class InsertionSort &#123; public static void main(String[] args) &#123; int[] nums = &#123; 1, 54, 6, 3, 78, 34, 12, 45 &#125;; sort(nums,0,nums.length-1); for (int i = 0; i &lt; nums.length; i++) &#123; System.out.println(nums[i]); &#125; &#125; public static void sort(int[] myArray,int left,int right) &#123; if(left&lt;right)&#123; int center = (left+right)/2; sort(myArray,left,center); //递归 sort(myArray,center+1,right); merge(myArray,left,center,right); &#125; &#125; public static void merge(int[] myArray,int left,int center,int right)&#123; int[] result = new int[myArray.length]; int mid = center+1; int third = left; //记录新的数组result的偏移量 int tmp = left; //归并 while(left&lt;=center&amp;&amp;mid&lt;=right)&#123; if(myArray[left]&lt;=myArray[mid])&#123; result[third++] = myArray[left++]; &#125;else&#123; result[third++] = myArray[mid++]; &#125; &#125; //处理归并剩余部分 while(mid&lt;=right)&#123; result[third++] = myArray[mid++]; &#125; while(left&lt;=center)&#123; result[third++] = myArray[left++]; &#125; //复制回原数组 while(tmp&lt;=right)&#123; myArray[tmp] = result[tmp]; tmp++; &#125; &#125;&#125; js实现： 123456789101112131415161718192021222324252627282930313233343536373839404142var nums = [1, 54, 6, 3, 78, 34, 12, 45];var mergeSort = function(nums,left,right)&#123; if(left&lt;right)&#123; var center = Math.floor((left+right)/2); mergeSort(nums,left,center); mergeSort(nums,center+1,right); merge(nums,left,center,right); &#125;&#125;var merge = function(nums,left,center,right)&#123; var mid = center+1; var tmp = left; var third = left; var result = new Array(nums.length); while(left&lt;=center&amp;&amp;mid&lt;=right)&#123; if(nums[left]&lt;nums[mid])&#123; result[third++] = nums[left++]; &#125;else&#123; result[third++] = nums[mid++]; &#125; &#125; while(left&lt;=center)&#123; result[third++] = nums[left++]; &#125; while(mid&lt;=right)&#123; result[third++] = nums[mid++]; &#125; while(tmp&lt;=right)&#123; nums[tmp] = result[tmp]; tmp++; &#125;&#125;mergeSort(nums,0,nums.length-1);for(var number in nums)&#123; console.log(nums[number]);&#125; 冒泡排序（Bubble sort） 从第一个元素开始，比较相邻的元素，如果第一个比第二个大，就交换他们两个； 依次往后，对每一对相邻元素作同样的工作，直到序列最后，最后的元素应该会是最大的数； 从第一个元素开始，重复上面两步，直到倒数第二个元素就停止（最后一个元素肯定是序列中最大的，不用再次比较）； 重复上面的过程，直到序列末尾； java实现： 12345678910111213141516171819202122232425package algorithm;public class InsertionSort &#123; public static void main(String[] args) &#123; int[] nums = &#123; 1, 54, 6, 3, 78, 34, 12, 45 &#125;; sort(nums); for (int i = 0; i &lt; nums.length; i++) &#123; System.out.println(nums[i]); &#125; &#125; public static void sort(int[] myArray) &#123; int tmp; for(int i =0; i&lt;myArray.length-1; i++)&#123; for(int j=0; j&lt;myArray.length-1-i; j++)&#123; if(myArray[j]&gt;myArray[j+1])&#123; tmp = myArray[j]; myArray[j] = myArray[j+1]; myArray[j+1] = tmp; &#125; &#125; &#125; &#125;&#125; js实现： 123456789101112131415161718var nums = [1,5,3,6,2,7,9];var bubbleSort = function(nums)&#123; var temp; for(var i=0 ;i&lt;nums.length-1; i++)&#123; for(var j=0; j&lt;nums.length-1-i; j++)&#123; if(nums[j]&gt;nums[j+1])&#123; tmp = nums[j]; nums[j] = nums[j+1]; nums[j+1] = tmp; &#125; &#125; &#125;&#125;bubbleSort(nums);for(var number in nums)&#123; console.log(nums[number]);&#125; 快速排序(Quick Sort) 思想：选择一个基准元素,通常选择第一个元素或者最后一个元素,通过一趟扫描，将待排序列分成两部分,一部分比基准元素小,一部分大于等于基准元素,此时基准元素在其排好序后的正确位置,然后再用同样的方法递归地排序划分的两部分； java实现： 123456789101112131415161718192021222324252627282930313233343536373839package algorithm;public class InsertionSort &#123; public static void main(String[] args) &#123; int[] nums = &#123; 1, 54, 6, 3, 78, 34, 12, 45 &#125;; quickSort(nums,0,nums.length-1); for (int i = 0; i &lt; nums.length; i++) &#123; System.out.println(nums[i]); &#125; &#125; public static void quickSort(int[] list, int low, int high) &#123; if (low &lt; high) &#123; int middle = getMiddle(list, low, high); // 将list数组进行一分为二 quickSort(list, low, middle - 1); // 对低字表进行递归排序 quickSort(list, middle + 1, high); // 对高字表进行递归排序 &#125; &#125; public static int getMiddle(int[] list, int low, int high) &#123; int tmp = list[low]; // 数组的第一个作为中轴 while (low &lt; high) &#123; while (low &lt; high &amp;&amp; list[high] &gt;= tmp) &#123; high--; &#125; list[low] = list[high]; // 比中轴小的记录移到低端 while (low &lt; high &amp;&amp; list[low] &lt;= tmp) &#123; low++; &#125; list[high] = list[low]; // 比中轴大的记录移到高端 &#125; list[low] = tmp; // 中轴记录到尾 return low; // 返回中轴的位置 &#125;&#125; js实现： 123456789101112131415161718192021222324252627282930var nums = [1, 54, 6, 3, 78, 34, 12, 45];var quickSort = function(nums,low,high)&#123; if(low&lt;high)&#123; var middle = sort(nums,low,high); quickSort(nums,low,middle-1); quickSort(nums,middle+1,high); &#125; &#125;var sort = function(nums, low, high)&#123; var tmp = nums[low]; while(low&lt;high)&#123; while(low&lt;high&amp;&amp;tmp&lt;=nums[high])&#123; high--; &#125; nums[low] = nums[high]; while(low&lt;high&amp;&amp;tmp&gt;=nums[low])&#123; low++; &#125; nums[high] = nums[low]; &#125; nums[low] = tmp; return low;&#125;quickSort(nums,0,nums.length-1);for(var number in nums)&#123; console.log(nums[number]);&#125; 堆排序(Heap Sort) 堆的基本概念： 堆是节点含有可比较对象，并以如下方式组织的完全二叉树： 每个节点含有的对象不小于(最大堆)/不大于(最小堆)其后代中的对象； 最大（小）堆的根含有堆中最大（小）的对象； 最大（小）堆中任何节点的子树也是最大（小）堆； 堆排序原理： 这里讲解的很清楚； java实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package algorithm;public class InsertionSort &#123; public static void main(String[] args) &#123; int[] nums = &#123; 4,1,2,7,3,8,4,5,10 &#125;; heapSort(nums); for (int i = 0; i &lt; nums.length; i++) &#123; System.out.println(nums[i]); &#125; &#125; public static void heapSort(int[] myArray) &#123; for (int i = myArray.length - 1; i &gt;= 0; i--) &#123; // i记录了数组中参与重建最大堆的最后一个元素的索引值 buildMaxHeap(myArray, i); // 交换了第一个元素和倒数第myArray.length-1-i个元素 swap(myArray, 0, i); &#125; &#125; public static void swap(int[] myArray, int a, int b) &#123; int tmp; tmp = myArray[a]; myArray[a] = myArray[b]; myArray[b] = tmp; &#125; public static void buildMaxHeap(int[] myArray, int i) &#123; // (i-1)/2 是数组中最后一个具有叶子节点的节点的索引，从这个节点开始重建堆 for (int j = (i - 1) / 2; j &gt;= 0; j--) &#123; int k = j; while (k * 2 + 1 &lt;= i) &#123; int leftIndex = k * 2 + 1; // 当前节点的左子节点的索引 int rightIndex = leftIndex + 1; // 当前节点的右子节点的索引 int biggerInLeftRight = myArray[leftIndex]; // 左右子节点中较大的数 int biggerIndex = leftIndex; // 左右子节点中较大的数的索引 // 判断右子节点是否参与本次重建堆，参与则执行 if (rightIndex &lt;= i) &#123; // 找出左右子节点中较大的数 if (myArray[leftIndex] &lt; myArray[rightIndex]) &#123; biggerInLeftRight = myArray[rightIndex]; biggerIndex = rightIndex; &#125; &#125; // 将当前节点、当前节点的左右子节点中的最大值移到当前节点的位置 if (myArray[k] &lt; biggerInLeftRight) &#123; swap(myArray, k, biggerIndex); // 继续循环，确保当前节点的左右子节点也满足最大堆的性质 k = biggerIndex; &#125; else &#123; break; &#125; &#125; &#125; &#125;&#125; js实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243var nums = [8,3,5,0,2,7,9,10];var heapSort = function(nums)&#123; for(var i=nums.length-1; i&gt;=0; i--)&#123; buildMaxHeap(nums,i); swap(nums,0,i); &#125;&#125;var swap = function(nums, a, b)&#123; var tmp; tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp;&#125;var buildMaxHeap = function(nums,i)&#123; for(var j=Math.floor((i-1)/2); j&gt;=0; j--)&#123; var k = j; while(k*2+1&lt;=i)&#123; var leftIndex = k*2+1; var rightIndex = leftIndex+1; var biggerIndex = leftIndex; if(rightIndex&lt;=i)&#123; if(nums[leftIndex]&lt;nums[rightIndex])&#123; biggerIndex = rightIndex; &#125; &#125; if(nums[k]&lt;nums[biggerIndex])&#123; swap(nums,k,biggerIndex); k = biggerIndex; &#125;else&#123; break; &#125; &#125; &#125;&#125;heapSort(nums);for(var i=0; i&lt;nums.length; i++)&#123; console.log(nums[i]);&#125; 基数排序（radix sort） 基数排序和其他排序方法的思路不同，不是以比较对象大小为基础； 基础排序先将待排序对象的长度补全成相同的长度，然后从最后一位开始：将所有元素按照最后一位的大小排序，排序后元素的最后一位是有序的；再将所有元素按照倒数第二位的大小排序，排序后元素的倒数第二位是有序的，在倒数第二位相同的元素中，它们的最后一位是有序的；再将所有元素按照倒数第三位的大小排序，排序后元素的倒数第三位是有序的，在倒数第三位相同的元素中，它们的倒数第二位是有序的，在倒数第二位相同的元素中，它们的最后一位是有序的； 以此类推，直到元素的第一位排序完成； 此时元素已经是有序序列； java实现： 12345678910111213141516171819202122232425262728293031package test8;public class RadixSort &#123; public static void main(String[] args) &#123; int[] array = new int[] &#123; 20, 22, 98, 45, 77, 75, 55, 25, 52, 79, 56, 44, 32, 37, 35, 21, 102, 33, 178, 187, 156, 144 &#125;; sort(array, 3); // 传入数组和数组中长度最大的数的长度 for (int i = 0; i &lt; array.length; i++) &#123; System.out.print(array[i] + " "); &#125; &#125; public static void sort(int[] array, int d) &#123; int[][] bucket = new int[array.length][array.length]; for (int n = 1, m = 0; m &lt; d; n *= 10, m++) &#123; int[] num = new int[array.length]; //记录二维数组bucket的横向数组的长度 for (int i = 0; i &lt; array.length; i++) &#123; int position = array[i] / n % 10; bucket[position][num[position]] = array[i]; num[position]++; &#125; for (int k = 0, i = 0; k &lt; array.length; k++) &#123; for (int j = 0; j &lt; num[k]; j++, i++) &#123; array[i] = bucket[k][j]; &#125; &#125; &#125; &#125;&#125; 各种排序算法对比 资料： 这里有各种算法的汇总，进入相应的算法的词条有动图； 这里有HTML5动图，非常好看； 复杂度对比： 排序算法 最好时间复杂度 平均时间复杂度 最坏时间复杂度 稳定性 空间复杂度 冒泡排序 O(n) O(n^2) O(n^2) 稳定 O(1) 选择排序 O(n^2) O(n^2) O(n^2) 不稳定 O(1) 插入排序 O(n) O(n^2) O(n^2) 稳定 O(1) 希尔排序 O(n) O(n^1.5) O(n^2) 不稳定 O(1) 归并排序 O(n*logn) O(n*logn) O(n*logn) 稳定 O(1) 快速排序 O(n*logn) O(n*logn) O(n^2) 不稳定 O(logn)~O(n) 堆排序 O(n*logn) O(n*logn) O(n*logn) 不稳定 O(1) 基数排序 约为O(n) 约为O(n) 约为O(n) 稳定 O(rd+n) 各种排序方法的适用条件 当待排序总数较小，用插入排序或选择排序，虽然他们的时间复杂度高，但是在排序总数较小时时间并不是主要矛盾； 当待排序对象基本有序时，用插入排序、冒泡排序、快速排序，因为他们在序列接近有序的情况下的时间复杂度比序列完全无序时低； 若待排序对象非常多，选择快速排序（首选）、堆排序、归并排序，因为他们的时间复杂度为O(nlgn)，即用空间换取时间，以便解决“时间太长”这个主要矛盾； 若要求排序算法稳定，则选用归并排序；]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java日志]]></title>
    <url>%2F2015%2F12%2F30%2Fjava-log%2F</url>
    <content type="text"><![CDATA[引言 最近在做资源库管理系统，由于这个系统涉及一些复杂的操作，比如增删改查数据库表、用户申请新版本、审批和通过用户申请、导入和导出资源表，需要将每次操作的日志记录在专门的文件中，已被查阅和追责； 需求中提出的日志记录功能不是JVM或者是glassfish层面的日志，而是业务层面的日志，需要用专门的类完成这一功能； 顺便学习了java日志记录的相关知识； log4j 日志的记录一般是用Apache的Log4j包，log4j的优点在于：线程安全、可记录多个层次的日志信息、支持国际化、速度经过优化； 本文参考这篇文章； log4j下载和使用步骤 在这里下载； 将其中的jar包复制到eclipse工程中，并通过右键&gt;build path&gt;configuration&gt;library添加jar包进入工程； 在src直接下级目录创建并设置log4j.properties文件 log4j.properties文件可写成诸如下面的结构： 1234567891011121314151617181920log4j.rootLogger = debug,stdout,D,Elog4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target = System.outlog4j.appender.stdout.layout = org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern = [%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%nlog4j.appender.D = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.D.File = C:\\Users\\changsiyuan\\Desktop\\log.loglog4j.appender.D.Append = truelog4j.appender.D.Threshold = DEBUG log4j.appender.D.layout = org.apache.log4j.PatternLayoutlog4j.appender.D.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%nlog4j.appender.E = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.E.File = C:\\Users\\changsiyuan\\Desktop\\log.loglog4j.appender.E.Append = truelog4j.appender.E.Threshold = ERROR log4j.appender.E.layout = org.apache.log4j.PatternLayoutlog4j.appender.E.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n 程序需要先初始化log4j，然后再需要记录日志的地方调用相应的方法即可： 1234567891011121314151617181920212223242526272829303132333435package testlog;import java.io.File;import org.apache.log4j.BasicConfigurator;import org.apache.log4j.Logger;import org.apache.log4j.PropertyConfigurator;/** * * @author changsiyuan * */public class Test &#123; //获取日志记录器 private static Logger logger = Logger.getLogger(Test.class); /** * * @param args */ public static void main(String[] args) &#123; //配置log4j环境，自动快速地使用缺省Log4j环境 BasicConfigurator.configure(); // 记录debug级别的信息 logger.debug("This is debug message."); // 记录info级别的信息 logger.info("This is info message."); // 记录warn级别的信息 logger.warn ("This is warn message.") ; // 记录error级别的信息 logger.error("This is error message."); &#125;&#125; 配置文件参数说明 优先级说明 日志优先级从高到低为ERROR、WARN、INFO、DEBUG； 根配置信息 下面的配置信息表明将登记大于等于INFO的日志信息输出到stdout和R两个目的地； 1log4j.rootCategory=INFO,stdout,R 配置日志输出目的地信息 目的地参数如下：org.apache.log4j.ConsoleAppender（控制台）,org.apache.log4j.FileAppender（文件），org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件), org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）, org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方） 语法如下： 1234log4j.appender.appenderName = fully.qualified.name.of.appender.class log4j.appender.appenderName.option1 = value1 ...log4j.appender.appenderName.option = valueN 布局信息的配置 布局参数：org.apache.log4j.HTMLLayout（以HTML表格形式布局），org.apache.log4j.PatternLayout（可以灵活地指定布局模式），org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）, org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息） 语法如下： 1234log4j.appender.appenderName.layout = fully.qualified.name.of.layout.class log4j.appender.appenderName.layout.option1 = value1 ...log4j.appender.appenderName.layout.option = valueN 打印信息 语法：log4j.appender.appenderName.layout.ConversionPattern=...; 参数： 参数 含义 %m 输出代码中指定的消息 %p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL %r 输出自应用启动到输出该log信息耗费的毫秒数 %c 输出所属的类目，通常就是所在类的全名 %t 输出产生该日志事件的线程名 %n 输出一个回车换行符，Windows平台为“rn”，Unix平台为“n” %d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss,SSS}，输出类似：2002年10月18日 22：10：28，921 %l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数 配置文件示例 log写入控制台 12345678# Root logger optionlog4j.rootLogger=INFO, stdout# Direct log messages to stdoutlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.outlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-5p %c&#123;1&#125;:%L - %m%n log写入文件 12345678### set log levels ### log4j.rootLogger = debug,myloglog4j.appender.mylog=org.apache.log4j.FileAppenderlog4j.appender.mylog.append=truelog4j.appender.mylog.file= C://Users/changsiyuan/Desktop/log.txtlog4j.appender.mylog.layout=org.apache.log4j.PatternLayoutlog4j.appender.mylog.layout.ConversionPattern=%-5p %c: %m%n log写入文件并限制文件大小 1234567891011121314# Root logger optionlog4j.rootLogger=INFO, file# Direct log messages to a log filelog4j.appender.file=org.apache.log4j.RollingFileAppender#Redirect to Tomcat logs folder#log4j.appender.file.File=$&#123;catalina.home&#125;/logs/logging.loglog4j.appender.file.File=C:\\logigng.loglog4j.appender.file.MaxFileSize=10MBlog4j.appender.file.MaxBackupIndex=10log4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-5p %c&#123;1&#125;:%L - %m%n log同时写入日志和文件 12345678910111213141516# Root logger optionlog4j.rootLogger=INFO, file, stdout# Direct log messages to a log filelog4j.appender.file=org.apache.log4j.RollingFileAppenderlog4j.appender.file.File=C:\\logging.loglog4j.appender.file.MaxFileSize=10MBlog4j.appender.file.MaxBackupIndex=10log4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-5p %c&#123;1&#125;:%L - %m%n # Direct log messages to stdoutlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.outlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-5p %c&#123;1&#125;:%L - %m%n]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java注解]]></title>
    <url>%2F2015%2F12%2F29%2Fjava-annotation%2F</url>
    <content type="text"><![CDATA[引言 最近项目中需要在服务器端的REST层加入鉴权的机制，即客户端在HTTP请求中带上用户token，调用REST层的每一个API前需要经过鉴权的步骤，即向中心服务器发送用户token查询该用户是否具有调用此API的权限，如果有则可以调用，没有则不能调用； 由于REST层的API都已经写好，且鉴权的代码和API的代码分离，故初步决定反射机制实现这一功能； 由于用到了反射，顺便学习了下java注解； 本文参考这里； 注解的作用 注释是给人看的，注解是给程序看的； Annotation可被用于packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）； 注解的最主要作用是为特定的数据打上一个标记，以便以后拿来使用； 执行注解的原则：有什么标记（注解）就干什么事； 注释本质上是一个标记，可以在编译、类加载、运行时被读取，并执行相应的操作； 具体来说，注解有以下作用：生成文档、跟踪代码依赖性、在编译时进行格式检查； 元注解 元注解用于注解其他的注解； @Target ElemenetType.CONSTRUCTOR 构造器声明 ElemenetType.FIELD 域声明（包括 enum 实例） ElemenetType.LOCAL_VARIABLE 局部变量声明 ElemenetType.METHOD 方法声明 ElemenetType.PACKAGE 包声明 ElemenetType.PARAMETER 参数声明 ElemenetType.TYPE 类，接口（包括注解类型）或enum声明 @Retention RetentionPolicy.SOURCE 注解将被编译器丢弃 RetentionPolicy.CLASS 注解在class文件中可用，但会被VM丢弃 RetentionPolicy.RUNTIME VM 将在运行期也保留注释，因此可以通过反射机制读取注解的信息 @Documented @Documented 将此注解包含在javadoc中 ，它代表着此注解会被javadoc工具提取成文档; @Inherited @Inherited 允许子类继承父类中的注解; 基本注解 @Override：告诉编译器检查本方法确保被重写，只能作用于方法，不能作用于其他元素； @Deprecated：修饰类或者方法，告诉编译器这个被修饰的类或方法已经过时，编译时提出警告信息； @Suppress Warnings：取消编译器警告信息，作用于修饰的元素及所有子元素； @Safe Varargs：专门抑制堆污染警告； 其他的java定义好的注解直接查阅API文档即可； 自定义注解 自定义注解修饰各种语法成分 123456//注解的定义package test13;public @interface TestA &#123;&#125; 12345678910111213141516171819202122232425package test13;import java.util.HashMap;import java.util.Map;@TestApublic class UserAnnotation &#123; @TestA //使用了类成员注解 private Integer age; @TestA //使用了构造方法注解 public UserAnnotation()&#123; &#125; @TestA //使用了类方法注解 public void a()&#123; @TestA //使用了局部变量注解 Map m = new HashMap(0); &#125; public void b(@TestA Integer a)&#123; //使用了方法参数注解 &#125;&#125; 使用元注解 123456789101112package test13;import java.lang.annotation.Target;import java.lang.annotation.Retention;import java.lang.annotation.ElementType;import java.lang.annotation.RetentionPolicy;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface TestA &#123;&#125; 在注解中添加内容 123456789101112131415//定义注解package test13;import java.lang.annotation.Target;import java.lang.annotation.Retention;import java.lang.annotation.ElementType;import java.lang.annotation.RetentionPolicy;@Target(&#123;ElementType.TYPE,ElementType.METHOD,ElementType.FIELD,ElementType.CONSTRUCTOR&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface TestA &#123; String name(); int id() default 0; Class&lt;?&gt; gid();&#125; 123456789101112131415161718192021222324252627282930313233343536373839//使用注解package test13;import java.util.HashMap;import java.util.Map;@TestA(name = "type", gid = Long.class)// 类成员注解public class UserAnnotation &#123; @TestA(name = "param", id = 1, gid = Long.class) // 类成员注解 private Integer age; @TestA(name = "construct", id = 2, gid = Long.class) // 构造方法注解 public UserAnnotation() &#123; &#125; @TestA(name = "public method", id = 3, gid = Long.class) // 类方法注解 public void a() &#123; Map m = new HashMap(0); &#125; @TestA(name = "protected method", id = 4, gid = Long.class) // 类方法注解 protected void b() &#123; Map m = new HashMap(0); &#125; @TestA(name = "private method", id = 5, gid = Long.class) // 类方法注解 private void c() &#123; Map m = new HashMap(0); &#125; public void b(Integer a) &#123; &#125;&#125; 配合反射使用注解 一般的做法是，定义annotation生命周期为运行时仍存在，运行时通过反射获取相应的annotation内容，然后根据annotation的内容决定采取下一步的动作； 123456789101112131415//定义注解package test13;import java.lang.annotation.Target;import java.lang.annotation.Retention;import java.lang.annotation.ElementType;import java.lang.annotation.RetentionPolicy;@Target(&#123;ElementType.TYPE,ElementType.METHOD,ElementType.FIELD,ElementType.CONSTRUCTOR&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface TestA &#123; String name(); int id() default 0; Class&lt;?&gt; gid();&#125; 123456789101112131415161718192021222324252627282930313233343536373839//被注解修饰的类package test13;import java.util.HashMap;import java.util.Map;@TestA(name = "type", gid = Long.class)// 类成员注解public class UserAnnotation &#123; @TestA(name = "param", id = 1, gid = Long.class) // 类成员注解 private Integer age; @TestA(name = "construct", id = 2, gid = Long.class) // 构造方法注解 public UserAnnotation() &#123; &#125; @TestA(name = "public method", id = 3, gid = Long.class) // 类方法注解 public void a() &#123; Map m = new HashMap(0); &#125; @TestA(name = "protected method", id = 4, gid = Long.class) // 类方法注解 protected void b() &#123; Map m = new HashMap(0); &#125; @TestA(name = "private method", id = 5, gid = Long.class) // 类方法注解 private void c() &#123; Map m = new HashMap(0); &#125; public void b(Integer a) &#123; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//用反射机制使用注解package test13;import java.lang.annotation.Annotation;import java.lang.reflect.Constructor;import java.lang.reflect.Method;public class ParseAnnotation &#123; public static void parseTypeAnnotation() throws ClassNotFoundException &#123; //通过反射获取UserAnnotation类 Class&lt;?&gt; clazz = Class.forName("test13.UserAnnotation"); //获取类的注解信息,由于注解信息保留到了运行时，所以这里可以获取 Annotation[] annotations = clazz.getAnnotations(); for (Annotation annotation : annotations) &#123; TestA testA = (TestA) annotation; //id= 0;name= type;gid= class java.lang.Long (类注解仅有一个) System.out.println("id= " + testA.id() + ";name= " + testA.name() + ";gid= " + testA.gid()); &#125; &#125; public static void parseMethodAnnotation() &#123; //通过反射获取类方法 Method[] methods = UserAnnotation.class.getDeclaredMethods(); for (Method method : methods) &#123; boolean hasAnnotation = method.isAnnotationPresent(TestA.class); if (hasAnnotation) &#123; TestA annotation = method.getAnnotation(TestA.class); /* * method = c ; id = 5 ; description = private method; gid= class java.lang.Long * method = a ; id = 3 ; description = public method; gid= class java.lang.Long * method = b ; id = 4 ; description = protected method; gid= class java.lang.Long */ System.out.println("method = " + method.getName() + " ; id = " + annotation.id() + " ; description = " + annotation.name() + "; gid= " + annotation.gid()); &#125; &#125; &#125; public static void parseConstructAnnotation() &#123; //通过反射获取构造器 Constructor[] constructors = UserAnnotation.class.getConstructors(); for (Constructor constructor : constructors) &#123; boolean hasAnnotation = constructor .isAnnotationPresent(TestA.class); if (hasAnnotation) &#123; TestA annotation = (TestA) constructor .getAnnotation(TestA.class); /* * constructor = test13.UserAnnotation ; id = 2 ; description = construct; gid= class java.lang.Long */ System.out.println("constructor = " + constructor.getName() + " ; id = " + annotation.id() + " ; description = " + annotation.name() + "; gid= " + annotation.gid()); &#125; &#125; &#125; public static void main(String[] args) throws ClassNotFoundException &#123; parseTypeAnnotation(); parseMethodAnnotation(); parseConstructAnnotation(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射机制]]></title>
    <url>%2F2015%2F12%2F27%2Fjava-reflect%2F</url>
    <content type="text"><![CDATA[引言 最近的项目中，需要根据客户端传入的id来动态的实例化对象，所以学习了一下java的反射机制； 反射的定义 反射是指程序可以访问、检测和修改它本身状态或行为的一种能力，并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义； import是在程序编译时，静态引入相应类，反射是程序运行时，根据某一字符串，访问、创建这个字符串描述的类或是它的方法； 反射的作用 在运行时判断任意一个对象所属的类 ； 在运行时构造任意一个类的对象 ； 在运行时判断任意一个类所具有的成员变量和方法 ； 在运行时调用任意一个对象的方法； 反射所需的API都位于java.lang.reflect包中： Class类：代表一个类，位于java.lang包下； Field类：代表类的成员变量（成员变量也称为类的属性）； Method类：代表类的方法； Constructor类：代表类的构造方法； Array类：提供了动态创建数组，以及访问数组的元素的静态方法； 反射实例 获取Class对象： 12345678910111213141516package test12;public class Employee &#123; public static void main(String[] args) throws ClassNotFoundException &#123; Class c1 = Class.forName("test12.Employee"); Class c2 = Employee.class; Employee e = new Employee(); Class c3 = e.getClass(); System.out.println(c1); //class test12.Employee System.out.println(c2); //class test12.Employee System.out.println(c3); //class test12.Employee &#125;&#125; 获取所有成员变量: 123456789101112131415161718192021package test12;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class Employee &#123; public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, SecurityException, IllegalArgumentException, InvocationTargetException &#123; Class&lt;?&gt; c = Class.forName("test12.test"); //获取所有成员变量 Field[] f = c.getFields(); for(int i =0; i&lt;f.length; i++)&#123; System.out.println(f[i]); //public int test12.test.c &#125; &#125;&#125; 获取特定的成员变量: 123456789101112131415161718192021package test12;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class Employee &#123; public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, SecurityException, IllegalArgumentException, InvocationTargetException, NoSuchFieldException &#123; Class&lt;?&gt; c = Class.forName("test12.test"); //获取特定成员变量 Field f = c.getField("c"); System.out.println(f); //public int test12.test.c Field f1 = c.getField("d"); //java.lang.NoSuchFieldException System.out.println(f1); &#125;&#125; 获取所有方法: 12345678910111213141516package test12;import java.lang.reflect.Method;public class Employee &#123; public static void main(String[] args) throws ClassNotFoundException &#123; Class c = Class.forName("java.lang.String"); Method[] methods = c.getDeclaredMethods(); for (Method method : methods) &#123; System.out.println(method); //输出所有方法 &#125; &#125;&#125; 获取特定的方法并调用之 1234567891011121314151617181920212223package test12;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class Employee &#123; public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, SecurityException, IllegalArgumentException, InvocationTargetException &#123; Class c = Class.forName("test12.test"); //获取方法 Object t = c.newInstance(); System.out.println(t instanceof test); //true //调用方法 Method stringMethod = c.getDeclaredMethod("plus", new Class[]&#123;int.class, int.class&#125;); Object result = stringMethod.invoke(t, new Object[]&#123;1,2&#125;); System.out.println(result); //3 System.out.println(result instanceof Integer); //true &#125;&#125; 12345678//test类package test12;public class test &#123; public int plus(int a, int b)&#123; return a+b; &#125;&#125; 动态生成对象（构造器不含参数） 12Class&lt;?&gt; classType = String.class;Object obj = classType.newInstance(); 动态生成对象（构造器含参数）: 123456789101112131415161718192021222324package test12;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class Employee &#123; public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, SecurityException, IllegalArgumentException, InvocationTargetException &#123; Class c = Class.forName("test12.test"); //获取构造器并实例化类 Constructor cons = c.getConstructor(new Class[] &#123;int.class, int.class&#125;); Object obj = cons.newInstance(new Object[] &#123;10,20&#125;); //调用方法 Method stringMethod = c.getDeclaredMethod("plus"); Object result = stringMethod.invoke(obj); System.out.println(result); //30 System.out.println(result instanceof Integer); //true &#125;&#125; 12345678910111213141516//test类package test12;public class test &#123; private int a; private int b; public test(int a, int b)&#123; this.a = a; this.b = b; &#125; public int plus()&#123; return a+b; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的多态]]></title>
    <url>%2F2015%2F12%2F25%2Fjava-polymorphism%2F</url>
    <content type="text"><![CDATA[引言 最近研究了一下java中的多态这一java特有的非常优秀的特性； 多态增加了程序的灵活性和可扩展性，但是也对程序的安全性和稳定性提出了挑战； 多态的概念 多态的定义：指允许不同类的对象对同一消息做出响应，即同一消息可以根据发送对象的不同而采用多种不同的行为方式（发送消息就是函数调用）； 多态的分类：编译时多态（方法的重载就是其具体实现），运行时多态（本文中的多态均指运行时多态）； 实现多态的技术是动态绑定（dynamic binding）：是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法； 多态的作用：消除类型之间的耦合关系； 多态存在的条件 要有继承（包括接口的实现）； 要有重写； 父类引用指向子类对象； 实例 父类如下： 123456789101112package test11;public class BaseClass &#123; public int a = 6; public void base()&#123; System.out.println("父类普通方法"); &#125; public void test()&#123; System.out.println("父类被覆盖方法"); &#125;&#125; 子类如下： 123456789101112131415161718192021222324252627282930313233343536373839package test11;public class SubClass extends BaseClass&#123; public int b = 8; public int a = 8; public void test()&#123; System.out.println("子类覆盖父类的test方法"); &#125; public void sub()&#123; System.out.println("子类普通方法"); &#125; public static void main(String[] args) &#123; BaseClass base = new BaseClass(); SubClass sub = new SubClass(); BaseClass bc = new SubClass(); //SubClass sb = new BaseClass(); //编译时报错，不能从父类到子类强制转换 System.out.println(base.a); //6 //System.out.println(base.b); //报错，因为BaseClass没有变量b base.base(); //父类普通方法 base.test(); //父类被覆盖方法 System.out.println(sub.b); //8 System.out.println(sub.a); //8 sub.test(); //子类覆盖父类的test方法 sub.sub(); //子类普通方法 sub.base(); //父类普通方法 //System.out.println(bc.b); //编译时报错，编译时bc是BaseClass类，不含有变量b System.out.println(bc.a); //6，因为变量没有多态的特性 bc.test(); //子类覆盖父类的test方法 //bc.sub(); //编译时报错，编译时bc是BaseClass类，不含有方法sub() bc.base(); //父类普通方法 &#125;&#125; BaseClass base = new BaseClass();定义base为父类，可访问所有父类的变量和方法； SubClass sub = new SubClass();定义为子类，优先访问子类中的变量和方法，如果没有，再从父类寻找； 对于BaseClass bc = new SubClass();: 编译时，系统首先new出来一个SubClass类的实例，系统自动将这个new出来的实例强制转换为BaseClass类型，并且赋给bc对象； 运行时，bc对象名义上是BaseClass类型，实际上是SubClass类型，bc对象可访问且优先访问SubClass类中的方法，找不到的话再到它的父类BaseClass寻找； 尽管bc对象在运行时是SubClass类型，bc对象在运行时是可以访问SubClass自己的方法的（比如sub()方法），但是由于bc对象在编译时是BaseClass类型，bc.sub()这一句话根本通不过编译，所以运行时bc对象实际上是不能访问sub()方法的； 在编译时，base和bc对象都是BaseClass类型的对象，但是在运行时base仍为BaseClass类型，bc却是SubClass类型，这就出现了base和bc这两个编译时相同类型的变量，在运行时调用test()方法的结果却不一致的现象，就是多态； 多态性只对方法有效，对于变量无效，所以访问bc对象的a变量时，输出父类的a变量而非子类的a变量值，这和java内部运行机制有关；]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Latex使用方法]]></title>
    <url>%2F2015%2F12%2F20%2Flatex%2F</url>
    <content type="text"><![CDATA[引言 最近要写论文，所以粗浅学了下Latex的使用方法； 本文将Latex常用的语法和工具做个总结，大多数是借鉴和引用别人的博客； Latex Latex是一种排版工具，借助于特定的语法实现论文、书籍等的排版； 想要实现用Latex排版一篇论文，需要以下几个工具或软件： 学习Latex语法； 安装Latex解析器和Latex的pdf生成工具，本文选用TexLive2015； 安装一款适合自己的Latex编辑器，本文选用Texmaker； TexLive2015 教程请点击这里； iso镜像文件下载地址： 地址一; 地址二，密码txt3； 安装方法：解压iso文件后，双击批处理文件install-tl-advanced，选择安装目录后，即可安装； Latex编辑器 texLive软件自带编辑器teXworks editor； 也可选用其它编辑器：textmarker、teXstudio、在线编辑器sharelatex、其他编辑器; Latex常用语法 教程 入门教程； 排版和格式； 官方教程； 数学常用 数学公式; 括号; 数学符号; 希腊字母; 生成参考文献 进入谷歌学术； 点击谷歌学术的设置按钮，选择“显示导入BibTex的链接”； 在谷歌学术中所搜所需的文章，点击文章下面的导出BibTex按钮，即可自动生成该文章的BibTex的引用信息； 添加一个名为”myreference.bib”的文件，放在和.tex文件的同一目录下，将上面生成的BibTex复制进去； 在.tex文件的需要添加参考文献的地方（必须是\end{document}之前）添加下面的代码： 12\bibliographystyle&#123;plain&#125; ## 设置参考文献的类型，plain代表标准类型\bibliography&#123;myreference.bib&#125; ## 设置bib文件的名称，让latex编译器能够找到bib文件 我用的编辑器是Texmaker，点击工具&gt;BibTex，编译bib文件； bib文件编译好后，再编译.tex文件（运行.tex文件），即可看到效果： 引用参考文献： 1\cite&#123;文章名称&#125; ## 文章名称是指写在bib文件中的@article后面的内容]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaEE Web开发规范汇总]]></title>
    <url>%2F2015%2F12%2F15%2FJavaEE-Web-standard%2F</url>
    <content type="text"><![CDATA[引言 在开发系统资源库项目的过程中，发现自己的代码有多处不规范之处； 本文总结了JavaEE Web的一些开发规范，尤其是RESTful设计模式的一些常见的规范，以警示自己编写代码必须要规范、可维护、可扩展； 数据库设计和命名规范 库表名称、字段名称含义明确，并且使用snake_case命名，避免使用特殊符号和sql关键字； 字段应当具有原子性，不可再分； Table用单数，Column用单数； 代表个数、次数等数量概念的，用count，比如xxx_count; 时间类型统一规定命名为xxx_date的形式，并且带上timezone； boolean类型的命名要用is_xxx格式，比如在业务上删除一条记录时，并不会将本条记录真正从数据库中删除，而是将is_deleted字段置为相应的值； 每个表都要有主键，名称是id，类型为bigint； 一个字段不要有多个用途； varchar的缺省长度是255，varchar(50)并不比varchar(255)节省空间，因为这个空间只在需要时才分配，而不会提前分配，使用varchar(255)可以提升系统的可持续性； 必须避免不同数据库表的数据冗余，数据冗余很容易造成数据的不一致性； 不同的数据库表间应当尽量解耦，这样可以保证每个表只存储他该存储的信息，库表间可用外键连接； 关于数据库表设计，可参考这里； RESTful设计规范 我画了一张图清晰地说明了再用Java开发Web应用时，如果使用RESTful设计模式，应该遵循的架构： 对上图的说明： REST层只向client提供数据接口，不进行数据查询和处理； Service层向REST提供各种数据和服务，是进行数据处理最重要的一层； DAO层内含有各种SQL语句，以便查询； entity是数据库中一条记录的映射对象； entity manager对象根据相关的配置文件（如persistence.xml），在EJB容器中，负责数据库连接的管理、释放等工作； 数据库保存数据； 不同的REST和Dao之间不要传递数据，如果一个Service需要另一个Service的数据，可相互传递； EntityManager实例化的两种方式：12345//方法一：通过createEntityManagerFactory方法实例化EntityManager em = Persistence.createEntityManagerFactory("cn.com.haohandata_ResourceStore_war_1.0-SNAPSHOTPU") .createEntityManager();//方法二：通过@PersistenceContext注入@PersistenceContext(unitName = "cn.com.haohandata_ResourceStore_war_1.0-SNAPSHOTPU") private EntityManager em; RESTful API设计规范（老师总结） 原则： 资源（URL）永远是名词，操作（HTTP方法）永远是动词； GET永远不应该修改对象内容; 基本形式 GET /weibo - 获取微博列表 GET /weibo/12 - 获取某个微博 POST /weibo - 创建微博 PUT /weibo/12 - 修改某个微博 PATCH /weibo/12 - 部分修改某个微博 DELETE /weibo/12 - 删除某个微博 有关系的资源 GET /weibo/12/comment - 获取某个微博的评论列表 GET /weibo/12/comment/5 - 获取某个微博的某个评论 POST /weibo/12/comment - 创建微博的评论 PUT /weibo/12/comment/5 - 修改某个微博的某个评论 PATCH /weibo/12/comment/5 - 部分修改某个微博的某个评论 DELETE /weibo/12/comment/5 - 删除某个微博的某个评论 不太能归类为CRUD的操作 PUT /weibo/12/like - 给某个微博点赞 DELETE /weibo/12/like - 删除某个微博的赞 过滤、排序、搜索等 GET /weibo?deleted=true - 得到所有标记为删除的微博 GET /weibo?sort=-create-date - 按照创建日期反序排序得到微博列表 GET /weibo?sort=comment-count,-create-date - 先按微博评论数再按创建日期反序排序得到微博列表 GET /weibo?keyword=xxx - 得到包含关键字xxx的微博列表 GET /weibo?keyword=xxx&amp;deleted=true&amp;sort=comment-count,-create-date - 搜索关键字包含xxx的标记为删除的微博，按照评论数再按创建日期反序排序得到微博列表 常用的查询可以独立出来 GET /weibo/top10 - 得到最热前10名的微博列表 这里写得非常不错 编写Java代码需要注意 参考这里 保持方法简短扼要 永远永远不要将同一个变量用于不同的目的 尽可能让变量和方法的名称能够描述要实现的功能 尽可能将变量定义在最靠近它们的地方 不要出现让人费解的数字 要像对待朋友一样对待你擅长的语言 不要逆常规而行 千万小心过早的优化代码 要常常重构经过测试的代码 不要沉溺于过度的设计技巧 随时随地学习新的知识]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>RESTful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令汇总]]></title>
    <url>%2F2015%2F12%2F12%2Flinux-cmd%2F</url>
    <content type="text"><![CDATA[引言 本文总结了我经常用到的linux命令，以后会补充； 帮助命令 --help man 文本处理 grep：使用正则表达式搜索文本，适用于在话单中快速找出需要的内容 1cat ip.csv grep *guangdong* | head -n 10 awk:从前面命令的结果中筛选列或行 1hadoop fs -du /user/siyuan/test/test2/* | awk '&#123;if($1!=0)&#123;print $2&#125;&#125;' 磁盘管理/目录管理 fdsik -l: 查看磁盘分区表 df: 查看磁盘分区使用情况 du: 查看当前目录下子目录的大小 mount 挂载设备名 挂载目录: 挂载设备，比如mount /dev/sda1 /mnt/disk1 文件/目录 cd: 切换目录 pwd: 查看当前目录 mkdir: 新建目录, -m 制定权限, -p创建多层目录 touch: 新建文件 vi: 新建、编辑文件 rmdir: 删除目录 rm: 删除文件/目录 mv 源文件或目录 目标文件或目录: 移动文件/文件改名 cp 源文件或目录 目标文件或目录: 复制文件 chmod: 更改权限 ls -lht: 查看当前目录下文件的大小 cat/head/tail/less/more: 查看文件,下面是详细的使用说明 cat 文件名：查看文件全部信息，从头开始向下滚动； head 文件名：查看文件开头前10行信息； head -n 文件名：查看文件开头前n行信息； tail 文件名：查看文件最后10行信息； tail -n 文件名：查看文件最后n行信息； less 文件名：从文件开头显示一屏文件内容（先加载一部分文件内容、不是全部加载），按向下、向上、page up、page down、G（移动到最后一行）、g（ 移动到第一行）、ctrl + F（向前移动一屏）、ctrl + B（向后移动一屏）、q（退出）可以随意查看； more 文件名：从文件开头显示一屏文件内容，只能向下翻页，ctrl + F（向前移动一屏）、ctrl + B（向后移动一屏）、q（退出）； 软件 yum install 软件包名称: 查找、安装、删除某一个或一组软件包 软件名 --version: 检测软件是否正确安装 rpm -ql +软件名: 查看某个软件是否安装、安装路径 rpm -qi +软件名: 查看某个软件版本等相关信息 网络 ifconfig: 查看网络配置、网卡 netstat -a: 查看所有程序的协议、端口 ping: 查看网络连通情况 系统运行 jps -lm: 查看本机正在跑的进程 top: 查看CPU和内存使用率 free -m或cat /proc/meminfo或vmstat: 查看内存使用情况、空闲内存数量 iostat: 查看当前硬盘读写速率等 ifstat: 查看当前网络IO状况 netstat: 查看本机端口占用情况 ps aux: 查看正在进行的任务/程序，即任务管理器 系统配置 cat /proc/cpuinfo: 查看机器配置信息（包括CPU主频型号核心数等等） cat /proc/cpuinfo |grep &quot;physical id&quot;|sort |uniq|wc -l: 查看物理CPU个数 cat /proc/cpuinfo |grep &quot;processor&quot;|wc -l: 查看逻辑CPU的个数 cat /proc/cpuinfo |grep &quot;cores&quot;|uniq: 查看CPU是几核 cat /proc/cpuinfo |grep MHz|uniq: 查看CPU的主频 cat /proc/version: Linux查看当前操作系统版本信息 cat /etc/issue: Linux查看版本当前操作系统发行版信息 uname -a: 查看当前操作系统内核信息 echo $PATH: 查看环境变量PATH的值 系统管理 useradd: 增加新用户 who: 每个用户、什么时间、从哪台机器上面连上来 su 用户名: 切换到某个用户 sudo: 以系统管理者的身份执行指令 exit/logout: 退出当前用户 reboot: 重启机器 halt/poweroff/shutdown: 关机]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery选择器]]></title>
    <url>%2F2015%2F12%2F11%2FjQuery-selector%2F</url>
    <content type="text"><![CDATA[引言 jQuery是一个javascript库，最为重要的作用就是动态的、灵活的操纵DOM对象； jQuery选择器多种多样，满足了不同的筛选DOM对象的需求； jQuery选择器和css选择器在很大程度上相似，但是jQuery选择器以及jQuery对于选择结果的处理上更加丰富和充实（比如使用回调函数处理选择结果）； 本文总结了各种类型的jQuery选择器，当然这还不全面，在工作中如果用到其他类型的、效率更高的选择器我会及时补充； jQuery选择器基本语法 jQuery选择器的语法相当简单： 12345&lt;script&gt; $("selector").function()&#123; ... &#125;&lt;/script&gt; 可以对比下css选择器的语法： 123456&lt;style&gt; selector1, selector2 &#123; ... &#125;&lt;/style&gt; 最小粒度选择器 选择器 选择对象 实例 * 任意元素 tag name 选择 h1 #id 选择id名称（单一元素） #test .class 选择class（一类元素） .test selector(空格):伪类/伪元素 加入伪类伪元素,相当于对selector的筛选结果再做逻辑筛选 $(“#form1 :text”) 属性选择器 选择器 实例 选取 [attribute] $(“[href]”) 所有带有 href 属性的元素 [attribute=value] $(“[href=’#’]”) 所有 href 属性的值等于 “#” 的元素 [attribute!=value] $(“[href!=’#’]”) 所有 href 属性的值不等于 “#” 的元素 [attribute$=value] $(“[href$=’.jpg’]”) 所有 href 属性的值包含以 “.jpg” 结尾的元素 选择器级联 选择器 选择对象 实例 selector1, selector2 不同的选择器用逗号隔开(css),不同选择器直接相连 $(“.main”).$(“.test”) selector1selector2selector3 元素必须满足所有选择器的条件才能被选中 $(“.main.btn”) selector1&gt;selector2 筛选出符合selector1的元素的符合selector2的所有直接后代元素 $(“.main&gt;p”) selector1(空格)selector2 筛选出符合selector1的元素的符合selector2的所有后代元素 $(“.main p”) selector1+selector2 筛选出符合selector1的元素的紧挨着它的后面的同级（兄弟）元素，这个兄弟元素必须符合selector2 $(“#test3+#test4”) selector1~selector2 筛选出符合selector1的元素后面的所有的同级（兄弟）元素，这个兄弟元素必须符合selector2 $(“#test3~#test4”) $(“selector1”).filter(“selector2”) 用selector2的筛选条件去过滤selector1的筛选结果 $(“.main”).filter($(“p”)) 伪类和伪元素 这里借用书上的和w3cschool的几张图片加以说明； 普通伪类选择器 文本相关 子元素相关 表单相关]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery中$符号的含义]]></title>
    <url>%2F2015%2F12%2F10%2FjQuery-%24%2F</url>
    <content type="text"><![CDATA[$符号表示什么 $()函数是jQuery()函数的别称； 例子： 12345678$(document).ready(function()&#123; alert("aaa");&#125;);$("#btn1").bind(&#123; mouseover:function()&#123;$(this).attr("style","color:red")&#125;, mouseout:function()&#123;$(this).attr("style","color:yellow")&#125;&#125;) 禁用$符号 在引入多个库时，$符号有可能和别的库重复； 此时需要禁用jQuery中的$符号，或是自定义jQuery的简写符号； 1234567891011121314151617&lt;script&gt; //不使用jQuery的$符号 jQuery.noConflict(); jQuery(document).ready(function()&#123; jQuery("#me").mouseover(function()&#123; jQuery("#me").css("background-color","blue"); &#125;) &#125;) //自定义jQuery简写符号 var jq = jQuery.noConflict(); jq(document).ready(function()&#123; jq("#me").mouseover(function()&#123; jq("#me").css("background-color","yellow"); &#125;) &#125;)&lt;/script&gt; 几个函数的区别 几个document相关的函数在jQuery中使用： 1234567891011//jQuery中使用，等待DOM加载完毕后就执行$(document).ready(fucntion()&#123;...&#125;)//jQuery中使用，等待页面全部加载完毕后才执行（图片音频视频等全部加载完毕后才执行）$(window).load(function()&#123; ...&#125;)//纯js中使用，等待DOM加载完毕后就执行document.ready = function()&#123;...&#125;//纯js中使用，等待页面全部加载完毕后才执行（图片音频视频等全部加载完毕后才执行）window.onload = function()&#123;...&#125; 下面的几个函数完全等价： 123456789101112131415$(document).ready(function()&#123; alert("aaa");&#125;);jQuery(document).ready(function()&#123; alert("bbb");&#125;);$(function()&#123; alert("ccc");&#125;)jQuery(function()&#123; alert("ddd");&#125;) 禁用浏览器的前进后退按钮： 1234567&lt;script&gt; $(document).ready(function() &#123; window.history.forward(1); //or window.history.forward(-1); &#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中字符串截取函数的对比]]></title>
    <url>%2F2015%2F12%2F08%2F2015-12-8-js-substring%2F</url>
    <content type="text"><![CDATA[引言 在js中，字符串处理是很重要的； 常用的字符串的截取函数有三个，分别是slice()、substring()、substr()； 他们的区别在哪里呢？我做了一点小研究； slice(start, end)函数 截取值包含start不包含end； start如果为负数，会从尾部算起，-1表示倒数第一个，-2表示倒数第2个，此时end必须为负数，并且是大于start的负数，否则返回空字符串； slice的end如果为负数，同样从尾部算起，如果其绝对值超过原字符串长度或者为0，返回空字符串； 123456789101112&lt;script&gt; var s = "abcdefgh"; console.log(s.slice(1,3)); //bc console.log(s.slice(4,10)); //efgh (end超过字符串长度) console.log(s.slice(10,11)); //空字符串 (start超过字符串长度) console.log(s.slice(-3, -1)); //fg console.log(s.slice(-2,1)); //空字符串 (start若为负值，end必须也为负值) console.log(s.slice(-10, -3)); //abcde (start负值超过了字符串长度) console.log(s.slice(-12,-10)); //空字符串 (end负值超过了字符串长度)&lt;/script&gt; substring(start, end)函数 截取值包含start不包含end； 不允许操作数为负数； 取start和end中较小的值为start,二者相等返回空字符串，任何一个参数为负数被替换为0(即该值会成为start参数)； 1234567891011121314&lt;script&gt; var s = "abcdefgh"; console.log(s.substring(1,3)); //bc console.log(s.substring(4,10)); //efgh (end超过字符串长度) console.log(s.substring(10,11)); //空字符串 (start超过字符串长度) console.log(s.substring(3,1)); //bc console.log(s.substring(-3, -1)); //空字符串 console.log(s.substring(-2,1)); //a (-2被替换成0) console.log(s.substring(-10, -3)); //空字符串 console.log(s.substring(-12,-10)); //空字符串&lt;/script&gt; substr(start, length)函数 其第二个参数表示要截取的长度，而不是截取的终点，若该参数为负数或0，都将返回空字符串； start参数可以为负值； 1234567891011&lt;script&gt; var s = "abcdefgh"; console.log(s.substr(1,3)); //bcd console.log(s.substr(3,1)); //d console.log(s.substr(-2,1)); //g console.log(s.substr(4,10)); //efgh (end超过字符串长度) console.log(s.substr(10,5)); //空字符串 (start超过字符串长度) console.log(s.substr(-3, -1)); //空字符串&lt;/script&gt;]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5 新特性]]></title>
    <url>%2F2015%2F12%2F07%2F2015-12-7-html5-property%2F</url>
    <content type="text"><![CDATA[引言 html5是html语言的第五次重大修改； HTML5的第一份正式草案已于2008年1月22日公布，HTML5仍处于完善之中，然而，大部分现代浏览器已经具备了某些 HTML5支持； 2012年12月17日，万维网联盟（W3C）正式宣布HTML5规范正式定稿； HTML5具有诸多亮点和新特性，本文总结了html5常用的新特性，供大家参考； 文档声明方式的转变 HTML5声明 1&lt;!DOCTYPE html&gt; HTML4声明 1&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt; XHTML声明 1&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; 对比可知，HTML5的声明非常简单，这是因为它不依赖于SGML。要知道详细的DOCTYPE声明方式，请看我的另一篇博客； 脚本无需加注type属性 HTML4 12&lt;link rel="stylesheet" href="path/to/stylesheet.css" type="text/css" /&gt;&lt;script type="text/javascript" src="path/to/script.js"&gt;&lt;/script&gt; HTML5 12&lt;link rel="stylesheet" href="path/to/stylesheet.css" /&gt;&lt;script src="path/to/script.js"&gt;&lt;/script&gt; 标签的变化新增的标签 header和footer 在html5中可以直接使用&lt;header&gt;和&lt;footer&gt;标签 123456&lt;header&gt; ...&lt;/header&gt;&lt;footer&gt; ...&lt;/footer&gt; 高亮标签： 1&lt;mark&gt;this is marked words.&lt;/mark&gt; 图片和图片描述文字的语义化链接 123456&lt;figure&gt; &lt;figcaption&gt; &lt;p&gt;this is my picture:&lt;/p&gt; &lt;/figcaption&gt; &lt;img src="img/11.png" alt="this is me"&gt;&lt;/figure&gt; 废弃的标签 frame frameset noframe applet big center basefront HTML5表单新特性 允许缩略属性，比如&lt;input type=&quot;text&quot; name=&quot;someInput&quot; required&gt;等价于&lt;input type=&quot;text&quot; name=&quot;someInput&quot; required=&quot;required&quot;&gt;，这在XHTML中是不允许的； 新增autofocus属性，可实现自动聚焦某个表单控件 1&lt;input type="text" autofocus="autofocus" required&gt; 新增placeholder属性，向表单输入控件预制提示信息； 1&lt;input type="text" placeholder="please input your name" required&gt; 新增pattern属性，实现自动正则匹配用户的输入，如果不满足条件则不予提交表单； 1&lt;input type="text" pattern="[A-Za-z]&#123;4,10&#125;"&gt; 新增datalist属性，实现在用户输入的同时，按照用户的输入给出相应的提示信息： 12345678910&lt;form&gt; &lt;input list="Country"&gt; &lt;datalist id="Country"&gt; &lt;option value="China"&gt; &lt;option value="America"&gt; &lt;option value="Italy"&gt; &lt;option value="India"&gt; &lt;/datalist&gt; &lt;input type="submit" class="btn"&gt;&lt;/form&gt; 新增多种表单属性： 自动弹出颜色选择器&lt;input type=&quot;color&quot; name=&quot;favcolor&quot;&gt;； 自动弹出日期选择器&lt;input type=&quot;date&quot; name=&quot;bday&quot;&gt; 或 &lt;input type=&quot;datetime-local&quot; name=&quot;bdaytime&quot;&gt;； 自动校验email格式正确&lt;input type=&quot;email&quot; name=&quot;email&quot;&gt;； 自动校验url格式正确&lt;input type=&quot;url&quot; name=&quot;sitename&quot;&gt;； 自动显示数字增减上下箭头&lt;input type=&quot;number&quot; name=&quot;quantity&quot; min=&quot;1&quot; max=&quot;5&quot;&gt;； 自动显示范围增减条&lt;input type=&quot;range&quot; min=&quot;0&quot; max=&quot;10&quot; step=&quot;2&quot; value=&quot;6&quot;&gt;； 文本框作为搜索引擎&lt;input type=&quot;search&quot; name=&quot;googleengine&quot;&gt;； 只能输入时间&lt;input type=&quot;time&quot; name=&quot;usr_time&quot;&gt;； 输入电话号码&lt;input type=&quot;tel&quot; name=&quot;mytel&quot;&gt;； HTML5 多媒体支持 支持的视频格式：Ogg、MPEG4、WebM； 1234&lt;video width=”450″ height=”340″ controls&gt; &lt;source src=”jamshed.mp4″ type=”video/mp4″&gt; &lt;source src=”jamshed.ogg” type=”video/ogg”&gt;&lt;/video&gt; 支持的音频格式:Ogg Vorbis、MP3、Wav； 1234&lt;audio controls&gt; &lt;source src=”jamshed.mp3″ type=”audio/mpeg”&gt; Your browser does’nt support audio embedding feature.&lt;/audio&gt; HTML5 图像支持 SVG线条图案： 1234&lt;svg id="svgLineTutorial" style="border-style:solid;border-width:2px;" height="200px" width="200px" xmlns="http://www.w3.org/2000/svg"&gt; &lt;line x1="10" y1="20" x2="100" y2="200" style="stroke:Green;stroke-width:2"/&gt;&lt;/svg&gt; SVG圆形图案： 123&lt;svg id="svgCircleTutorial" height="250" xmlns="http://www.w3.org/2000/svg"&gt; &lt;circle id="myCircle" cx="55" cy="55" r="50" fill="#219E3E" stroke="#17301D" stroke-width="2" /&gt;&lt;/svg&gt; SVG矩形图案： 123&lt;svg id="svgRectangleTutorial" height="200" xmlns="http://www.w3.org/2000/svg"&gt; &lt;rect id="myRectangle" width="300" height="100" stroke="#17301D" stroke-width="2" fill="#0E4E75" fill-opacity="0.5" stroke-opacity="0.5"/&gt;&lt;/svg&gt; SVG椭圆图案： 123&lt;svg id="svgEllipseTutorial" height="150" xmlns="http://www.w3.org/2000/svg"&gt; &lt;ellipse id="myEllipse" cx="120" cy="60" rx="100" ry="50" style="fill:#3F5208;stroke:black;stroke-width:3"/&gt;&lt;/svg&gt; SVG多边形图案： 123&lt;svg id="svgPolygonTutorial" height="200" xmlns="http://www.w3.org/2000/svg"&gt; &lt;polygon id="myPolygon" points="10,10 75,150 150,60" style="fill:#63BCF7;stroke:black;stroke-width:3"/&gt;&lt;/svg&gt; &lt;canvas&gt;标签有一个基于JavaScript的绘图API，详见这里； HTML5 存储模式 session storage和local storage是HTML5新增的两种存储模式； cookie的缺陷： cookie大小限制在4KB以内； cookie随着http事务一起发送，浪费流量和带宽； 使用cookie不方便； cookie保存在本地硬盘中，不安全； session storage： 对应标签页，只要当前标签页不被关闭，则session storage不会消失； 一但标签页关闭，session storage的值随即清空； 可以用下面的方式加注session storage； 1sessionStorage.setItem("message", str) local storage： 保存在硬盘中，只要不手动清除，无论标签页和浏览器是否关闭都一直保存； 可以用下面的方式加注local storage; 1localStorage.setItem("message",str); cookie、session storage、local storage的区别和联系： cookie是由服务器端生成并发送给客户端的，其中的内容由服务器端决定； cookie只能保存少量数据（不超过4K）； 同源的网站cookie只存一份且共享（chrome中打开百度和firefox中打开百度用的是同一个cookie文件）； 不同源网站的cookie不能相互访问和读写（百度和谷歌两个网站的cookie不能相互访问）； session storage保存在浏览器缓存中，面向一次性的会话； local storage保存在本地磁盘中； session storage同源窗口不共享（不同的浏览器打开相同的网站不共享session storage）； local storage同源窗口共享（不同的浏览器打开相同的网站共享local storage）； session storage和local storage保存数据不超过5M； session storage和local storage只在本地保存，一定不会发送给服务器； HTML5 离线存储机制 离线存储（应用程序缓存）是 HTML5 的重要特性之一； 离线存储的作用是让应用程序可以获取本地的网站内容，在离线时也能实现正常访问网页； 离线存储的实现借助于 manifest 文件； 与传统浏览器缓存相比，离线存储不强制用户访问的网站内容被缓存； 如果您想详细了解离线存储机制，请看这篇文章； HTML5 提供的多种多样的API Media API Text Track API Application Cache API User Interaction Data Transfer API Command API Constraint Validation API History API]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>html</tag>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOCTYPE 标签详解]]></title>
    <url>%2F2015%2F12%2F06%2F2015-12-6-DOCTYPE%2F</url>
    <content type="text"><![CDATA[引言 DOCTYPE标签存在于html文档头部，我以前没有注意他，因为大多数情况下，我编写的都是html5文档，区区一行&lt;!DOCTYPE html&gt;确实没有引起我的重视； DOCTYPE标签规定了文档类型、文档模式等等，对于浏览器正确解析html文档具有重要作用； 本文分析了DOCTYPE标签的作用和常见形式； 文档类型 XML、HTML、XHTML、HTML5的关系如下： SGML（标准通用标记语言）是一个标准，告诉我们怎么去指定文档标记，他是只描述文档标记应该是怎么样的元语言； HTML是被用SGML描述的标记语言； HTML不够灵活，因此W3C开发了XML，XML用于对信息进行自我描述，XML支持自定义标签； XHTML是在HTML和XML之间的一种语言，是为了适应XML而重新改造的HTML； XHTML比HTML更加严格； HTML5不是基于SGML的，所以不需要引用 DTD； HTML5是最新的HTML标准，他的主要目标是提供所有内容而不需要任何的像flash，silverlight等的额外插件，这些内容来自动画，视频，富GUI等； DHTML是指Dynamic HTML，动态的HTML，DHTML意味着HTML、CSS和 JavaScript的组合； 为什么说XHTML比HTML更加严格： 在HTML中标签可以不严格嵌套、有时可省略结束标签、标签的大小写不作区分、属性值有时可以不加引号，这些在XHTML中均不允许； 几者的关系可用下图表示： DOCTYPE标签的作用 作用一：告诉浏览器这个文档是HTML、HTML5还是XHTML，即区分文档定义类型（DTD）； 作用二：告诉浏览器这个文档是过渡的(Transitional,要求非常宽松的DTD)还是严格的(Strict,要求严格的DTD)还是框架的(Frameset,专门针对框架页面设计使用的DTD)； 需要注意： 如果浏览器不能识别一个形式错误的doctype，就会强制进入Quirks模式； &lt;!DOCTYPE&gt;声明位于文档中的最前面的位置，处于标签之前； &lt;!DOCTYPE&gt;没有结束标签； &lt;!DOCTYPE&gt; 声明对大小写不敏感； DOCTYPE基本语法 语法如下： 1HTML 顶级元素 可用性 "注册//组织//类型 标签//定义 语言""URL"； 选项说明： 顶级元素：指定DTD中声明的顶级元素类型，这与声明的SGML文档类型相对应。 可用性：指定正式公开标识符(FPI)是可公开访问的对象还是系统资源。 PUBLIC为默认值，表示可公开访问的对象。 SYSTEM指系统资源，如本地文件或URL。 注册：指定组织是否由国际标准化组织(ISO)注册。 + 为默认值，表示组织名称已注册。 - 表示组织名称未注册。 组织：指定表明负责由 !DOCTYPE 声明引用的DTD的创建和维护的团体或组织的名称，即 OwnderID。 类型：指定公开文本类，即所引用的对象类型。 DTD为默认值。 标签：指定公开文本描述，即对所引用的公开文本的唯一描述性名称。后面可附带版本号。 HTML为默认值。 定义：指定文档类型定义。 Frameset为框架集文档。，Strict排除所有W3C专家希望逐步淘汰的代表性属性和元素，因为样式表已经很完善了，Transitional包含除frameSet元素的全部内容。 语言：指定公开文本语言，即用于创建所引用对象的自然语言编码系统。该语言定义已编写为 ISO 639 语言代码(大写两个字母)。 EN为默认值，表示英语。 URL：指定所引用对象的位置。 不同模式的例子 过渡的(Transitional):要求非常宽松的DTD(一般推荐使用这种) 1&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; 严格的(Strict):要求严格的DTD 1&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt; 框架的(Frameset):专门针对框架页面设计使用的DTD 1&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd"&gt; 常用的DOCTYPE声明 HTML5 1&lt;!DOCTYPE html&gt; HTML 4.01 Strict 1&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt; HTML 4.01 Transitional 12&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd"&gt; HTML 4.01 Frameset 12&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN""http://www.w3.org/TR/html4/frameset.dtd"&gt; XHTML 1.0 Strict 12&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt; XHTML 1.0 Transitional 12&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; XHTML 1.0 Frameset 12&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd"&gt; XHTML 1.1 1&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"&gt;]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css元素位置相关属性解析]]></title>
    <url>%2F2015%2F12%2F05%2F2015-12-5-css-position%2F</url>
    <content type="text"><![CDATA[元素浮动 clear属性 语法：clear : none|left|right|both none : 允许两边都可以有浮动对象 both : 不允许有浮动对象 left : 不允许左边有浮动对象 right : 不允许右边有浮动对象 float属性 语法：float : none|left|right none : 对象不浮动 left : 对象浮在左边 right : 对象浮在右边 使用场景 float和clear属性一般配合使用； 在需要文字环绕图片、段首大号文字环绕效果等情况下可使用float，请看下面的代码； 12345678910111213141516171819202122232425262728&lt;html&gt;&lt;head&gt;&lt;style type="text/css"&gt;span&#123; float:left; width:0.7em; font-size:400%; font-family:algerian,courier; line-height:80%;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;span&gt;T&lt;/span&gt;his is some text.This is some text. This is some text.This is some text. This is some text. This is some text.This is some text. This is some text. This is some text.This is some text. This is some text. This is some text.This is some text. This is some text. This is some text.This is some text. This is some text. This is some text.This is some text. This is some text. This is some text.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; float也可用于实现两栏布局（这种样式在bootstrap中很容易实现） 12345678910.main&#123; float: left; width: 600px;&#125;.sidebar&#123; float: right; width: 300px; margin-top: 1.875em;&#125; 元素定位（position属性） position属性的值： absolute：生成绝对定位的元素，相对于static定位以外的第一个父元素进行定位； fixed：生成绝对定位的元素，相对于浏览器窗口进行定位； relative：生成相对定位的元素，相对于其正常位置进行定位； static：默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）； inherit：规定应该从父元素继承position属性的值； position属性深入理解： relative是相对于元素本来应该在的位置进行定位，元素本来的位置会留出空白（保留元素本来位置）； absolute是相对于页面进行绝对位置定位，元素本来的位置不会留出空白（不保留元素本来的位置），直接让元素浮于整个页面，相对于整个页面进行定位，如果要设定元素之间的重叠关系可使用z-index属性； z-index属性一般结合position:absolute一起使用； z-index的默认值为0，z-index值越大，这个元素就越在顶层显示，通过设置各个元素的z-index值，控制他们的页面层叠关系； 如两个绝对定位对象的此属性具有同样的值，那么将依据它们在HTML文档中声明的顺序层叠； 元素居中显示的几种方法 使用margin属性（首选方法）： 将元素的margin-left和margin-right属性设置为auto即可，必须为该容器指定宽度； 本方法只适用于&gt;=IE6.0浏览器； 示例： 123&lt;div style="margin-left:auto; margin-right:auto; width:200px;"&gt; &lt;button&gt;按钮&lt;/button&gt;&lt;/div&gt; 123&lt;div style="margin:0 auto; width:200px;"&gt; &lt;button&gt;按钮&lt;/button&gt;&lt;/div&gt; 使用text-align属性 使用方法：style=&quot;text-align: left | center | right&quot; 这个属性一般用于文字，但也可以用于其他控件或元素； 用于非文字的控件或元素时，这个控件以及他所有的孩子全部居中，这是不太好的一点； 利用负外边距 首先创建一个包含居中元素的容器，然后将其绝对定位于相对页面左边边缘50%的位置； 这样，该容器的左外边距将从页面50%宽度的位置开始算起； 然后，将容器的左外边距值设置为负的容器宽度的一半，这样即可将该容器固定在页面水平方向的中点； 123456#container&#123; position: absolute; left: 50%; width: 760px; margin-left: -380px;&#125; 元素显示 display属性： visibility属性： 区别： display:none：元素不可见也不占用空间； visibility:hidden：元素不可见，但是占用空间，仍然会对页面布局产生影响； 使元素不可见还可以用opacity属性设置元素完全透明，即opacity: 0;，效果和visibility:hidden；完全相同；]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2015我的年度书单]]></title>
    <url>%2F2015%2F12%2F05%2F2015-12-5-year-books%2F</url>
    <content type="text"><![CDATA[引言 2015年即将过去了，回首这一年，陪伴我的不仅仅是一行一行的代码，不仅仅是前端的知识和页面，更有书香伴我行； 本文列出了我2015年的书单，虽然区区几本不算多，但是每本书我都认真阅读，深受启迪； 书是最好的老师，为我的成长之路指明方向，给我知识、给我力量、给我正能量！希望自己在2016年能读更多的书； 2015-我的书单 《自控力》 作者： [美] 凯利·麦格尼格尔 本书的作者是美国斯坦福大学备受赞誉的心理学家凯利·麦格尼格尔； 本书帮助人们管理压力、控制情绪； 本书促使人们思考自己、思考自己的生活，并且在生活中做出积极的改变； 本书从科学的角度揭示了成功的必要要素，揭示了自控力的本质，引导人们不要为了训练自控力而训练自控力，而应当用”小步快走”式的积极的改变影响自己和自己身边的人； 《社会心理学》 作者: [美] 戴维·迈尔斯 强烈建议每个人，无论您从事什么行业、什么职业，都应该读一读此书，此书绝不仅仅是一本简单的心理学教材，它会告诉您为什么人的心理有这样或是那样的想法或情绪，该如何应对，这将极大地提升您的心理健康水平和生活质量，是难得一见的好书！ 本书从科学的角度揭示了常见的心理学效应的本质，压力的本质，情绪的本质，攻击行为和偏见的本质，群体心理和从众心理的本质，态度、自责、自尊的本质等； 特别推荐本书关于群体心理的章节，它能够让您了解群体在作出决策时的心理反应、怎样避免群体决策的误区、怎样避免群体决策的失衡、怎样影响甚至改变群体决策的结果； 本书关于自我认识的章节（发展心理学）也值得推荐，让您科学的认识自我、倾听内心的声音，让您不再为人际关系、自我认知不到位、偏弱的自我意识等常见的心理问题所困扰，并且为您在自我接纳、自我悦纳方面提出可行的建议； 《为何家会伤人》 作者：[中] 武志红 本书重点讲述了”家”在一个人成长、成熟、发展中的重要意义，指出了家有时候也会带来烦恼和困惑，阅读了这本书后，我更加清楚了家的重要意义，以及如何避免家人之间的冲突和误解，让家真正成为心灵的港湾； 《大学之路》-吴军著 作者：吴军 相信很多人都读过这本书，本书的上下册我大约花了一个月左右看完，书中讲述的美国大学的历史、人文、教学、学生活动、大学文化等给我留下深刻印象； 吴军博士深入浅出的分析了美国大学教育为什么强，中国大学在教学、科研等方面存在的问题和差距； 美国各个大学不同但是很有特色的学校文化特别吸引我，如果有机会能去亲自体验一下就是再好不过的了； 《少有人走的路-心智成熟的旅程》 作者： [美] M·斯科特·派克 读完本书，最大的收获是一个人不断成长的法宝就是不断积极、主动的促进自己心智的成熟； 书中从正反两方面举例，让我明白了何为心智成熟、怎么是自己心智成熟、什么样的表现是心智不成熟的表现； 书中列举了一些自居成熟、一贯瞧不起他人、自认为什么都懂的人的外在表现和内心想法，一针见血的指出这些人其实非常自卑，自我放弃心智成熟的进程，作者为这些人感到深深的惋惜； 本书非常适合刚上大学的学生来阅读，我虽然上研了才读，但是也受益匪浅； 《感谢自己的不完美》 作者：[中] 武志红 本书特别适合那些和我一样，有完美主义倾向的人来阅读； 本书将会告诉您如何接纳自己、悦纳自己的优点或是缺点，指出人人都有对完美的追求，但是过度的不切实际的追求完美是不现实的； 本书深入浅出讲解了为什么要感谢自己的不完美，如何在不完美中实现突破和自我超越，从而在奋斗的同时体会到快乐、体会到幸福、并且真正明白人生的意义； 本书语言很优美，是非常文艺的一本书； 《恰到好处的幸福》 作者: [中] 毕淑敏 本书不是鸡汤、胜似鸡汤，用温暖的语言让您体会到幸福的含义； 幸福需要我们用心体会才能得到，如果一个人整天抱怨不停、犹犹豫豫、缺乏信心、自居高傲，那么他只会离内心中的幸福越来越远； 互联网时代，人人的压力都很大，如果您编代码变累了，不妨拿起此书翻一翻，让您的书香中放松，体会生活中小小的幸福； 《从0到1》 作者：[美] 彼得·蒂尔 / 布莱克·马斯特斯 这是我读的第一本真正的”商业”书籍，因为它从头到尾都在讲怎么赚钱； 网上对这本书褒贬不一，有人说这本书揭示了商业的秘密，指出了创新在企业发展中的重要价值，但也有人说本书只是停留在概念表面，并没有为创业者、特别是中小企业家指出成功之路； 我认为本书虽然有局限性，它对”从0到1”的商业模式的阐述不是非常清晰，但是如果您对彼得·蒂尔规划的商业蓝图感兴趣，还是值得一读的； 《组织行为学》 作者: [美] 斯蒂芬·P·罗宾斯 说实话，我没读懂这本书，感觉中间写的有些高深莫测； 本书的核心就是如何让组织运转更加高效，作为管理者如何让公司用有限的人力资源、产出尽可能高的业绩和成效； 本书虽然挺高深，但是却是美国组织行为学权威、圣迭戈大学管理学教授斯蒂芬·P·罗宾斯撰写的经典管理教科书，如果您对组织管理、组织运转感兴趣、又期待深入研究的话，非常推荐您详细阅读此书； 《竞争战略》 作者： [美] 迈克尔•波特 本书是迈克尔•波特竞争三部曲之一，具有划时代的价值和意义； 本书是我读过的最权威的、最全面的、最具有可操作性的企业级的竞争战略书籍，不过本书在概念层面上有一些抽象，并没有提出非常具体的竞争战略，但是，从战略层面考虑问题本来就不是具体的，总体来看，本书的作者具有非凡的战略眼光和魄力，在引领企业发展、促使企业创新、完善企业管理、加快产业融合等方面观点独具一格； 本书详细剖析了零散型产业、新兴产业、成熟产业、衰退产业和全球性产业中的竞争战略，非常全面； 本书的作者迈克尔•波特毕业于普林斯顿大学，后获哈佛大学商学院企业经济学博士学位，是当今世界上竞争战略和竞争力方面公认的第一权威； 如果您对企业市场竞争感兴趣，强烈推荐您阅读此书； 《策略与博弈》 作者： [美] 普拉伊特・K.杜塔 说实话，本书的概念我感觉十分晦涩难懂，但是还是坚持看完了； 本书介绍了博弈论的相关知识，最大特点就是：严谨、例子多； 本书完整描述和展示了效用理论、动态博弈论、动态策略相互作用； 阅读本书需要有一定的数学基础和逻辑推理能力； 对博弈论和决策效用理论感兴趣的童鞋可以阅读此书，我还是很推荐哒； 《基辛格-美国的全球战略》 作者：[美] 亨利·基辛格 本书作者亨利·基辛格是美国著名外交家、国际问题专家，美国前国务卿，1971年7月，基辛格作为尼克松总统特使访华，为中美关系大门的开启作出了历史性贡献； 本书是基辛格亲自所著，从多个角度全面分析了中美关系，本书中充满精准的判断，偶然显现的深刻洞悉力令读者阅后扼腕称赞； 基辛格是美国前国务卿，他对于美国和中国无论是在战略还是战术层面都非常了解，虽然在某些地方我不同意他的看法，但是书中他对于中美关系发展的总体把握和判断对于当今世界、当今的中美关系都非常有借鉴意义； 如果您期望了解美国人眼中的中国，特别是美国政客眼中的中国，推荐阅读本书； 《亚太战略变局与中美新型大国关系》 作者： [中] 孙哲 本书作者孙哲是清华大学国际问题研究所教授、博士生导师，主要从事政治学理论、国际关系及美国政治与外交方面的研究工作； 何谓“新型大国关系”？按照中方的说法，它是以相互尊重、互利共赢的合作伙伴关系为核心特征的；按照美方的说法，它是对“崛起国与守成国必然冲突”这一历史魔咒的打破，是以“新答案”解决“老问题”； 尽管双方并未使用相同的概念，两国学术界尚未对其进行系统的理论阐释，双方对其理解和期待也不尽相同，但双方业内已存在的基本共识在于：21世纪的中美关系必须避免大国对抗和零和博弈的历史覆辙，切实走出一条新路； 本书基于”新型大国关系”这个全新理念，系统性的阐释了亚太战略变局对于新型大国关系的影响； 亚太地区一直是中美双方都非常关注的热点地区，亚太的和平稳定符合中美双方共同利益和需求，如果您对于亚太地区和中美关系走向感兴趣，推荐阅读此书；]]></content>
      <tags>
        <tag>books</tag>
        <tag>feeling</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中如何实现发邮件功能]]></title>
    <url>%2F2015%2F12%2F03%2F2015-12-3-java-mail%2F</url>
    <content type="text"><![CDATA[需求描述 实验室的资源表管理系统需要这样一种功能：当资源表更改时自动给管理员发邮件； 由于后台是用java写的，所以需要用java实现自动发邮件的功能； 本文参考这里 实现过程 下载jar包并导入工程，在这里下载； 如果您使用的是maven工程，请在这里搜索jar包，包名称为commons-email,选择最新版本的jar包，将其groupId、artifactId、version等信息填入maven工程的导入jar包界面，点击导入即可； 不要忘记在pom.xml中加入jar包的配置信息(我使用的netbeans会自动添加)： 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-email&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt; 下面的代码即可实现发邮件的功能 12345678910111213141516171819202122package resourcestore.applycontent;import org.apache.commons.mail.DefaultAuthenticator;import org.apache.commons.mail.Email;import org.apache.commons.mail.EmailException;import org.apache.commons.mail.SimpleEmail;public class SendMail &#123; public static void send() throws EmailException &#123; Email email = new SimpleEmail(); email.setHostName("10.106.128.254"); //邮件服务器ip地址 email.setSmtpPort(465); //邮件服务器接收邮件的端口号 email.setAuthenticator(new DefaultAuthenticator("name", "password")); //登录邮件服务器的用户名密码 email.setSSLOnConnect(true); email.setFrom("...@..."); //发送地址 email.setSubject("TestMail"); //邮件主题 email.setMsg("This is a test mail ... :-)"); //邮件内容 email.addTo("...@..."); //目的地址 email.send(); //发送邮件 &#125;&#125; 上面只是实现了最简单的邮件发送功能，如果需要更加复杂的、带有附件的、发送html邮件等，请看这里；]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>mail</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaEE中如何获取JSON格式的数据]]></title>
    <url>%2F2015%2F12%2F01%2F2015-12-1-javaEE-JSON%2F</url>
    <content type="text"><![CDATA[问题描述 在web开发时，如果您后台用的是javaEE，经常需要将数据转换成JSON格式，以便序列化后返回给客户端； javaEE内部能够自己将list转为JSON格式，比如下面的程序，从数据库取得数据后放在list中，在return这个list的时候javaEE内部将list转为JSON格式并序列化，作为http请求实体返回给客户端； 1234567public List&lt;ApplyInfo&gt; getCurrentApply(int resourceId)&#123; List&lt;ApplyInfo&gt; list = em.createQuery("select a from ApplyInfo a " + "where a.resourceId=:resourceId and a.isPassed=0") .setParameter("resourceId", resourceId) .getResultList(); return list; &#125; 但是在javaEE升级后，这样的内部转JSON的机制貌似失效了（具体原因尚不清楚）； 导致服务器成功取得了数据，但是客户端获取不了数据，报500错误； 解决方案 推荐一款轻量级的快速将数据转换为JSON格式的工具–fastjson，请看这里； 它使用起来非常方便，先在工程中引入这个包： 1import com.alibaba.fastjson.JSON; 如果您的工程的maven工程，直接search这个包即可，添加后在pom.xml中即可看到包已经被引入： 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.1.41&lt;/version&gt;&lt;/dependency&gt; 直接调用JSON对象的toJSONString方法，就可将list转为JSON格式的String，然后我们手动构建http响应报文的实体： 12345678910@GET@Path("userInfo")@Produces(&#123;"application/json"&#125;)public Response getUserInfo() &#123; Query query = em.createQuery("select a.id , a.name from AuthUser a"); List&lt;AuthUser&gt; userInfo = query.getResultList(); System.out.println(userInfo.size()); String u = JSON.toJSONString(userInfo); return Response.status(200).entity(u).build();&#125; 访问我们写的API，看到数据成功被返回客户端；]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>javaEE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用selenium实现轮播]]></title>
    <url>%2F2015%2F11%2F25%2Fselenium-rollplay%2F</url>
    <content type="text"><![CDATA[需求定义 公司需要对外展示若干web页面，需要一种能够自动在屏幕上循环播放这些web页面的功能； web页面上的按钮和各种功能点也要能够自动点击和展示； 现在有三种方案：用js实现、用制作视频的方式实现、用录屏的方式实现； 第一种方案理论上可以实现，但是如果一个页面上的功能点过多，编写js代码就显得非常繁杂，而且一旦页面的元素、控件等有所改动就需要修改代码； 第二种方案可能会存在视频不清晰、分辨率不高的缺点，同样，一旦系统有所变化，就需要重新录制，比较麻烦； 第三种方案也没有能够避免第二种方案的缺陷； 经过认真上网查询，我最终选择了用selenium来完成这件事； 为什么是selenium selenium原本是一种网页自动化测试工具，可以实现自动测试网页功能和性能； 这里，我们只用它的”网页动作”录制的功能来实现轮播效果； selenium和selenium IDE均可直接安装在firefox上面，非常方便； selenium支持多种浏览器播放录制的网页动作，官网上面可下载所需的浏览器驱动，浏览器支持性较强； selenium支持各种常用语言，比如java、javascript（需要安装node）、C#、Python、Ruby，让你用最擅长的语言随心所欲操控网页； 以java语言为例，selenium最终的录制脚本可以导出成jar包，无论是linux还是windows，只要机器上安装了java，你就可以运行jar包、开启轮播，没有比这更方便的啦！ 下面，我就带您用selenium一步一步实现轮播； 下载Selenium 下载selenium插件 目前，只有firefox支持selenium插件，不知道以后会不会跨浏览器支持； 打开firefox，搜索插件selenium，安装插件； 安装完后，可以看到firefox的功能列表中已经多了selenium啦！ 但此时启动selenium还不能够使用，这是因为我们尚未安装selenium IDE； 安装Selenium IDE 用firefox打开selenium官网，下载selenium IDE：点击这里下载； selenium IDE将直接以插件形式安装在firefox上面； Selenium IDE使用 使用Selenium IDE来录制网页动作的方法十分简单，打开selenium后，点击红色的圆点即可开始录制，再次点击即停止录制，点击run按钮可以以设定好的速率播放相应脚本的动作，还能够将另存为脚本或者将脚本导出成为java/Ruby/Python等； 如果需要查询更复杂的功能，请看这里 实现轮播 确保您的机器安装了java； 打开eclipse，新建一个工程； 在这里的Selenium Standalone Server一栏下载selenium依赖jar包，我下载的是selenium-server-standalone-2.48.2.jar； 将上述jar包导入eclipse新建的工程中，注意不要仅仅是复制进eclipse呦，还需要在工程右键build path&gt;library&gt;add jars将jar包真正添加进工程中； 然后，我们就可以开始录制脚本啦； 打开Selenium插件，点击红色圆形按钮开始录制； 在浏览器操作一遍需要录制的动作，比如进入URL、点击按钮、选择下拉菜单等等； 注意在录制前将所需的用户名和密码填写好并保存，否则在录制过程中还要填写用户名密码，这样会使得轮播的展示效果变差； 录制完后，点击文件&gt;export test case as java/JUnit4/webDriver，将脚本导出为JUnit； 然后我们就该处理脚本了： 将脚本复制进ecplise中； 如果您使用的不是firefox来进行轮播，则将driver = new FirefoxDriver();改为driver = new ChromeDriver();就可以来，注意要引入外部包； 可以加入诸如for循环或者while(true)之类的语句，保证脚本可以自动无限次循环播放； 可以加入诸如Thread.sleep(3000);的语句来实现每个动作之间的时间驻留； 对于具体的网页动作，也可根据代码进行必要的修改； 需要注意的是，如果您使用的不是firefox来进行轮播，那么还需要下载您使用的浏览器的驱动才行，否则Selenium在启动浏览器时找不到相应的驱动会报错，各大浏览器的驱动在这里下载，linux版本的chrome驱动请在这里下载，chrome驱动版本和chrome版本的对应关系在这里查询； 下载完驱动后，您还需要在程序中指明驱动存放位置，即添加下述代码： 1System.setProperty("webdriver.chrome.driver", "D:\\chromedriver_win32\\chromedriver.exe"); 脚本录制大功告成，下面我们可以试着播放脚本，看看效果如何： 将上面工程导出为jar包； 用java -jar jar包名称运行jar包； 此时，Selenium将自动为您开启浏览器，并播放刚才录制的网页动作，是不是非常方便！ 需要注意的是，在linux上面运行脚本，需要对chrome驱动赋予执行权限： 1chmod +x chromedriver 进一步优化 实现了录制和播放脚本还不够，我们要让整个轮播的过程更加优雅！ 可以添加下面的代码，实现浏览器自动全屏播放，是不是很炫！ 1234// full screen automaticChormeOptions options = new ChormeOptions();options.addArguments("kiosk");driver = new ChromeDriver(options); 如果您用的是windows系统，可直接将运行jar包的命令放在.bat文件中，这样如果有人来公司参观，直接双击.bat文件就能够实现轮播了，相当方便； 如果您用的是linux系统，可以写一个shell脚本实现上述功能： 123#!/bin/shcd /home/haohan/Desktop/looping_play/java -jar /home/haohan/Desktop/looping_play/looping_play_linux64_2015.6.30.jar &amp; 您还可以写一个.desktop文件，即桌面图标文件，链接到上面的shell脚本，这样双击桌面图标就能开启轮播功能！ 1234567891011#!/usr/bin/env xdg-open[Desktop Entry]Version=1.0Name=IdeaExec=looping_play/looping_play.shTerminal=falseIcon=looping_play/looping_play_pic.jpgType=ApplicationCategories=Development;Name[en_US]=LoopingPlay 现在我们完整的实现了整个轮播效果，我准备把它部署在公司门口的显示屏上，让每一个路过的人都能看到公司的产品展示！]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>selenium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[glassfish 数据库连接报错的解决]]></title>
    <url>%2F2015%2F11%2F24%2Fglassfish-error%2F</url>
    <content type="text"><![CDATA[引言 最近实验室有人来参观，由于集群重装了，需要重新部署各个应用； 在部署过程中发现数据库连接失败的问题，加以总结； 问题描述 glassfish报错： 1Invalid resource : traffic__pm 解决方法： 根据错误提示，应该是persistence manager出错了 应当运行数据库注册信息，即相关resource的xml文件 运行后，将数据库添加到glassfish注册信息中，删除原来部署失败的war包，重启glassfish后添加新的war包即可部署成功 1/opt/glassfish4/glassfish/bin/asadmin add-resources glassfish-resources.xml 如果问题还未得到解决，那说明resource配置信息出了问题，需要检查glassfish-resources.xml中的jndi-name和persistence.xml中的&lt;jta-data-source&gt;是否相同；]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>glassfish</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 原型和原型链的理解]]></title>
    <url>%2F2015%2F11%2F23%2Fjs-prototype%2F</url>
    <content type="text"><![CDATA[引言 原型和原型链是js中比较重要但也是比较难的内容； 正是因为有了原型链的概念，js中的继承才成为可能； 本文结合js内置的数据类型，说说我对js原型和原型链的理解； Javascript和Java语言设计思想的区别 java java是完全OOP的语言，对Java的认知是从类与对象开始的； class是一类具有共同特点的物体的抽象，object（对象）是某个class下具体的一个实现，Object类是所有类的顶层父类； js javascript是基于原型（而不是基于类的，尽管ES6新增了class关键字）的面向对象的语言，没有类的概念（ES6新增的类是语法糖）； javascript中的class本质上是一个函数对象，和java中的类的概念有本质区别； javascript存在类似面相对象的特性，这就是原型和原型链，从而派生出了类似于父类子类和继承的概念； 本图来自这里 对象和数据类型 js中的数据类型: 数据类型：string、number、boolean、object（数组、对象、null）、undefined、function； 数组、对象、null是不精确的数据类型，在用typeof判断时均返回object； typeof关键字只能返回非精确的数据类型； 用Object.prototype.toString判断精确的数据类型； 首字母大小写的区别： 小写（string、number、boolean、object、null、undefined、function）表示数据类型； 大写（String、Number、Boolean、Object、Array）表示js的内置对象（全部是function类型）； js中对象的含义： 广义的对象（js一切皆为对象、包括window和document对象、也包括String、Number、Boolean、Object、Array、Math、Date等内置对象）； 狭义的数据类型（数组、对象、null类型均为object，即被typeof关键字判断为object类型）; “对象”这种数据类型（请参考我的另一篇博客）； 原型链概述 JavaScript中的每个对象都有一个内部的链接指向另一个对象，这个对象就是原对象的原型，这个原型对象也有自己的原型，直到对象的原型为 null 为止（也就是没有原型）； 这种一级一级的链结构就称为原型链（prototype chain）； 每个对象都有一个隐形的属性proto（两边都是双下划线），这个属性的值为一个地址，指向这个属性的原型对象，原型对象是每个对象都有指向的隐形对象； new出来的普通对象没有构造器，就没有prototype属性； proto属性也可用someObject.[[Prototype]] 表示； 如果一个对象是object类型，它的proto属性总是指向Object.prototype； 如果一个对象是function类型，它的proto属性总是指向Function.prototype； 继承属性：JavaScritp引擎在访问对象的属性时，如果在对象本身中没有找到，则会去原型链中查找，如果找到，直接返回值，如果整个链都遍历且没有找到属性，则返回undefined； 各种对象原型链的图示 String对象的原型链 12345678910111213141516171819202122 var s = "sss";var s1 = new String();console.log(typeof String); //functionconsole.log(typeof String.prototype); //objectconsole.log(typeof String.prototype.constructor); //functionconsole.log(typeof String.prototype.__proto__); //objectconsole.log(typeof String.__proto__); //functionconsole.log(typeof s1); //objectconsole.log(typeof s); //stringconsole.log(typeof s1.__proto__); //objectconsole.log(typeof s.__proto__); //objectconsole.log(String.prototype.constructor); // function String()&#123;...&#125;console.log(String.prototype.__proto__); //Object &#123;&#125;console.log(String.__proto__); //function()&#123;&#125;console.log(String.__proto__ == Function.prototype); //trueconsole.log(String.prototype.constructor.__proto__ == Function.prototype); //trueconsole.log(String.prototype.__proto__ == Object.prototype); //trueconsole.log(s1); //String &#123;&#125;console.log(s1.__proto__); //String &#123;...&#125;console.log(s); //sssconsole.log(s.__proto__); //String &#123;...&#125; Number对象的原型链 12345678910111213141516171819202122 var n = 1;var n1 = new Number();console.log(typeof Number); //functionconsole.log(typeof Number.prototype); //objectconsole.log(typeof Number.prototype.constructor); //functionconsole.log(typeof Number.prototype.__proto__); //objectconsole.log(typeof Number.__proto__); //functionconsole.log(typeof n1); //objectconsole.log(typeof n); //numberconsole.log(typeof n1.__proto__); //objectconsole.log(typeof n.__proto__); //objectconsole.log(Number.prototype.constructor); // function Number()&#123;...&#125;console.log(Number.prototype.__proto__); //Object &#123;&#125;console.log(Number.__proto__); //function()&#123;&#125;console.log(Number.__proto__ == Function.prototype); //trueconsole.log(Number.prototype.constructor.__proto__ == Function.prototype); //trueconsole.log(Number.prototype.__proto__ == Object.prototype); //trueconsole.log(n1); //Number &#123;&#125;console.log(n1.__proto__); //Number &#123;...&#125;console.log(n); //1console.log(n.__proto__); //Number &#123;...&#125; Boolean对象的原型链 12345678910111213141516171819202122 var b = true;var b1 = new Boolean();console.log(typeof Boolean); //functionconsole.log(typeof Boolean.prototype); //objectconsole.log(typeof Boolean.prototype.constructor); //functionconsole.log(typeof Boolean.prototype.__proto__); //objectconsole.log(typeof Boolean.__proto__); //functionconsole.log(typeof b1); //objectconsole.log(typeof b); //booleanconsole.log(typeof b1.__proto__); //objectconsole.log(typeof b.__proto__); //objectconsole.log(Boolean.prototype.constructor); // function Boolean()&#123;...&#125;console.log(Boolean.prototype.__proto__); //Object &#123;&#125;console.log(Boolean.__proto__); //function()&#123;&#125;console.log(Boolean.__proto__ == Function.prototype); //trueconsole.log(Boolean.prototype.constructor.__proto__ == Function.prototype); //trueconsole.log(Boolean.prototype.__proto__ == Object.prototype); //trueconsole.log(b1); //Boolean &#123;&#125;console.log(b1.__proto__); //Boolean &#123;...&#125;console.log(b); //trueconsole.log(b.__proto__); //Boolean &#123;...&#125; Array对象的原型链 12345678910111213141516171819202122 var a =[1,2,3];var a1 = new Array(); console.log(typeof Array); //functionconsole.log(typeof Array.prototype); //objectconsole.log(typeof Array.prototype.constructor); //functionconsole.log(typeof Array.prototype.__proto__); //objectconsole.log(typeof Array.__proto__); //functionconsole.log(typeof a1); //objectconsole.log(typeof a); //objectconsole.log(typeof a1.__proto__); //objectconsole.log(typeof a.__proto__); //objectconsole.log(Array.prototype.constructor); // function Array()&#123;...&#125;console.log(Array.prototype.__proto__); //Object &#123;&#125;console.log(Array.__proto__); //function()&#123;&#125;console.log(Array.__proto__ == Function.prototype); //trueconsole.log(Array.prototype.constructor.__proto__ == Function.prototype); //trueconsole.log(Array.prototype.__proto__ == Object.prototype); //trueconsole.log(a1); //[]console.log(a1.__proto__); //包含Array的各种方法console.log(a); //[1,2,3]console.log(a.__proto__); //包含Array的各种方法 Function对象的原型链 12345678910111213141516171819202122 var f = function()&#123;&#125;;var f1 = new Function(); console.log(typeof Function); //functionconsole.log(typeof Function.prototype); //functionconsole.log(typeof Function.prototype.constructor); //functionconsole.log(typeof Function.prototype.__proto__); //objectconsole.log(typeof Function.__proto__); //functionconsole.log(typeof f1); //functionconsole.log(typeof f); //functionconsole.log(typeof f1.__proto__); //functionconsole.log(typeof f.__proto__); //functionconsole.log(Function.prototype.constructor); // function Function()&#123;...&#125;console.log(Function.prototype.__proto__); //Object &#123;&#125;console.log(Function.__proto__); //function()&#123;&#125;console.log(Function.__proto__ == Function.prototype); //trueconsole.log(Function.prototype.constructor.__proto__ == Function.prototype); //trueconsole.log(Function.prototype.__proto__ == Object.prototype); //trueconsole.log(f1); //function anonymous()&#123;&#125;console.log(f1.__proto__); //function()&#123;&#125;console.log(f); //function()&#123;&#125;console.log(f.__proto__); //function()&#123;&#125; Object对象的原型链 12345678910111213141516171819202122 var o = &#123;&#125;;var o1 = new Object(); console.log(typeof Object); //functionconsole.log(typeof Object.prototype); //objectconsole.log(typeof Object.prototype.constructor); //functionconsole.log(typeof Object.prototype.__proto__); //objectconsole.log(typeof Object.__proto__); //functionconsole.log(typeof o1); //objectconsole.log(typeof o); //objectconsole.log(typeof o1.__proto__); //objectconsole.log(typeof o.__proto__); //objectconsole.log(Object.prototype.constructor); // function Object()&#123;...&#125;console.log(Object.prototype.__proto__); //nullconsole.log(Object.__proto__); //function()&#123;&#125;console.log(Object.__proto__ == Function.prototype); //trueconsole.log(Object.prototype.constructor.__proto__ == Function.prototype); //trueconsole.log(Object.prototype.__proto__ == null); //trueconsole.log(o1); //Object&#123;&#125;console.log(o1.__proto__); //Object&#123;...&#125;console.log(o); //Object&#123;&#125;console.log(o.__proto__); //Object&#123;...&#125; 自定义对象的原型链 123456789101112131415161718192021222324252627 function Person(name,age)&#123; this.name = name; this.age = age;&#125;var p1 = new Person("Jack",22);var p = &#123;"Jack":22&#125;;console.log(typeof Person); //functionconsole.log(typeof Person.prototype); //objectconsole.log(typeof Person.prototype.constructor); //functionconsole.log(typeof Person.prototype.__proto__); //objectconsole.log(typeof Person.__proto__); //functionconsole.log(typeof p1); //objectconsole.log(typeof p); //objectconsole.log(typeof p1.__proto__); //objectconsole.log(typeof p.__proto__); //objectconsole.log(Person.prototype.constructor); // function Person()&#123;...&#125;console.log(Person.prototype.__proto__); //Object &#123;&#125;console.log(Person.__proto__); //function()&#123;&#125;console.log(Person.__proto__ == Function.prototype); //trueconsole.log(Person.prototype.constructor.__proto__ == Function.prototype); //trueconsole.log(Person.prototype.__proto__ == Object.prototype); //trueconsole.log(p1); //Person &#123;name: "Jack", age: 22&#125;console.log(p1.__proto__); //Person&#123;...&#125;console.log(p); //Object &#123;Jack: 22&#125;console.log(p.__proto__); //Object&#123;...&#125; 最后附上一张知乎上面大神画的图，清楚地表示了Object和Function的继承关系]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 对象详解]]></title>
    <url>%2F2015%2F11%2F20%2Fjs-object%2F</url>
    <content type="text"><![CDATA[创建对象 使用对象初始化器来创建对象 12var obj = &#123;key_1:value_1, key_2:value_2,...&#125; 1var myObj = &#123;color: red, wheels:4, engine:&#123;cylinders: 4, size: 2.2&#125;&#125; 使用Object.create()方法创建对象 语法是(属性描述符会在下面讲解)： 1Object.create(proto, [ propertiesObject ]) 123456789o = Object.create(Object.prototype, &#123; // foo会成为所创建对象的数据属性 foo: &#123; writable:true, configurable:true, value: "hello" &#125;, // bar会成为所创建对象的访问器属性 bar: &#123; configurable: false, get: function() &#123; return 10 &#125;, set: function(value) &#123; console.log("Setting `o.bar` to", value) &#125;&#125;&#125;) 混合构造函数和原型方式创建对象 1234567891011function Parent()&#123; this.name = "Jack"; this.age = 22;&#125;Parent.prototype.lev = function()&#123; return this.name;&#125;var x = new Parent();alert(x.lev()); //Jack 对象属性的遍历 遍历属性 1234var obj = &#123;prop1: 4, prop2: 5, prop3: 6&#125;;for(var i in obj)&#123; console.log(i); //prop1 prop2 prop3&#125; 遍历属性值 1234var obj = &#123;prop1: 4, prop2: 5, prop3: 6&#125;;for(var i in obj)&#123; console.log(obj[i]); //4 5 6&#125; 对象常用操作 对象的访问 obj.name和obj[“name”]效果一样； 获取key值组成的数组 1var arr = Object.keys(obj); 删除对象或属性 123delete objectName;delete objectName.prop;delete prop; //仅仅在with语句中可以使用 getter和setter getter和setter是对象属性的属性描述符的一种，可以在定义对象属性的时候指明； getter和setter用于获取或者修改对象的某个属性； 通过对象初始化器在创建对象的时候指明： 1234567891011(function () &#123; var o = &#123; a : 7, get b()&#123;return this.a +1;&#125;, //通过 get,set的 b,c方法间接性修改a属性 set c(x)&#123;this.a = x/2&#125; &#125;; console.log(o.a); //7 console.log(o.b); //8 o.c = 50; console.log(o.a); //25&#125;)(); 使用 Object.create 方法指定： 123456789101112131415161718192021(function () &#123; var o = null; o = Object.create(Object.prototype,//指定原型为 Object.prototype &#123; bar:&#123; get :function()&#123; return this.a; &#125;, set : function (val) &#123; console.log("Setting `o.bar` to ",val); this.a = val; &#125;, configurable :true &#125; &#125; //第二个参数 ); o.a = 10; console.log(o.bar); //10 o.bar = 12; console.log(o.bar); //12&#125;)(); 使用 Object.defineProperty 方法指定： Object.defineProperty() 方法直接在一个对象上定义一个新属性，或者修改一个已经存在的属性，并返回这个对象; 语法：Object.defineProperty(obj, prop, descriptor) 参数：obj 需要定义属性的对象；prop 需被定义或修改的属性名；descriptor 需被定义或修改的属性的描述符； 12345678910111213141516(function () &#123; var o = &#123; a : 1&#125; //声明一个对象,包含一个 a 属性,值为1 Object.defineProperty(o,"b",&#123; get: function () &#123; return this.a; &#125;, set : function (val) &#123; this.a = val; &#125;, configurable : true &#125;); console.log(o.b); o.b = 2; console.log(o.b);&#125;)(); 使用 Object.defineProperties方法指定： 概述：Object.defineProperties() 方法在一个对象上添加或修改一个或者多个自有属性，并返回该对象; 语法：Object.defineProperties(obj, props) 参数：obj 将要被添加属性或修改属性的对象；props 该对象的一个或多个键值对定义了将要为对象添加或修改的属性的具体配置； 用法与 Object.defineProperty 方法类似； 1234567891011121314151617181920(function () &#123; var obj = &#123;a:1,b:"string"&#125;; Object.defineProperties(obj,&#123; "A":&#123; get:function()&#123;return this.a+1;&#125;, set:function(val)&#123;this.a = val;&#125; &#125;, "B":&#123; get:function()&#123;return this.b+2;&#125;, set:function(val)&#123;this.b = val&#125; &#125; &#125;); console.log(obj.A); console.log(obj.B); obj.A = 3; obj.B = "hello"; console.log(obj.A); console.log(obj.B);&#125;)(); 使用 Object.prototype.defineGetter以及 Object.prototype.defineSetter方法指定： 123456789101112(function () &#123; var o = &#123;a:1&#125;; o.__defineGetter__("giveMeA", function () &#123; return this.a; &#125;); o.__defineSetter__("setMeNew", function (val) &#123; this.a = val; &#125;) console.log(o.giveMeA); //1 o.setMeNew = 2; console.log(o.giveMeA); //2&#125;)(); 属性描述符 说明： 对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。 数据描述符是一个拥有可写或不可写值的属性。 存取描述符是由一对 getter-setter 函数功能来描述的属性。 描述符必须是两种形式之一；不能同时是两者。 数据描述符和存取描述符均具有以下可选键值： 1234configurable 当且仅当这个属性描述符值为 true 时，该属性可能会改变，也可能会被从相应的对象删除。默认为 false。enumerable true 当且仅当该属性出现在相应的对象枚举属性中。默认为 false。 数据描述符同时具有以下可选键值： 1234value 与属性相关的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。writable true 当且仅当可能用 赋值运算符 改变与属性相关的值。默认为 false。 存取描述符同时具有以下可选键值： 1234get 一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。方法将返回用作属性的值。默认为 undefined。set 一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。该方法将收到作为唯一参数的新值分配给属性。默认为 undefined。 上面键值的含义： 数据描述符包括两个属性 : value 属性以及 writable属性，第一个属性用来声明当前欲修饰的属性的值，第二个属性用来声明当前对象是否可写即是否可以修改； 存取描述符就包括 get 与 set 属性用来声明欲修饰的象属性的 getter 及 setter； 属性描述符内部，数据描述符与存取描述符只能存在其中之一，但是不论使用哪个描述符都可以同时设置 configurable 属性以及enumerable 属性； configurable属性用来声明欲修饰的属性是否能够配置，仅有当其值为 true 时，被修饰的属性才有可能能够被删除，或者重新配置； enumerable 属性用来声明欲修饰属性是否可以被枚举，决定属性是否能被 for…in 循环或 Object.keys 方法遍历得到； create方法为显示配置对象的属性和值，如不声明将按照属性描述符的默认值： 12345678910111213141516171819(function () &#123; var obj = &#123;&#125;; Object.defineProperty(obj,"key",&#123; value:"static" //没有设置 enumerable 使用默认值 false //没有 configurable 使用默认值 false //没有 writable 使用默认值 false &#125;); console.log(obj.key); // static obj.key = "new" //尝试修改其值,修改将失败,因为 writable 为 false console.log(obj.key); // static delete obj.key; //尝试删除属性,失败,因为 configurable 使用默认值 false console.log(obj.key); // static obj.a = 1; //动态添加一个属性 for(var item in obj)&#123; //遍历所有 obj 的可枚举属性 console.log(item); &#125; //只输出一个 “a” 因为 “key”的 enumerable为 false&#125;)(); defineProperty、defineProperties方法为显示配置对象的属性和值，如不声明将按照属性描述符的默认值： 12345678910111213141516171819(function () &#123; var obj = &#123;&#125;; Object.defineProperty(obj,"key",&#123; value : "static" //没有设置 enumerable 使用默认值 false //没有 configurable 使用默认值 false //没有 writable 使用默认值 false &#125;) console.log(obj.key); // static obj.key = "new" //尝试修改其值,修改将失败,因为 writable 为 false console.log(obj.key); // static delete obj.key; //尝试删除属性,失败,因为 configurable 使用默认值 false console.log(obj.key); // static obj.a = 1; //动态添加一个属性 for(var item in obj)&#123; //遍历所有 obj 的可枚举属性 console.log(item); &#125; //只输出一个 “a” 因为 “key”的 enumerable为 false&#125;)(); var o = {}; o.a = 1;这个语句却和上面不同，它的等价配置如下： 12345678910111213141516(function () &#123; var o = &#123;&#125;; o.a = 1; //等价于 Object.defineProperty(o,"a",&#123;value : 1, writable : true, configurable : true, enumerable : true&#125;); Object.defineProperty(o,"a",&#123;value :1&#125;); //等价于 Object.defineProperty(o,"a",&#123;value : 1, writable : false, configurable : false, enumerable : false&#125;);&#125;)(); Enumerable属性专项研究： 属性特性 enumerable 决定属性是否能被 for…in 循环或 Object.keys 方法遍历得到； 123456789101112131415161718(function () &#123; var o = &#123;&#125;; Object.defineProperty(o,"a",&#123;value :1,enumerable :true&#125;); Object.defineProperty(o,"b",&#123;value :2,enumerable :false&#125;); Object.defineProperty(o,"c",&#123;value :2&#125;); //enumerable default to false o.d = 4; //如果直接赋值的方式创建对象的属性,则这个属性的 enumerable 为 true for(var item in o)&#123; //遍历所有可枚举属性包括继承的属性 console.log(item); //a d &#125; console.log(Object.keys(o)); //输出["a","d"],获取o对象的所有可遍历属性不包括继承的属性 console.log(o.propertyIsEnumerable('a')); //true console.log(o.propertyIsEnumerable('b')); //false console.log(o.propertyIsEnumerable('c')); //false console.log(o.propertyIsEnumerable('d')); //true&#125;)(); Configurable属性专项研究： Configurable属性如果为false，表示对象的Configurable、Enumerable、value、writable、set、get属性一旦确定（包含默认确定的）就不能再更改，对象的这个属性也不能被删除； 12345678910111213141516171819202122232425(function () &#123; var o = &#123;&#125;; Object.defineProperty(o,"a",&#123;get: function () &#123;return 1;&#125;, configurable : false&#125; ); //enumerable 默认为 false, //value 默认为 undefined, //writable 默认为 false, //set 默认为 undefined //抛出异常,因为最开始定义了 configurable 为 false,故后期无法对其进行再配置 Object.defineProperty(o,"a",&#123;configurable : true&#125; ); //抛出异常,因为最开始定义了 configurable 为 false,故后期无法对其进行再配置,enumerable 的原值为 false Object.defineProperty(o,"a",&#123;enumerable : true&#125; ); //抛出异常,因为最开始定义了 configurable 为 false,set的原值为 undefined Object.defineProperty(o,"a",&#123;set : function(val)&#123;&#125;&#125; ); //抛出异常,因为最开始定义了 configurable 为 false,故无法进行覆盖,尽管想用一样的来覆盖 Object.defineProperty(o,"a",&#123;get : function()&#123;return 1&#125;&#125;); //抛出异常，因为最开始定义了 configurable 为 false,故无法将其进行重新配置把属性描述符从存取描述符改为数据描述符 Object.defineProperty(o,"a",&#123;value : 12&#125;); console.log(o.a);//输出1 delete o.a; //想要删除属性,将失败 console.log(o.a);//输出1 &#125;)();]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript var关键字详解]]></title>
    <url>%2F2015%2F11%2F11%2Fjs-var%2F</url>
    <content type="text"><![CDATA[关于var关键字需要知道的 对于var关键字，要么定义全局变量、要么定义函数内变量； 不能定义只在一个语句块儿内部起作用的变量； 这叫做js的函数级作用域(function-level scope)； 123456(function test()&#123; if (true) &#123; x = 5; //x的作用域为全局 &#125; console.log(x); // 5&#125;)(); 12345678910function foo() &#123; var x = 1; if (x) &#123; (function () &#123; var x = 2; &#125;()); &#125; console.log(x); //1 &#125; foo(); 在严格模式下不能定义一个不被var修饰的变量12345678(function test()&#123; if (true) &#123; x = 5; //x的作用域为全局,严格模式报错 &#125; console.log(x); // 5&#125;)();console.log(x); // 5 用let关键字定义块儿级作用域变量 下面程序的lemma变量作用域为if语句块儿中； 123456789"use strict"function test(x,y)&#123; if(x&gt;y)&#123; let lemma = x+3; alert(lemma*y); //5 &#125; alert(lemma); // error&#125;test(2,1) javascript变量提升（hoisting） 变量提升是指，你可以引用稍后声明的变量，而不会引发异常； JavaScript变量感觉上是被“举起”或提升到了所有函数和语句之前； 提升后的变量将返回 undefined 值； 即使在使用或引用后面存在声明和初始化操作，仍将返回 undefined值； 12console.log(x === undefined); // logs "true"var x = 3; 123456var myvar = "my value";(function() &#123; console.log(myvar); // undefined var myvar = "local value";&#125;)(); 定义常量 可以用关键字 const 创建一个只读的常量； 常量标识符的命名规则和变量的相同：必须以字母、下划线或美元符号开头并可以包含有字母、数字或下划线； 常量不可以通过赋值改变其值，也不可以在脚本运行时重新声明; 常量，包括全局常量，都必须带const关键字; 若const关键字被省略了，该标识符将被视为变量; 1const prefix = '212';]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 严格模式详解]]></title>
    <url>%2F2015%2F11%2F10%2Fjs-strict%2F</url>
    <content type="text"><![CDATA[引言 严格模式是在ECMAscript 5中添加的； 严格模式消除Javascript语法的一些不合理、不严谨之处，消除代码运行的一些不安全之处； 严格模式提高编译器效率，增加运行速度； 如果不主动声明，编译器默认是正常模式； 进入严格模式的方式 在脚本第一行声明，则整个脚本都将以”严格模式”运行，如果这行语句不在第一行，则无效，整个脚本以”正常模式”运行； 将”use strict”放在函数体的第一行，则整个函数以”严格模式”运行； 12"use strict";console.log("这是严格模式。"); 1234function strict()&#123; "use strict"; return "这是严格模式";&#125; 严格模式”严格”了哪些语法行为 全局变量必须显式声明 12"use strict";i=1; //Uncaught ReferenceError: i is not defined 123456"use strict";(function() &#123; var a = b = 5; //由于b没有用var关键自定义，严格模式下报错&#125;)();console.log(b); //正常模式下b是全局变量，输出5 12345"use strict";var arr = new Array(1,2,3);for(i =0; i&lt;arr.length; i++)&#123; //Uncaught ReferenceError: i is not defined console.log(arr[i]);&#125; 严格模式下不能使用with语句 12345678"use strict"var o = document.createElement("div");with(o)&#123; //Uncaught SyntaxError: Strict mode code may not include a with statement style.width = "100px"; style.height = "100px"; style.backgroundColor = "#000";&#125;document.body.appendChild(o); 严格模式下，eval作用域发生变化 正常模式下，eval语句不形成单独的作用域，eval就相当于将其中的语句直接写到js中； 严格模式下，eval语句形成了自己的作用域； 123var x = 2;console.info(eval("var x = 5; x")); // 5console.info(x); // 5 1234"use strict";var x = 2;console.info(eval("var x = 5; x")); // 5console.info(x); // 2 严格模式增强了哪些安全措施 this关键字禁止指向全局对象 12345678function f()&#123; return !this; // 返回false，因为"this"指向全局对象，"!this"就是false&#125;function f()&#123; "use strict"; return !this; // 返回true，因为严格模式下，this的值为undefined，所以"!this"为true&#125; 12345"use strict";function f()&#123; this.name = 1; //Uncaught TypeError: Cannot set property 'name' of undefined&#125;;f(); 限制使用函数内置对象 argument对象（比如遍历argument输出传入参数值）及其属性（比如argument.length）仍可使用， 但caller、callee不能使用； argument对象不再追踪参数的变化情况; 123456789101112"use strict";function testCaller() &#123; alert(testCaller.caller); //报错 alert(arguments.callee); //报错&#125; function aCaller() &#123; alert(arguments.length); //由于传入参数个数为2，故输出2 alert(arguments.caller); //报错 testCaller();&#125; aCaller("haha","heihei"); 1234567function f(a) &#123; /*"use strict";*/ a = 2; alert(arguments.caller); return [a, arguments[0]];&#125;alert(f(1)); // 正常模式为[2,2], 严格模式为[2,1] 禁止随意删除变量 严格模式下无法删除变量； 只有configurable设置为true的对象属性，才能被删除； 12345678"use strict";var x;delete x; // 语法错误var o = Object.create(null, &#123;'x': &#123; value: 1, configurable: true&#125;&#125;);delete o.x; // 删除成功 另外 严格模式下，一个对象不能有重名的属性; 严格模式下，一个函数不能传入重名的参数； 严格模式下，禁止八进制表示法; 123"use strict";var o = &#123;p:1,p:2&#125;; //严格模式下报错alert(o.p); //正常模式下输出2 12"use strict";var i = 0100; //Uncaught SyntaxError: Octal literals are not allowed in strict mode. 严格模式下的对象操作 正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败，严格模式下将报错; 1234"use strict";var o = &#123;&#125;;Object.defineProperty(o, "v", &#123; value: 1, writable: false &#125;);o.v = 2; // 报错 严格模式下，对一个使用getter方法读取的属性进行赋值，会报错； 12345"use strict";var o = &#123; get v() &#123; return 1; &#125;&#125;;o.v = 2; // 报错 严格模式下，对禁止扩展的对象添加新属性，会报错； 1234"use strict";var o = &#123;&#125;;Object.preventExtensions(o);o.v = 1; // 报错 严格模式下，删除一个不可删除的属性，会报错； 12"use strict";delete Object.prototype; // 报错 保留字 为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield； 用这些新增保留字做变量名，正常模式不会报错，严格模式报错； 123"use strict"var implements = 1; //Uncaught SyntaxError: Unexpected strict mode reserved wordalert(implements);]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 二叉查找树的实现]]></title>
    <url>%2F2015%2F11%2F06%2F2015-11-6-java-binary-tree%2F</url>
    <content type="text"><![CDATA[引言 树是重要的数据结构； 本文简单介绍了树和二叉树的概念； 本文详细实现了二叉查找树； 树的基本术语： 树（Tree）是由显示节点间关系的边（edge）相连而成的节点的集合； 这些节点排列在表明节点层次的各层（level）上； 顶层是一个称为根（root）的单独节点； 树的高度是树的层的数目，一般的，树的高度是从根到叶子的最长路径的长度加一； 树的每个后继层中的节点是其上一层节点的孩子（children）； 有孩子的节点是这些孩子的双亲（parent）； 以某结点为根的子树中的任一节点成为该节点的子孙/后代（descendent）； 从根到某节点所经分支上的所有节点成为该节点的祖先（ancestor）； 双亲相同的孩子们被称为兄弟（sibling）； 没有孩子的节点成为叶子（leaf）节点； 不是叶子节点的节点被称作非叶节点（nonleaf）； 树的分类： 一般树（general tree）：树中的每个节点可以有任意数量的孩子； n叉树（n-ary tree）：树中的每个节点的孩子数量不超过n； 二叉树（binary tree）：树种每个节点至多有两个孩子； 二叉树： 二叉树每个节点至多有两个孩子，分别为左孩子（left child）和右孩子（right child）； 二叉树节点的子树被称为左子树（left subtree）和右子树（right subtree）； 二叉树的左子树是其根的左子树，二叉树的右子树是其根的右子树； 二叉树中每个非叶节点都恰好有两个孩子，且最后一层全部填满，则称二叉树是满的（full）； 二叉树中除了最后一层外其余层都含有尽可能多的节点，并且最后一层上的节点是从左到右填满的，则称这棵树是完全的（complete）； 二叉查找树 每个节点的数据大于该节点左子树的数据； 每个节点的数据小于该节点右子树的数据； 二叉查找树的实现 Node定义节点类 12345678910111213141516171819202122232425262728293031323334353637package binarytree;public class Node&lt;T&gt; &#123; Node&lt;T&gt; leftChid = null; Node&lt;T&gt; rightChild = null; T data; // 构造器 public Node() &#123; &#125; //构造器 public Node(T data)&#123; this.data = data; &#125; public void display() &#123; System.out.println(data + " "); &#125; public Node&lt;T&gt; getLeftChid() &#123; return leftChid; &#125; public void setLeftChid(Node&lt;T&gt; leftChid) &#123; this.leftChid = leftChid; &#125; public Node&lt;T&gt; getRightChild() &#123; return rightChild; &#125; public void setRightChild(Node&lt;T&gt; rightChild) &#123; this.rightChild = rightChild; &#125;&#125; BinaryTree类实现了二叉查找树的大部分方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445package binarytree;import java.util.Queue;import java.util.Stack;import java.util.concurrent.LinkedBlockingQueue;public class BinaryTree&lt;T extends Comparable&gt; &#123; public int maxHeight = 8; // 默认树的最大高度为8 public int size = 0; // 树的节点数量 Node&lt;T&gt; root = null; // 构造器 public BinaryTree() &#123; &#125; // 构造器 public BinaryTree(int maxHeight) &#123; this.maxHeight = maxHeight; &#125; /* * 基本动作 */ // 清空二叉树 public void clear() &#123; root = null; size = 0; &#125; // 判断是否为空 public boolean isEmpty() &#123; return size == 0; &#125; // 判断是否是满树 public boolean isFull() &#123; // 利用满树的高度和元素个数的关系判断 // 判断size+1是否是2的幂次即可 if (size == 0) &#123; return false; &#125; int p = size + 1; while (p % 2 == 0) &#123; p = p / 2; &#125; if (p == 1) &#123; return true; &#125; else &#123; return false; &#125; &#125; // 获取树的高度 public int getHeight() &#123; return height(root); &#125; public int height(Node&lt;T&gt; subTree) &#123; if (subTree == null) return 0; // 递归结束：空树高度为0 else &#123; int i = height(subTree.getLeftChid()); int j = height(subTree.getRightChild()); return (i &lt; j) ? (j + 1) : (i + 1); &#125; &#125; // 返回结点个数 public int getSize() &#123; return size; &#125; // 返回结点个数，第二种实现方法 public int getSize2() &#123; return size(root); &#125; public int size(Node&lt;T&gt; subTree) &#123; if (subTree == null) &#123; return 0; &#125; else &#123; return 1 + size(subTree.getLeftChid()) + size(subTree.getRightChild()); &#125; &#125; // 获取叶子节点总数 int leafNumber = 0; public int getLeafNum() &#123; leafNumber = 0; leafNum(root); return leafNumber; &#125; public void leafNum(Node&lt;T&gt; subTree) &#123; if (subTree != null) &#123; if (subTree.getLeftChid() == null &amp;&amp; subTree.getRightChild() == null) &#123; leafNumber++; &#125; leafNum(subTree.getLeftChid()); leafNum(subTree.getRightChild()); &#125; &#125; /* * 获取数据 */ // 获取根节点数据 public T getRoot() &#123; return root.data; &#125; // 获取双亲节点数据 public T getParent(T data) &#123; if (root == null) &#123; return null; &#125; else if (root.data.equals(data)) &#123; return root.data; &#125; else &#123; return parent(root, data); &#125; &#125; public T parent(Node&lt;T&gt; subTree, T data) &#123; // 思路：先找左子树，如果找到则返回数值，左子树找不到（左子树寻找结果为null的话）再去右子树找， // 如果找到则返回数值，找不到返回null if (subTree == null) &#123; return null; &#125; if (subTree.getLeftChid() != null &amp;&amp; subTree.getLeftChid().data.equals(data)) &#123; return subTree.data; &#125; else if (subTree.getRightChild() != null &amp;&amp; subTree.getRightChild().data.equals(data)) &#123; return subTree.data; &#125; else &#123; T p; if ((p = parent(subTree.getLeftChid(), data)) != null) &#123; return p; &#125; else &#123; return parent(subTree.getRightChild(), data); &#125; &#125; &#125; // 获取左孩子结点数据 public T getLeftChild(T data) &#123; if (root == null) &#123; return null; &#125; else &#123; return leftChild(root, data); &#125; &#125; public T leftChild(Node&lt;T&gt; subTree, T data) &#123; // 思路：先找左子树，如果找到则返回数值，左子树找不到（左子树寻找结果为null的话）再去右子树找， // 如果找到则返回数值，找不到返回null if (subTree == null) &#123; return null; &#125; if (subTree.data.equals(data) &amp;&amp; subTree.getLeftChid() != null) &#123; return subTree.getLeftChid().data; &#125; else &#123; T p; if ((p = leftChild(subTree.getLeftChid(), data)) != null) &#123; return p; &#125; else &#123; return leftChild(subTree.getRightChild(), data); &#125; &#125; &#125; // 获取右孩子结点数据 public T getRightChild(T data) &#123; if (root == null) &#123; return null; &#125; else &#123; return rightChild(root, data); &#125; &#125; public T rightChild(Node&lt;T&gt; subTree, T data) &#123; // 思路：先找左子树，如果找到则返回数值，左子树找不到（左子树寻找结果为null的话）再去右子树找， // 如果找到则返回数值，找不到返回null if (subTree == null) &#123; return null; &#125; if (subTree.data.equals(data) &amp;&amp; subTree.getRightChild() != null) &#123; return subTree.getRightChild().data; &#125; else &#123; T p; if ((p = rightChild(subTree.getLeftChid(), data)) != null) &#123; return p; &#125; else &#123; return rightChild(subTree.getRightChild(), data); &#125; &#125; &#125; // 获取节点中的最小值 T tMin; public T getMin() &#123; if (root == null) &#123; return null; &#125; else &#123; tMin = root.data; min(root); return tMin; &#125; &#125; public void min(Node&lt;T&gt; subTree) &#123; if (subTree != null) &#123; if (subTree.data.compareTo(tMin) &lt; 0) &#123; tMin = subTree.data; &#125; min(subTree.getLeftChid()); min(subTree.getRightChild()); &#125; &#125; // 获取节点中的最大值 T tMax; public T getMax() &#123; if (root == null) &#123; return null; &#125; else &#123; tMax = root.data; max(root); return tMax; &#125; &#125; public void max(Node&lt;T&gt; subTree) &#123; if (subTree != null) &#123; if (subTree.data.compareTo(tMax) &gt; 0) &#123; tMax = subTree.data; &#125; max(subTree.getLeftChid()); max(subTree.getRightChild()); &#125; &#125; /* * 插入和删除 */ // 插入节点: 每个节点的数据大于该节点左子树的数据、小于该节点右子树的数据； public void insert(T t) throws Exception &#123; if (root == null) &#123; root = new Node&lt;T&gt;(t); size++; &#125; else if (isFull() &amp;&amp; getHeight() == maxHeight) &#123; throw new Exception("二叉树已满且高度达到最大值！"); &#125; else &#123; insertNode(root, t); &#125; &#125; // 插入节点具体行为 public void insertNode(Node&lt;T&gt; node, T data) &#123; if (data.compareTo(node.data) &lt;= 0) &#123; if (node.getLeftChid() == null) &#123; node.setLeftChid(new Node&lt;T&gt;(data)); size++; &#125; else &#123; insertNode(node.getLeftChid(), data); &#125; &#125; else &#123; if (node.getRightChild() == null) &#123; node.setRightChild(new Node&lt;T&gt;(data)); size++; &#125; else &#123; insertNode(node.getRightChild(), data); &#125; &#125; &#125; // 删除某个子树 public void destroy(T t) &#123; if (root == null) &#123; return; &#125; else if (root.data.equals(t)) &#123; clear(); &#125; else &#123; destroyNode(root, t); &#125; &#125; public void destroyNode(Node&lt;T&gt; subTree, T t) &#123; //思路：先检查当前节点的左子树是否符合要求，符合则删除，不符合再检查右子树是否符合要求，符合则删除 //若左右子树都不符合，迭代查询下层节点的左右子树 //如果当前节点为null或叶子节点，不予检查，直接返回 if (subTree != null &amp;&amp; (subTree.getLeftChid() != null || subTree.getRightChild() != null)) &#123; if (subTree.getLeftChid() != null &amp;&amp; subTree.getLeftChid().data.equals(t)) &#123; subTree.setLeftChid(null); size--; &#125; if (subTree.getRightChild() != null &amp;&amp; subTree.getRightChild().data.equals(t)) &#123; subTree.setRightChild(null); size--; &#125; destroyNode(subTree.getLeftChid(), t); destroyNode(subTree.getRightChild(), t); &#125; &#125; /* * 递归遍历 */ // 先序遍历 public void getPreOrder() &#123; preOrder(root); &#125; public void preOrder(Node&lt;T&gt; subTree) &#123; if (subTree != null) &#123; visit(subTree); preOrder(subTree.getLeftChid()); preOrder(subTree.getRightChild()); &#125; &#125; public void visit(Node&lt;T&gt; node) &#123; node.display(); &#125; // 中序遍历 public void getInOrder() &#123; inOder(root); &#125; public void inOder(Node&lt;T&gt; subTree) &#123; if (subTree != null) &#123; inOder(subTree.getLeftChid()); visit(subTree); inOder(subTree.getRightChild()); &#125; &#125; // 后序遍历 public void getPostOrder() &#123; postOrder(root); &#125; public void postOrder(Node&lt;T&gt; subTree) &#123; if (subTree != null) &#123; postOrder(subTree.getLeftChid()); postOrder(subTree.getRightChild()); visit(subTree); &#125; &#125; // 按层次遍历 public void levelTraverse() &#123; levelTraverse(root); &#125; public void levelTraverse(Node&lt;T&gt; node) &#123; Queue&lt;Node&lt;T&gt;&gt; queue = new LinkedBlockingQueue&lt;Node&lt;T&gt;&gt;(); queue.add(node); while (!queue.isEmpty()) &#123; Node&lt;T&gt; temp = queue.poll(); if (temp != null) &#123; temp.display(); if (temp.getLeftChid() != null) queue.add(temp.getLeftChid()); if (temp.getRightChild() != null) queue.add(temp.getRightChild()); &#125; &#125; &#125; /* * 非递归遍历 */ // 先序遍历 public void nrPreOrder() &#123; Stack&lt;Node&lt;T&gt;&gt; stack = new Stack&lt;Node&lt;T&gt;&gt;(); Node&lt;T&gt; node = root; while (node != null || !stack.isEmpty()) &#123; while (node != null) &#123; node.display(); stack.push(node); node = node.getLeftChid(); &#125; node = stack.pop(); node = node.getRightChild(); &#125; &#125; // 中序遍历 public void nrInOrder() &#123; Stack&lt;Node&lt;T&gt;&gt; stack = new Stack&lt;Node&lt;T&gt;&gt;(); Node&lt;T&gt; node = root; while (node != null || !stack.isEmpty()) &#123; while (node != null) &#123; stack.push(node); node = node.getLeftChid(); &#125; node = stack.pop(); node.display(); ; node = node.getRightChild(); &#125; &#125; // 后序遍历 public void nrPostOrder() &#123; Stack&lt;Node&lt;T&gt;&gt; stack = new Stack&lt;Node&lt;T&gt;&gt;(); Node&lt;T&gt; node = root; Node&lt;T&gt; preNode = null; // 表示最近一次访问的节点 while (node != null || !stack.isEmpty()) &#123; while (node != null) &#123; stack.push(node); node = node.getLeftChid(); &#125; node = stack.peek(); if (node.getRightChild() == null || node.getRightChild() == preNode) &#123; node.display(); node = stack.pop(); preNode = node; node = null; &#125; else &#123; node = node.getRightChild(); &#125; &#125; &#125;&#125; BinaryTreeTest为测试类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package binarytree;public class BinaryTreeTest &#123; public static void main(String[] args) throws Exception &#123; BinaryTree&lt;Integer&gt; b = new BinaryTree&lt;Integer&gt;(); b.insert(0); System.out.println(b.isEmpty()); // false System.out.println(b.getSize()); // 1 b.clear(); System.out.println(b.isEmpty()); // true System.out.println(b.getSize()); // 0 System.out.println("-----------"); b.insert(11); b.insert(10); b.insert(14); System.out.println(b.isFull()); // true System.out.println(b.getHeight()); // 2 System.out.println(b.getSize()); // 3 System.out.println(b.getSize2()); // 3 System.out.println(b.getLeafNum()); // 2 System.out.println("-----------"); b.insert(15); System.out.println(b.isFull()); // false System.out.println(b.getHeight()); // 3 System.out.println(b.getSize()); // 4 System.out.println(b.getSize2()); // 4 System.out.println(b.getLeafNum()); // 2 System.out.println("-----------"); b.insert(12); System.out.println(b.isFull()); // false System.out.println(b.getHeight()); // 3 System.out.println(b.getSize()); // 5 System.out.println(b.getSize2()); // 5 System.out.println(b.getLeafNum()); // 3 System.out.println("-----------"); b.destroy(15); System.out.println(b.isFull()); // false System.out.println(b.getHeight()); // 3 System.out.println(b.getSize()); // 4 System.out.println(b.getSize2()); // 4 System.out.println(b.getLeafNum()); // 2 System.out.println("-----------"); b.insert(16); b.insert(17); b.insert(15); b.insert(18); System.out.println(b.isFull()); // false System.out.println(b.getHeight()); // 5 System.out.println(b.getSize()); // 8 System.out.println(b.getSize2()); // 8 System.out.println(b.getLeafNum()); // 4 System.out.println(b.getRoot()); // 11 System.out.println("-----------"); System.out.println(b.getParent(10)); // 11 System.out.println(b.getParent(16)); // 14 System.out.println(b.getParent(12)); // 14 System.out.println(b.getParent(17)); // 16 System.out.println(b.getParent(18)); // 17 System.out.println(b.getParent(20)); // null System.out.println("-----------"); System.out.println(b.getLeftChild(11)); // 10 System.out.println(b.getLeftChild(10)); // null System.out.println(b.getLeftChild(14)); // 12 System.out.println(b.getLeftChild(16)); // 15 System.out.println(b.getLeftChild(15)); // null System.out.println(b.getLeftChild(17)); // null System.out.println(b.getLeftChild(18)); // null System.out.println("-----------"); System.out.println(b.getRightChild(11)); // 14 System.out.println(b.getRightChild(10)); // null System.out.println(b.getRightChild(14)); // 16 System.out.println(b.getRightChild(12)); // null System.out.println(b.getRightChild(16)); // 17 System.out.println(b.getRightChild(17)); // 18 System.out.println(b.getRightChild(18)); // null System.out.println("-----------"); System.out.println(b.getMin()); // 10 System.out.println(b.getMax()); // 18 System.out.println("-----------"); b.getPreOrder(); System.out.println("-----------"); // 11 10 14 12 16 15 17 18 b.getInOrder(); System.out.println("-----------"); // 10 11 12 14 15 16 17 18 b.getPostOrder(); System.out.println("-----------"); // 10 12 15 18 17 16 14 11 b.levelTraverse(); System.out.println("-----------"); // 11 10 14 12 16 15 17 18 b.nrPreOrder(); System.out.println("-----------"); // 11 10 14 12 16 15 17 18 b.nrInOrder(); System.out.println("-----------"); // 10 11 12 14 15 16 17 18 b.nrPostOrder(); System.out.println("-----------"); // 10 12 15 18 17 16 14 11 &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 堆的实现]]></title>
    <url>%2F2015%2F11%2F06%2F2015-11-6-java-heap%2F</url>
    <content type="text"><![CDATA[引言 堆是节点含有可比较对象，并以如下方式组织的完全二叉树：每个节点含有的对象不小于(最大堆)/不大于(最小堆)其后代中的对象； 最大堆的根含有堆中最大的对象； 最大堆中任何节点的子树也是最大堆； 堆是java中重要的数据结构，堆排序算法就要用到堆； 本文实现了简单的堆； 堆的实现 MyHeap类实现了堆的大部分方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147package heap;import java.lang.reflect.Array;public class MyHeap&lt;T extends Comparable&lt;T&gt;&gt; &#123; public static final int INITIAL_SIZE = 16; Class&lt;T&gt; type; boolean flag = false; T[] heap; int size = 0; // 堆中元素数量 // 构造器 public MyHeap() &#123; &#125; // 构造器 public MyHeap(Class&lt;T&gt; type) &#123; heap = (T[]) Array.newInstance(type, INITIAL_SIZE); this.type = type; &#125; // 清空堆 public void clear() &#123; heap = (T[]) Array.newInstance(type, INITIAL_SIZE); size = 0; &#125; // 堆中元素数量 public int size() &#123; return size; &#125; // 检查数组大小 public void checkSize() &#123; if (size &gt; heap.length / 2) &#123; T[] heap1 = (T[]) Array.newInstance(type, INITIAL_SIZE * 2); System.arraycopy(heap, 0, heap1, 0, heap.length); heap = heap1; &#125; &#125; // 求父节点数组下标 public int getParent(int i) &#123; return (i + 1) / 2 - 1; &#125; // 求左子节点数组下标 public int getLeftChild(int i) &#123; int t = (i + 1) * 2 - 1; return t; &#125; // 求右子节点数组下标 public int getRightChild(int i) &#123; int t = (i + 1) * 2; return t; &#125; // 获取某元素下标 public int getEle(T t) &#123; for (int i = 0; i &lt; size; i++) &#123; if (heap[i].equals(t)) &#123; flag = true; return i; &#125; &#125; return 0; &#125; // 换位置 public void swap(int i, int j) &#123; T temp; temp = heap[i]; heap[i] = heap[j]; heap[j] = temp; &#125; // 维护堆的性质(小顶堆) public void buildHeap(int i) &#123; if (i &gt; 0) &#123; if (heap[i].compareTo(heap[getParent(i)]) &lt; 0) &#123; swap(i, getParent(i)); &#125; buildHeap(getParent(i)); &#125; &#125; // 插入元素 public void insert(T t) &#123; checkSize(); heap[size] = t; buildHeap(size); size++; &#125; // 获取最小元素（堆顶元素） public T minEle() &#123; return heap[0]; &#125; // 获取某个元素的父元素 public T getParentEle(T t) &#123; flag = false; int i = getEle(t); if (!flag) &#123; return null; &#125; else if (i == 0) return heap[0]; else &#123; return heap[getParent(i)]; &#125; &#125; // 获取某元素左孩子 public T getLeftChildEle(T t) &#123; flag = false; int i = getEle(t); if (!flag) &#123; return null; &#125; else if (getLeftChild(i) &gt;= size) &#123; return null; &#125; else &#123; return heap[getLeftChild(i)]; &#125; &#125; // 获取某元素的右孩子 public T getRightChildEle(T t) &#123; flag = false; int i = getEle(t); if (!flag) &#123; return null; &#125; else if (getRightChild(i) &gt;= size) &#123; return null; &#125; else &#123; return heap[getRightChild(i)]; &#125; &#125; // 遍历堆（先序遍历） public void getPreOrder() &#123; for (int i = 0; i &lt; size; i++) &#123; System.out.println(heap[i]); &#125; &#125;&#125; TestMyHeap为测试类 123456789101112131415161718192021222324252627282930313233343536373839404142434445package heap;public class TestMyHeap &#123; public static void main(String[] args) &#123; MyHeap&lt;Integer&gt; h = new MyHeap&lt;Integer&gt;(Integer.class); h.insert(10); h.insert(11); h.insert(9); System.out.println(h.size()); //3 h.getPreOrder(); //9 11 10 System.out.println("----------"); h.clear(); h.insert(10); h.insert(11); h.insert(8); h.insert(9); h.insert(10); h.insert(12); h.insert(6); h.insert(13); h.insert(4); h.insert(7); System.out.println(h.size()); //10 System.out.println(h.minEle()); //4 h.getPreOrder(); //4 6 8 9 7 12 10 13 11 10 System.out.println("----------"); System.out.println(h.getParentEle(4)); //4 System.out.println(h.getParentEle(6)); //4 System.out.println(h.getParentEle(12)); //8 System.out.println(h.getParentEle(13)); //9 System.out.println(h.getParentEle(14)); //null System.out.println(h.getLeftChildEle(4)); //6 System.out.println(h.getLeftChildEle(13)); //null System.out.println(h.getLeftChildEle(7)); //10 System.out.println(h.getLeftChildEle(14)); //null System.out.println(h.getRightChildEle(4)); //8 System.out.println(h.getRightChildEle(8)); //10 System.out.println(h.getRightChildEle(7)); //null System.out.println(h.getRightChildEle(11)); //null &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[定义更安全的JSONP]]></title>
    <url>%2F2015%2F11%2F06%2F2015-11-6-safer-JSONP%2F</url>
    <content type="text"><![CDATA[说明 本文翻译自这篇文章 文中并未就JSOPN提出更加安全的一个定义，但是为跨域访问策略的发展指明了一个方向； 引言 JSON是一种轻量级的数据交换格式。它是由Douglas Crockford正式提出的规范。JSON作为在两个实体间进行数据传输的强大工具的代表，无论发收数据的实体采用的是什么计算机语言，JSON已经被越来越多的接受和使用。 跨域访问的AJAX–简介 浏览器的同源策略决定了，在数据传输时，如果目标资源所在的域等同于发出请求的页面，这样的传输行为才被允许。这一措施被所有的现代浏览器所采用，以防止不必要的或不安全的恶意JavaScript的用户行为。 跨域Ajax是指突破同源策略的限制，使得跨域请求成为可能的想法。事实上，跨域的Ajax不是绝对的不安全或邪恶的，它实际上是许多世界上最流行和实用的应用中必不可少的。但是，由于种种原因，跨域Ajax始终和同源策略格格不入。 JSON-P (JSONP) JSONP是这样的一个机制，它可以通过&lt;script&gt;标签请求不同域的内容。 2005年12月，Bob Ippolito正式提出JSONP（后来被称为JSON-P或JSON-with-padding），以此来充分利用的&lt;script&gt;标签的属性，实现跨域请求JSON格式的数据。JSON-P的工作原理是使一个&lt;script&gt;元素（HTML标签或通过JavaScript插入到DOM中），它请求服务器端的数据服务。HTTP请求的响应（装“的JavaScript”的实体内容）的内容是在请求中预先定义的，它通过参数传递给服务器端，提供被请求的JSON格式的数据的名称。当脚本执行时，相应的函数被调用，回传JSON格式的数据，从而使请求页面接收和处理这些数据。例子如下： 123function handle_data(data) &#123; // `data` is now the object representation of the JSON data&#125; 123http://some.tld/web/service?callback=handle_data:handle_data(&#123;"data_1": "hello world", "data_2": ["the","sun","is","shining"]&#125;); 正如你所看到的，远端Web服务通过请求URL中的参数知道调用的函数的名称。只要该函数是在请求页面实际定义的，它会在收到数据后被调用。 问题 迄今，JSON-P基本上已经被会议非正式的定义，事实上，浏览器可以接受任意的JavaScript响应。这意味着，任何依靠JSON-P的实现跨域访问的策略其实都将带来同源策略试图避免的危害。例如，一个恶意的Web服务可以通过调用函数发送JSONP请求，黑客可以通过返回的JavaScript信息窃取用户的隐私数据等。 出于这个原因，很多人将JSON-P视为一种不安全和易被黑客利用的跨域Ajax策略，这似乎理由非常充分。所以，程序员们必须足够用心，在调用远程Web服务之前必须确认对方是受控或受信任的，这样才能避免他们的用户受到伤害。 替代方案 有很多替代JSON-P实现跨域请求的办法，但每种方案都有自己的缺点和面临的挑战。这些技术将不会在这里详细介绍，除了这个：CORS（跨域资源共享）。 这是最近最流行的的JavaScript跨域Ajax调用方案之一。简单地说，CORS是一种扩展的XMLHttpRequest（又名“XHR”）对象，它可以让浏览器进行跨域调用（尽管存在同源策略的限制）。它会首先“预检测”目标服务器，确认服务器允许它这样做。 换句话说，远程服务器能够选择加入或退出此类通信，基于它认为是否是合适的。例如，一台服务器可以应答用户端的Ajax请求，并从唯一认可的网站域名的一个预先定义的列表中获取一些内容回传客户端，而且拒绝任何其他页面中的所有其他请求。或者，如果服务器认为适合这样做，它可以开放其内容被任何其它域进行检索。 乍一看，CORS可能看起来像是跨域Ajax请求的理想解决方案，使“黑客”无从下手。Nicholas Zakas最近写了一篇关于CORS的跨域Ajax请求方案，并指出它是浏览器跨域Ajax请求的解决方案中最有希望的一个。 CORS是否将最终成为浏览器跨域访问解决方案的标准，我们将拭目以待。当然它也有一些缺点，很可能存在一些细节问题（devil is always in the details）。 首先，CORS需要实现一个Web服务，以实现拦截HTTP请求头中特殊的“预检”的授权请求，并根据服务器相关的策略，决定响应的格式。如果一个基于JSON格式的网络服务需要JSON-P跨域请求的支持，这相当简单，只需在一个函数调用中包装JSON数据块即可。 在所有的互联网Web服务实现回传自定义数据更加值得期待，当然这取决于Web服务器软件的权限设置。这种技术可能需要若干年才能流行开来，并实现大部分的网络服务供应商兼容CORS。截至目前，这是非常新的技术，很少Web服务已经这样做了。 此外，CORS仅在IE8浏览器开始实施（尽管有一些轻微的语法上的不同），尚未兼容Opera。因此，不支持CORS的情况时有发生，这意味着替代跨域Ajax的备选方案也许在1-3年后才可能推广开来。 可能的解决方案 现在，JSON-P是跨域Ajax一个可行的解决方案。CORS可以减少黑客攻击的可能性，它可能应该在JSON-P技术串联部署，从而在不支持CORS的浏览器推广开来。然而，JSON-P的安全问题应当认真考虑并加以解决。 所以，JSON-P严格的子集的定义是非常必要的。下面我们将介绍什么应视为有效、安全、可被允许的JSON-P。 12345functionName(&#123;JSON&#125;);obj.functionName(&#123;JSON&#125;);obj["function-name"](&#123;JSON&#125;); 其含义是，只能有一个函数表达式（函数的引用，或对象属性的引用）可用于作为该函数的JSON-P的响应，在这个单一的()中一定是严格有效的、可解析JSON对象。函数调用可以选择性地跟着一个分号。 该提案的最关键的部分是浏览器厂商必须开始强制将这条规则应用于接收JSON-P回传数据的的&lt;script&gt;脚本上，并对任何不符合JSONP内容的错误抛出异常（或至少停止处理）。 为了使浏览器能够知道什么时候应该过滤内容，或是看作是常规的JavaScript内容，MIME类型为“application / JSON-P”和/或“text/ JSON-P”的必须请求&lt;script&gt;标签中声明。 缺点 不支持CORS的浏览器以及将来也不支持CORS的浏览器将不会拥有JSON-P的严格保护，这意味着，使用这些浏览器的用户将不会得到保护。但是，目前所有的浏览器都可以增加这个内容过滤功能，这对于使用尚未兼容CORS的浏览器的用户是一种安全支持。 注解 一个可能的帮助老的浏览器用户安全的利用JSON-P技术的方案是提前检测浏览器没有这样的支持，并只对那些在不安全的浏览器中的、有条件的连接发出的请求启用本地服务器代理，它可以作为一个网关，并根据上面提到的逻辑进行内容过滤。 前瞻 这是第一次讨论安全的JSON-P。在此，我主张在社区开放讨论，共同寻找可以向W3C，WHATWG和浏览器厂商宣传的一个可行的定义。 最好方法是回复本文，或从本讨论建立链接。此外，本网站代码已经托管在GitHub上，你可以fork或修改以便继续讨论，然后通过pull操作更新讨论。最后，你可以在下面的评论表中作简短评论，但请保持简短，以便他人跟踪讨论进度。]]></content>
      <categories>
        <category>translation</category>
      </categories>
      <tags>
        <tag>JSONP</tag>
        <tag>translation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 双端队列的实现]]></title>
    <url>%2F2015%2F11%2F05%2F2015-11-5-java-deque%2F</url>
    <content type="text"><![CDATA[引言 双端队列是java中重要的数据结构，有着广泛的应用； 双端队列一般用双向链表实现； 本文就用双向链表实现了简单的双端队列； Deque的实现 Node类定义双端队列的节点 12345678910111213141516171819202122232425262728293031323334353637package deque;public class Node&lt;T&gt; &#123; public Node&lt;T&gt; before; public Node&lt;T&gt; after; public T data; // 构造器 public Node() &#123; &#125; // 构造器 public Node(T t) &#123; this.data = t; &#125; public Node&lt;T&gt; getBefore() &#123; return before; &#125; public void setBefore(Node&lt;T&gt; before) &#123; this.before = before; &#125; public Node&lt;T&gt; getAfter() &#123; return after; &#125; public void setAfter(Node&lt;T&gt; after) &#123; this.after = after; &#125; public void display() &#123; System.out.println(data + " "); &#125;&#125; Deque类实现了双端队列的大部分方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131package deque;public class Deque&lt;T&gt; &#123; public int maxSize = 8; // 默认队列容量为8 public int size = 0; // 双端队列的长度 public Node&lt;T&gt; first; // 首节点 public Node&lt;T&gt; last; // 尾节点 // 构造器 public Deque() &#123; &#125; // 构造器 public Deque(int maxSize) &#123; this.maxSize = maxSize; &#125; // 清空队列 public void clear() &#123; size = 0; first = null; last = null; &#125; // 在首部添加 public void addToFront(T t) throws Exception &#123; Node&lt;T&gt; node = new Node&lt;T&gt;(); node.data = t; if (size == 0) &#123; first = node; last = node; size++; &#125; else if (size &lt; maxSize) &#123; node.setAfter(first); first.setBefore(node); first = node; size++; &#125; else &#123; throw new Exception("队列已满！"); &#125; &#125; // 在尾部添加 public void addToBack(T t) throws Exception &#123; Node&lt;T&gt; node = new Node&lt;T&gt;(); node.data = t; if (size == 0) &#123; first = node; last = node; size++; &#125; else if (size &lt; maxSize) &#123; node.setBefore(last); last.setAfter(node); last = node; size++; &#125; else &#123; throw new Exception("队列已满！"); &#125; &#125; // 从首部删除 public void removeFront() throws Exception &#123; if (size == 0) &#123; throw new Exception("队列为空"); &#125; else if (size == 1) &#123; clear(); &#125; else &#123; first = first.getAfter(); first.setBefore(null); size--; &#125; &#125; // 从尾部删除 public void removeBack() throws Exception &#123; if (size == 0) &#123; throw new Exception("队列为空"); &#125; else if (size == 1) &#123; clear(); &#125; else &#123; last = last.getBefore(); last.setAfter(null); size--; &#125; &#125; // 获取首部元素 public T getFront() &#123; if (size == 0) &#123; return null; &#125; else &#123; return first.data; &#125; &#125; // 获取尾部元素 public T getBack() &#123; if (size == 0) &#123; return null; &#125; else &#123; return last.data; &#125; &#125; // 判断是否为空 public boolean isEmpty() &#123; return size == 0; &#125; //判断是否队列已满 public boolean isFull()&#123; return size==maxSize; &#125; //获取队列长度 public int size()&#123; return size; &#125; // 输出队列全部内容 public void displayAll() &#123; if (size != 0) &#123; Node&lt;T&gt; node = first; while (node != null) &#123; node.display(); node = node.getAfter(); &#125; &#125; &#125;&#125; DuqueTest测试类 12345678910111213141516171819202122232425262728293031323334353637383940414243package deque;public class DequeTest &#123; public static void main(String[] args) throws Exception &#123; Deque&lt;String&gt; d = new Deque&lt;String&gt;(8); d.addToFront("111"); d.addToFront("222"); d.addToBack("333"); System.out.println(d.size()); //3 d.displayAll(); //222 111 333 System.out.println("----------"); d.clear(); System.out.println(d.size()); //0 System.out.println("----------"); d.addToFront("aaa"); d.addToFront("bbb"); d.addToFront("ccc"); d.addToFront("ddd"); d.addToBack("eee"); d.addToBack("fff"); System.out.println(d.size()); //6 d.displayAll(); //ddd ccc bbb aaa eee fff System.out.println("----------"); d.removeFront(); d.removeBack(); d.removeBack(); System.out.println(d.size()); //3 d.displayAll(); //ccc bbb aaa System.out.println("----------"); System.out.println(d.getFront()); //ccc System.out.println(d.getBack()); //aaa System.out.println("----------"); System.out.println(d.isEmpty()); //false System.out.println(d.isFull()); //false &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 队列的实现]]></title>
    <url>%2F2015%2F11%2F05%2F2015-11-5-java-queue%2F</url>
    <content type="text"><![CDATA[引言 队列是java中重要的数据结构； 本文用数组实现了简单的单端队列； 单端队列的实现 MyQueue类实现了队列的大部分方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package queuetest;public class MyQueue&lt;T&gt; &#123; public int size = 0; // 当前队列长度 public int maxSize = 8; // 队列容量，默认8 protected T[] queue = (T[]) new Object[maxSize]; // 队列用数组实现 // 构造器 public MyQueue() &#123; &#125; // 构造器 public MyQueue(int maxSize) &#123; this.maxSize = maxSize; &#125; // 清空队列 public void clear() &#123; queue = (T[]) new Object[maxSize]; size = 0; &#125; // add,如果队列已满，则抛出异常 public void add(T t) throws Exception &#123; if (size == maxSize) &#123; throw new Exception("队列容量已满."); &#125; else &#123; queue[size] = t; size++; &#125; &#125; // offer，添加一个元素并返回true，如果队列已满，则返回false public boolean offer(T t) &#123; if (size &lt; maxSize) &#123; queue[size] = t; size++; return true; &#125; return false; &#125; // element,返回队列头部的元素,如果队列为空,则抛出异常 public T element() throws Exception &#123; if (size == 0) &#123; throw new Exception("队列为空！"); &#125; else &#123; return queue[0]; &#125; &#125; // peek,返回队列头部的元素,如果队列为空，则返回null public T peek() &#123; if (size == 0) &#123; return null; &#125; else &#123; return queue[0]; &#125; &#125; // remove,移除并返回队列头部的元素,如果队列为空则抛出异常 public T remove() throws Exception &#123; if (size != 0) &#123; T t = queue[0]; for (int i = 0; i &lt; size - 1; i++) &#123; queue[i] = queue[i + 1]; &#125; queue[size - 1] = null; size--; return t; &#125; else &#123; throw new Exception("队列为空！"); &#125; &#125; // poll,移除并返问队列头部的元素,如果队列为空则返回null public T poll() &#123; if (size != 0) &#123; T t = queue[0]; for (int i = 0; i &lt; size - 1; i++) &#123; queue[i] = queue[i + 1]; &#125; queue[size - 1] = null; size--; return t; &#125; else &#123; return null; &#125; &#125; // 当前队列长度 public int size() &#123; return size; &#125; // 是否为空 public boolean isEmpty() &#123; return size == 0; &#125; // 遍历队列元素 public void display() &#123; for (int i = 0; i &lt; size; i++) &#123; System.out.println(queue[i]); &#125; &#125;&#125; MyQueueTest 测试类 1234567891011121314151617181920212223242526272829303132333435363738package queuetest;public class MyQueueTest &#123; public static void main(String[] args) throws Exception &#123; MyQueue&lt;String&gt; mq = new MyQueue&lt;String&gt;(4); mq.add("111"); mq.add("222"); mq.add("333"); mq.add("444"); System.out.println(mq.size()); //4// mq.add("555"); //java.lang.Exception: 队列容量已满. System.out.println(mq.size()); //4 System.out.println(mq.offer("666")); //false System.out.println(mq.size()); //4 System.out.println("-----------"); System.out.println(mq.element()); //111 System.out.println(mq.peek()); //111 System.out.println("-----------"); System.out.println(mq.isEmpty()); //false mq.display(); //111 222 333 444 System.out.println("-----------"); System.out.println(mq.remove()); //111 System.out.println(mq.remove()); //222 System.out.println(mq.remove()); //333 System.out.println(mq.remove()); //444 System.out.println(mq.size()); //0// System.out.println(mq.remove()); //java.lang.Exception: 队列为空！ System.out.println(mq.poll()); //null System.out.println(mq.size()); //0// System.out.println(mq.element()); //java.lang.Exception: 队列为空！ System.out.println(mq.peek()); //null &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java HashMap的实现]]></title>
    <url>%2F2015%2F11%2F04%2F2015-11-4-java-HashMap%2F</url>
    <content type="text"><![CDATA[引言 Java中，HashMap是重要的数据结构； HashMap用散列表实现，具体来说： HashMap底层维护一个数组充当哈希表； 当向HashMap中put一对键值时，它会根据key的hashCode值计算出一个位置，该位置就是此对象准备往数组中存放的位置，然后将key、value、next等值存放在Bucket中，作为Map.Entry； 如果有哈希值的冲突，即两组数据要放在数组的同一个位置(bucket)中，则用链表实现； 当从HashMap中get一个键值对时，HashMap会使用键对象的hashcode找到bucket位置，然后获取值对象； 如果数组的同一个位置对应多个键值对，将会遍历LinkedList，并调用keys.equals()方法去找到LinkedList中正确的节点，最终找到要找的值对象； 本文实现了一个简单的HashMap； HashMap具体实现 Entry类，定义节点 1234567891011121314151617181920212223242526272829303132package MyHashMap;import java.util.Objects;public class Entry&lt;K, V&gt; &#123; K k; V v; Entry&lt;K, V&gt; nextEntry = null; // 构造器 public Entry(K k, V v) &#123; this.k = k; this.v = v; this.nextEntry = null; &#125; public void setNextEntry(Entry&lt;K, V&gt; e) &#123; this.nextEntry = e; &#125; public Entry&lt;K, V&gt; getNextEntry() &#123; return this.nextEntry; &#125; public int hashCode() &#123; return Objects.hashCode(k) ^ Objects.hashCode(v); &#125; public void display() &#123; System.out.println("key:" + k + " value:" + v); &#125;&#125; MyHashMap类，实现HashMap大部分方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165package MyHashMap;public class MyHashMap&lt;K, V&gt; &#123; public static final int DEFAULT_INITIAL_CAPACITY = 16; protected Entry&lt;K, V&gt;[] entry = new Entry[DEFAULT_INITIAL_CAPACITY]; protected int size = 0; // 记录hashmap大小 protected int bucketSize = 0; // 清空hashmap public void clear() &#123; entry = new Entry[DEFAULT_INITIAL_CAPACITY]; size = 0; &#125; // 检测数组大小 public void testSize() &#123; int length = entry.length; if (bucketSize &gt;= length / 2) &#123; Entry&lt;K, V&gt;[] newEntry = new Entry[length * 2]; System.arraycopy(entry, 0, newEntry, 0, length); &#125; &#125; // 计算元素在数组中的位置 public static int indexFor(int h, int size) &#123; return h % (size - 1); &#125; // 是否含有特定key public boolean containsKey(K k) &#123; int index = indexFor(k.hashCode(), entry.length); if(entry[index]!=null)&#123; if(entry[index].k.equals(k))&#123; return true; &#125;else&#123; Entry&lt;K,V&gt; e = entry[index].nextEntry; while(e!=null)&#123; if(e.k.equals(k))&#123; return true; &#125; &#125; &#125; &#125; return false; &#125; // 是否包含特定value值 public boolean containsValue(V v) &#123; for (int i = 0; i &lt; entry.length; i++) &#123; if (entry[i] != null) &#123; if (entry[i].v.equals(v)) &#123; return true; &#125; else &#123; if (entry[i].nextEntry != null) &#123; Entry&lt;K, V&gt; e = entry[i]; while (e != null) &#123; if (e.v.equals(v)) &#123; return true; &#125; e = e.nextEntry; &#125; &#125; else &#123; continue; &#125; &#125; &#125; &#125; return false; &#125; // 获取特定key的value值 public V get(K k) &#123; int index = indexFor(k.hashCode(), entry.length); if(entry[index]!=null)&#123; if(entry[index].k.equals(k))&#123; return entry[index].v; &#125;else&#123; Entry&lt;K,V&gt; e = entry[index].nextEntry; while(e!=null)&#123; if(e.k.equals(k))&#123; return e.v; &#125; &#125; &#125; &#125; return null; &#125; // 插入数据 public void put(K k, V v) &#123; testSize(); int index = indexFor(k.hashCode(), entry.length); // 计算这个元素在数组中的位置 Entry&lt;K, V&gt; e = new Entry&lt;K, V&gt;(k, v); if (entry[index] == null) &#123; entry[index] = e; bucketSize++; &#125; else &#123; Entry&lt;K, V&gt; ee = entry[index]; ee.setNextEntry(e); &#125; size++; &#125; // 删除数据 public void remove(K k) &#123; int index = indexFor(k.hashCode(), entry.length); if(entry[index]!=null)&#123; Entry&lt;K,V&gt; e = entry[index]; if (e.nextEntry == null) &#123; if (e.k.equals(k)) &#123; entry[index] = null; bucketSize--; size--; &#125; &#125; else &#123; if (e.k.equals(k)) &#123; entry[index] = e.nextEntry; size--; &#125; else &#123; Entry&lt;K, V&gt; previous = e; Entry&lt;K, V&gt; current = e.nextEntry; while (current != null) &#123; if (current.k.equals(k)) &#123; previous.nextEntry = current.nextEntry; size--; break; &#125; previous = current; current = current.getNextEntry(); &#125; &#125; &#125; &#125; &#125; // 判断是否为空 public boolean isEmpty() &#123; return size == 0; &#125; // 获取长度 public int size() &#123; return size; &#125; // 遍历输出 public void diaplayAll() &#123; for (int i = 0; i &lt; entry.length; i++) &#123; if (entry[i] != null) &#123; if (entry[i].nextEntry != null) &#123; Entry&lt;K, V&gt; e = entry[i]; while (e != null) &#123; e.display(); e = e.nextEntry; &#125; &#125; else &#123; entry[i].display(); continue; &#125; &#125; &#125; &#125;&#125; TestMyHashMap测试类 12345678910111213141516171819202122232425262728293031323334353637package MyHashMap;public class TestMyHashMap &#123; public static void main(String[] args) &#123; MyHashMap&lt;String, String&gt; mhm = new MyHashMap&lt;String, String&gt;(); mhm.put("1", "111"); mhm.put("2", "222"); System.out.println(mhm.size()); //2 mhm.clear(); System.out.println(mhm.isEmpty()); //true System.out.println("-------------"); mhm.put("1", "aaa"); mhm.put("6", "fff"); mhm.put("2", "bbb"); mhm.put("5", "eee"); mhm.put("4", "ddd"); mhm.put("3", "ccc"); System.out.println(mhm.size()); //6 mhm.remove("2"); System.out.println(mhm.size()); //5 System.out.println(mhm.containsKey("5")); //true System.out.println(mhm.containsKey("2")); //false System.out.println(mhm.containsKey("3")); //true System.out.println(mhm.containsValue("ccc")); //true System.out.println(mhm.containsValue("ggg")); //false System.out.println(mhm.get("6")); //fff System.out.println(mhm.get("5")); //eee System.out.println(mhm.get("2")); //null System.out.println(mhm.isEmpty()); //false System.out.println("-------------"); mhm.diaplayAll(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java HashMap的遍历]]></title>
    <url>%2F2015%2F11%2F04%2F2015-11-4-HashMap-traverse%2F</url>
    <content type="text"><![CDATA[引言 HashMap是java中非常重要的数据结构； 本文提供了HashMap的若干种遍历方法，大体上分为两类： 通过Map.Entry遍历； 通过keyset遍历； HashMap遍历方法汇总1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package test5;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Map.Entry;import java.util.Set;public class MapTest &#123; public static void main(String[] args) &#123; Map&lt;Integer, String&gt; m = new HashMap&lt;Integer, String&gt;(); m.put(1, "aaa"); m.put(2, "bbb"); m.put(3, "ccc"); m.put(4, "ddd"); m.put(5, "eee"); // 遍历方法一 for (Map.Entry&lt;Integer, String&gt; entry : m.entrySet()) &#123; System.out.println("key:" + entry.getKey() + " value:" + entry.getValue()); &#125; System.out.println("----------"); // 遍历方法二 Iterator&lt;Entry&lt;Integer, String&gt;&gt; it = m.entrySet().iterator(); while (it.hasNext()) &#123; Map.Entry&lt;Integer, String&gt; entry = it.next(); System.out.println("key:" + entry.getKey() + " value:" + entry.getValue()); &#125; System.out.println("----------"); // 遍历方法三 Set&lt;Integer&gt; s = m.keySet(); Iterator&lt;Integer&gt; it1 = s.iterator(); while (it1.hasNext()) &#123; int i = it1.next(); System.out.println("key:" + i + " value:" + m.get(i)); &#125; System.out.println("----------"); //遍历方法四 for(int i : m.keySet())&#123; System.out.println("key:"+i+" value:"+m.get(i)); &#125; System.out.println("----------"); //遍历方法五 遍历所有的值 不能读取key for(String value:m.values())&#123; System.out.println("value:"+value); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Stack的实现]]></title>
    <url>%2F2015%2F11%2F04%2F2015-11-4-java-Stack%2F</url>
    <content type="text"><![CDATA[引言 Stack是java中常用的数据结构； 栈遵循先进后出，后进先出； 本文实现了一个简单的栈； 栈的实现 MyStack实现了栈的大部分方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package test6;public class MyStack&lt;T&gt; &#123; public static final int DEFAULT_INITIAL_CAPACITY = 16; public int size = 0; // 栈大小 protected T[] stack = (T[]) new Object[DEFAULT_INITIAL_CAPACITY]; // 清空栈 public void clear() &#123; stack = (T[]) new Object[DEFAULT_INITIAL_CAPACITY]; size = 0; &#125; // 判断容量 public void testCapacity() &#123; if (size &gt;= stack.length) &#123; T[] stack1 = (T[]) new Object[stack.length * 2]; System.arraycopy(stack, 0, stack1, 0, stack.length); stack = stack1; &#125; &#125; // 判断是否为空 public boolean isEmpty() &#123; return size == 0; &#125; // Looks at the object at the top of this stack without removing it from the // stack public T peek() &#123; return stack[size - 1]; &#125; // 压入数据 public void push(T t) &#123; testCapacity(); stack[size] = t; size++; &#125; // 弹出数据 public T pop() &#123; T t = stack[size - 1]; size--; return t; &#125; //Returns the 1-based position where an object is on this stack public int search(T t)&#123; for(int i =size-1; i&gt;=0; i--)&#123; if(stack[i].equals(t))&#123; return size-i; &#125; &#125; return -1; &#125; //获取容量 public int size()&#123; return size; &#125;&#125; TestMyStack测试类 12345678910111213141516171819202122232425262728package test6;public class TestMyStack &#123; public static void main(String[] args) &#123; MyStack&lt;String&gt; s = new MyStack&lt;String&gt;(); s.push("111"); s.push("222"); System.out.println(s.size()); //2 s.clear(); System.out.println(s.size()); //0 System.out.println("----------"); s.push("aaa"); s.push("bbb"); s.push("ccc"); s.push("ddd"); System.out.println(s.size()); //4 System.out.println(s.isEmpty()); //false System.out.println(s.search("ccc")); //2 System.out.println(s.peek()); //ddd System.out.println("----------"); s.pop(); System.out.println(s.peek()); //ccc &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java ArrayList的实现]]></title>
    <url>%2F2015%2F11%2F03%2F2015-11-3-java-ArrayList%2F</url>
    <content type="text"><![CDATA[引言 Java中，ArrayList是重要的数据结构； ArrayList用数组实现； 本文实现了一个简单的ArrayList； 具体实现 MyArrayList 完成大部分方法实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136package arraylisttest;public class MyArrayList&lt;T&gt; &#123; public static final int initialSize = 16; Object[] array = new Object[initialSize]; T[] myArray = (T[]) array; int size = 0; // 数组长度 // 构造器 public MyArrayList() &#123; &#125; // 删除全部元素 public void clear() &#123; array = new Object[initialSize]; myArray = (T[]) array; size = 0; &#125; // 检测数组空间是否充足 public void ensureCapacity() &#123; if (size &gt; (int) (myArray.length / 2)) &#123; Object[] newArray = new Object[array.length * 2]; T[] newMyArray = (T[]) newArray; System.arraycopy(array, 0, newMyArray, 0, myArray.length); myArray = newMyArray; // 新数组的引用赋值给原数组变量名，原数组的堆中的存储空间失去引用，交给垃圾回收处理 &#125; &#125; // 在末尾增加元素 public void add(T data) &#123; ensureCapacity(); myArray[size] = data; size++; &#125; // 在特定位置增加元素 public void add(T data, int index) &#123; ensureCapacity(); T temp = null; for (int i = index; i &lt; myArray.length; i++) &#123; temp = myArray[i]; myArray[i] = data; data = temp; &#125; size++; &#125; // 检测是否存在元素 public boolean contains(T data) &#123; for (int i = 0; i &lt; size; i++) &#123; if (myArray[i].equals(data)) &#123; return true; &#125; &#125; return false; &#125; // 获取特定元素 public T get(int index) &#123; return myArray[index]; &#125; // 获取特定元素的索引值 public int indexOf(T data) &#123; for (int i = 0; i &lt; size; i++) &#123; if (myArray[i].equals(data)) &#123; return i; &#125; &#125; return -1; &#125; //获取元素最后一次出现的索引值 public int lastIndexOf(T data)&#123; int index = 0; for(int i = 0; i &lt; size; i++)&#123; if (myArray[i].equals(data)) &#123; index = i; &#125; &#125; return index; &#125; // 判断是否为空 public boolean isEmpty() &#123; return size == 0; &#125; // 移除特定索引的元素 public void remove(int index)&#123; if(index&lt;size)&#123; for(int i =index+1; i&lt;size; i++)&#123; myArray[i-1]=myArray[i]; &#125; &#125; size--; &#125; //移除特定元素 public void remove(T data)&#123; int index = 0; boolean match = false; for(int i =0; i&lt;size; i++)&#123; if(myArray[i].equals(data))&#123; index = i; match = true; break; &#125; &#125; if(!match)&#123; for(int i =index+1; i&lt;size; i++)&#123; myArray[i-1]=myArray[i]; &#125; &#125; size--; &#125; //替换对应元素 public void set(T data, int index)&#123; if(index&lt;size)&#123; myArray[index] = data; &#125; &#125; //显示全部元素 public void displayAll()&#123; for(int i =0; i&lt;size; i++)&#123; System.out.print(myArray[i]+" "); &#125; System.out.print("\n"); &#125;&#125; MyArrayListTest 测试类 1234567891011121314151617181920212223242526272829303132333435363738394041424344package arraylisttest;public class MyArrayListTest &#123; public static void main(String[] args) &#123; MyArrayList&lt;String&gt; list = new MyArrayList&lt;String&gt;(); list.add("111"); list.add("222"); list.add("333"); list.displayAll(); list.add("test", 1); list.displayAll(); list.clear(); System.out.println(list.isEmpty()); //true System.out.println("----------"); list.add("aaa"); list.add("bbb"); list.add("aaa"); list.add("ccc"); list.add("eee"); list.add("ddd"); System.out.println(list.contains("ccc")); //true System.out.println(list.contains("sss")); //false System.out.println(list.get(2)); //aaa System.out.println(list.indexOf("aaa")); //0 System.out.println(list.lastIndexOf("aaa")); //2 System.out.println(list.indexOf("ddd")); //5 System.out.println(list.isEmpty()); //false System.out.println("----------"); list.displayAll(); list.remove(1); list.remove("ddd"); list.displayAll(); System.out.println("----------"); list.set("bbb",1); list.displayAll(); System.out.println("----------"); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java LinkedList的实现]]></title>
    <url>%2F2015%2F11%2F03%2F2015-11-3-java-LinkedList%2F</url>
    <content type="text"><![CDATA[引言 Java中，LinkedList是重要的数据结构； LinkedList用链表实现，每个节点不仅保存本节点的数据，还保存下个节点的引用； 本文实现了一个简单的LinkedList； LinkedList具体实现 Node类，定义节点 1234567891011121314package linkedtest;public class Node&lt;T&gt; &#123; protected Node&lt;T&gt; next; protected T data; public Node(T data) &#123; this.data = data; &#125; public void display() &#123; System.out.println(data + " "); &#125;&#125; MyLinkedList 具体实现类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222package linkedtest;public class MyLinkedList&lt;T&gt; &#123; protected Node&lt;T&gt; first; // 存储首元素 protected Node&lt;T&gt; last; // 存储末尾元素 protected int point = 0; // 存储当前指针 protected int size = 0; // 存储链表大小 // 构造器 public MyLinkedList() &#123; &#125; // 清空链表 public void clear() &#123; first = null; last = null; point = 0; size = 0; &#125; // 添加元素到末尾 public void add(T data) &#123; Node&lt;T&gt; node = new Node&lt;T&gt;(data); if (size == 0) &#123; first = node; first.next = null; last = node; last.next = null; size++; &#125; else &#123; last.next = node; last = node; size++; &#125; &#125; // 添加元素到特定位置 public void add(T data, int index) &#123; Node&lt;T&gt; node = new Node&lt;T&gt;(data); point = 0; Node&lt;T&gt; previous = first; Node&lt;T&gt; current = first; while (point != index) &#123; previous = current; current = current.next; point++; &#125; previous.next = node; node.next = current; size++; &#125; // 添加元素到list首部 public void addFirst(T data) &#123; Node&lt;T&gt; node = new Node&lt;T&gt;(data); node.next = first; first = node; size++; &#125; // 是否包含元素 public boolean contains(T data) &#123; point = 0; Node&lt;T&gt; previous = first; Node&lt;T&gt; current = first; while (point &lt; size) &#123; if (current.data.equals(data)) &#123; return true; &#125; previous = current; current = current.next; point++; &#125; return false; &#125; // 获取特定位置元素 public T get(int index) &#123; if (index &gt;= size) &#123; return null; &#125; point = 0; Node&lt;T&gt; previous = first; Node&lt;T&gt; current = first; while (point != index) &#123; previous = current; current = current.next; point++; &#125; return current.data; &#125; // 获取首元素 public T getFirst() &#123; return first.data; &#125; // 获取尾元素 public T getLast() &#123; return last.data; &#125; // 获取元素位置 public int indexOf(T data) &#123; point = 0; Node&lt;T&gt; previous = first; Node&lt;T&gt; current = first; while (point &lt; size) &#123; if (current.data.equals(data)) &#123; return point; &#125; previous = current; current = current.next; point++; &#125; return -1; &#125; // 反向获取元素位置 public int lastIndexOf(T data) &#123; int size1 = size; int point1 = 0; while (size1 &gt; 0) &#123; Node&lt;T&gt; previous = first; Node&lt;T&gt; current = first; while (point1 &lt; size1 - 1) &#123; previous = current; current = current.next; point1++; &#125; if (current.data.equals(data)) &#123; return size1 - 1; &#125; else &#123; size1--; point1 = 0; &#125; &#125; return -1; &#125; // 删除特定位置元素 public void remove(int index) &#123; point = 0; Node&lt;T&gt; previous = first; Node&lt;T&gt; current = first; while (point &lt; size) &#123; if (point == index) &#123; previous.next = current.next; break; &#125; previous = current; current = current.next; point++; &#125; size--; &#125; // 删除特定元素 public void remove(T data) &#123; point = 0; Node&lt;T&gt; previous = first; Node&lt;T&gt; current = first; while (point &lt; size) &#123; if (current.data.equals(data)) &#123; previous.next = current.next; break; &#125; previous = current; current = current.next; point++; &#125; size--; &#125; // 删除第一个元素 public void removeFirst() &#123; first = first.next; size--; &#125; // 删除最后一个元素 public void removeLast() &#123; point = 0; Node&lt;T&gt; previous = first; Node&lt;T&gt; current = first; while (point &lt; size) &#123; previous = current; current = current.next; if (point == size - 1) &#123; last = previous; last.next = null; break; &#125; point++; &#125; size--; &#125; // 是否为空 public boolean isEmpty() &#123; return size == 0; &#125; //返回list大小 public int size()&#123; return size; &#125; //遍历输出list public void displayAll()&#123; point = 0; Node&lt;T&gt; node = first; while(point&lt;size)&#123; node.display(); node = node.next; point++; &#125; &#125;&#125; TestMyLinkedList 测试类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package linkedtest;public class TestMyLinkedList &#123; public static void main(String[] args) &#123; MyLinkedList&lt;String&gt; mlist = new MyLinkedList&lt;String&gt;(); mlist.add("111"); mlist.add("222"); mlist.displayAll(); System.out.println("------------"); mlist.clear(); mlist.add("aaa"); mlist.add("bbb"); mlist.add("ddd"); mlist.add("ccc"); mlist.add("aaa"); mlist.add("eee"); mlist.displayAll(); System.out.println("------------"); mlist.add("sss", 3); mlist.displayAll(); System.out.println("------------"); mlist.addFirst("000"); mlist.displayAll(); System.out.println(mlist.size()); //8 System.out.println("------------"); System.out.println(mlist.contains("bbb")); //true System.out.println(mlist.get(0)); //000 System.out.println(mlist.get(1)); //aaa System.out.println(mlist.get(5)); //ccc System.out.println(mlist.get(8)); //null System.out.println(mlist.getFirst()); //000 System.out.println(mlist.getLast()); //eee System.out.println(mlist.indexOf("sss")); //4 System.out.println(mlist.indexOf("aaa")); //1 System.out.println(mlist.lastIndexOf("aaa")); //6 System.out.println("------------"); mlist.remove(2); System.out.println(mlist.size()); mlist.remove("ddd"); System.out.println(mlist.size()); mlist.displayAll(); System.out.println("------------"); mlist.removeFirst(); mlist.removeLast(); mlist.displayAll(); System.out.println("------------"); System.out.println(mlist.isEmpty()); //false System.out.println(mlist.size()); //4 &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript字符串操作]]></title>
    <url>%2F2015%2F11%2F02%2F2015-11-2-js-string%2F</url>
    <content type="text"><![CDATA[引言 字符串操作是js中常见的操作； 本文总结了js中常见的字符串操作； 常见字符串操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657var str1 = "aaa";var str2 = "bbb";var str3 = "ccc";var str4 = "aaabbbccc";var str5="Hello world!"//字符串长度document.write(str1.length +"&lt;br&gt;")//大小写转换document.write(str5.toLowerCase() +"&lt;br&gt;") //hello world!document.write(str5.toUpperCase() +"&lt;br&gt;") //HELLO WORLD!//连接两个字符串document.write(str1.concat(str2) +"&lt;br&gt;") //aaabbb//返回字符串中一个子串第一处出现的索引。如果没有匹配项，返回 -1 document.write(str4.indexOf("b") +"&lt;br&gt;") // 3document.write(str4.indexOf("c") +"&lt;br&gt;") // 6document.write(str4.indexOf("ab") +"&lt;br&gt;") // 2//返回字符串中一个子串最后一处出现的索引，如果没有匹配项，返回 -1document.write(str4.lastIndexOf("b") +"&lt;br&gt;") // 5//返回指定位置的字符document.write(str4.charAt(2) +"&lt;br&gt;") // adocument.write(str4.charAt(7) +"&lt;br&gt;") // c//使用 match() 来检索一个字符串document.write(str5.match("world") + "&lt;br /&gt;") // worlddocument.write(str5.match("World") + "&lt;br /&gt;") // nulldocument.write(str5.match("worlld") + "&lt;br /&gt;") // nulldocument.write(str5.match("world!") + "&lt;br /&gt;") // world!//使用 match() 来检索一个正则表达式的匹配document.write(str4.match(/a*b/) + "&lt;br /&gt;") // aaab//返回字符串的一个子串,传入参数是起始位置和结束位置document.write(str4.substring(0,5) + "&lt;br /&gt;") //aaabb//slice() 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分//stringObject.slice(start,end)document.write(str4.slice(1,4) + "&lt;br /&gt;") // aab//替换部分字符串，stringObject.replace(regexp/substr,replacement)document.write(str4.replace("aaab","ccc") + "&lt;br /&gt;") //cccbbcccdocument.write(str4.replace(/a*b/,"ccc") + "&lt;br /&gt;") //cccbbccc//search() 方法用于检索字符串中指定的子字符串,或检索与正则表达式相匹配的子字符串//stringObject.search(regexp)document.write(str4.search(/a*b/) + "&lt;br /&gt;") // 0document.write(str4.search(/b*c/) + "&lt;br /&gt;") // 3document.write(str4.search(/.*d/) + "&lt;br /&gt;") // -1(无匹配)//通过将字符串划分成子串，将一个字符串做成一个字符串数组document.write(str5.split(" ")[0] + "&lt;br /&gt;") //Hellodocument.write(str5.split(" ")[1] + "&lt;br /&gt;") //world!]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java堆内存和栈内存]]></title>
    <url>%2F2015%2F10%2F31%2Fjava-memory%2F</url>
    <content type="text"><![CDATA[JVM运行时数据区 程序计数器：存放线程执行位置（main函数也是一个线程）； 虚拟机栈（栈内存）： 生命周期和对应的线程相同，存放该线程的局部变量、对象的引用； 方法中可能嵌套调用别的方法，这些方法的变量以”先进后出、后进先出“的方式在栈内存中存储，所以内层方法无法访问外层方法的变量（他们在栈底），执行外层方法时内层方法的变量已经弹出栈消失了，所以外层方法也不会访问到内层方法的变量； 一个方法的执行过程，就是这个方法对于帧栈的入栈出栈过程； 本地方法栈： 作用和虚拟机栈完全相同； 虚拟机栈对应普通的java方法，本地方法栈对应native方法； native方法是一个java调用非java代码的接口； 方法区： JVM内存管理中最大一块； 存储常量（final修饰）、类变量/成员变量（static修饰）、类信息（每个类的访问控制符、修饰符、继承关系等）； 堆内存：JVM启动时创建，存放对象本身，不存放对对象的引用（引用存在栈内存）； 堆内存和栈内存的区别 变量存在栈内存中（无论是static类变量还是对象的变量），已经不在其作用域中的对象要及时弹出栈； new出来的对象或实例，它的名称存在栈内存中，实体存在堆内存中，名称通过实体在堆内存的地址引用实体； 垃圾回收的目标是堆内存中失去引用的对象实体； 栈内存一般是用物理一级缓存实现，堆内存一般是用物理二级缓存实现，栈内存存取速度快于堆内存，代码本身存储在磁盘中，和堆栈内存无关； 堆主要用来存放对象的，栈主要是用来执行程序的； 每个线程有自己的栈内存（栈内存是线程私有的），在一个JVM实例中（一个java应用对应一个JVM实例），堆内存只有一个（堆内存是线程共享的）； 在java中： 基本数据类型（int, short, long, byte, float, double, boolean, char），他们存储在栈内存中，函数调用它们的时候是”传值”； 复杂数据类型（数组, 对象, map, List, Set等），他们的实体存储在堆内存中，栈内存中只存储他们的对象的名称、通过堆内存的地址引用实体对象，函数调用它们的时候是”传引用地址”；]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同源策略详解]]></title>
    <url>%2F2015%2F10%2F30%2Fcross-domain%2F</url>
    <content type="text"><![CDATA[什么是同源策略 同源策略是Netscape提出的一个著名的安全策略； 同源策略是浏览器最核心最基础的安全策略； 现在所有的可支持javascript的浏览器都会使用这个策略； web构建在同源策略基础之上，浏览器对非同源脚本的限制措施是对同源策略的具体实现； 本文详细说明了同源策略的含义，用具体的例子让您深入理解同源策略，并且对跨域访问的几种常用机制作了说明； 同源策略的含义详解 含义一（DOM层面的同源策略）： 限制了来自不同源的”document”对象或js脚本，对当前“document”对象的读取或设置某些属性； 含义二（Cookie和XMLHttprequest层面的同源策略）： 只有和本网页同源的脚本才会被执行，有时，AJAX已经加载不同源的脚本，但绝对不会被执行； 含义三（同源策略的非绝对性）： 同源策略通常允许进行跨域写操作、通常允许跨域资源嵌入、通常不允许跨域读操作； &lt;script&gt;&lt;img&gt;&lt;iframe&gt;&lt;link&gt;&lt;video&gt;&lt;audio&gt;等带有src属性的标签可以从不同的域加载和执行资源，同源策略关注的是加载js的页面所在的域，而不是页面内存放的js文件的域； 含义四（其他插件的同源策略）： flash、java applet、silverlight、googlegears等浏览器加载的第三方插件也有各自的同源策略，只是这些同源策略不属于浏览器原生的同源策略，如果有漏洞则可能被黑客利用，从而留下XSS攻击的后患； 几个同源策略常见问题 没有同源策略会怎样？为什么同源策略禁止跨域读操作？ 设想你打开了一个银行网站，又打开了一个恶意网站，如果没有同源策略，将会： 恶意网站包含了脚本a.js，银行网站在没有加载此脚本的情况下，就可以被此脚本操纵，操纵的后果是： 银行网站页面DOM结构被篡改； 银行网站页面DOM元素的属性和值被篡改； 银行页面发送的表单信息可能被恶意脚本接收到，造成用户名密码泄漏； 恶意网站通过自己加载的恶意js脚本获取了银行网站用户的cookie信息，并将它发送给了银行网站，随后，恶意网站就可以自动的、不受用户限制的、在用户不知情的情况下登录用户的银行网站并且伪装用户发送转账等请求； 有了同源策略会怎样？ 浏览器在执行一个js脚本（或其他脚本）前，需要对这个脚本进行同源检测，如果加载这个脚本的页面和当前页面不同源，浏览器将拒绝执行此脚本； 注意，浏览器并不关心js脚本来自何方（不关心js脚本从哪个域名、哪个”源”加载），它只关心加载脚本的那个页面是否和当前页面同源； 为什么&lt;script&gt;&lt;img&gt;&lt;iframe&gt;&lt;link&gt;&lt;video&gt;&lt;audio&gt;等带有src属性的标签可以不遵守同源策略/为什么同源策略允许跨域嵌入： 现在很多大型网站的js脚本、图片等都不是存放在存储网站页面的那台服务器上，他们很可能通过CDN等方式传送到浏览器端，如果限制他们必须和网站页面同源，无异于自己束缚手脚； 一个网站要加载哪些脚本，由网站的编写人员说了算，他们不会故意加载恶意脚本（比如银行网站的编写人员不会将恶意网站的脚本写在银行网站中），所以只要是写在网页中的脚本，我们认为它是安全的； 所以，a.com的网页中可以写&lt;script src=&quot;b.js&quot;&gt;&lt;/script&gt;，a网站加载了b网站的脚本，这是完全可以的，不受任何限制；可以这样认为，只要是页面加载的脚本，都和页面同源，无论这个脚本来自哪个”源”（source）； 为什么同源策略允许跨域写操作？ 和上面一条理解相同； 比如提交表单这个写操作，表单不一定提交到提供网页页面的网站，很有可能提交到专门处理表单的服务器，如果不允许跨域写，将是很不灵活的； 表单提交到什么地方，是编写页面时程序员决定，程序员不可能故意写一个恶意域名进去，所以写操作通常是安全的； “同源”的具体含义? 网站的同源：域名、协议、端口有一个不同就不是同源，三者均相同，这两个网站才是同源； js脚本的同源：处于同源网站上的js脚本同源，否则不同源； 浏览器沙箱机制： 纵向上，浏览器的不同标签页分属不同的进程，进程间不能相互访问内存； 横向上，浏览器进程、渲染进程、插件进程、扩展进程相互隔离，他们可以相互通信，但要经过严格的安全检测； 浏览器的沙箱机制是从内存管理的角度设计的安全措施，是对同源策略的补充，进一步提升浏览器安全性； 几种跨域访问策略和原理 document.domain 浏览器在检测是否同源时肯定要检测域名是否相同，它是通过document.domain属性来获取当前页面域名的； document.domain属性不能随便更改，但可以通过js将document.domain属性设置为当前document.domain属性值的后缀； 例如，假设在 http://store.company.com/dir/other.html中的一个脚本执行了下列语句document.domain = &quot;company.com&quot;，这条语句执行之后，浏览器将会成功地通过对http://company.com/dir/page.html的同源检测，但不能设置 document.domain为othercompany.com.； 如果需要跨域访问的网站和本网站端口、协议均相同，只有域名不同，而且需要跨域访问的网站的域名是本网站的后缀，则可以使用document.domain暂时更改当前document对象的域名值，实现跨域访问； 此种跨域访问限制颇多，空间上，只能跨域访问协议、端口相同的且域名是本网站后缀的网站，时间上，一旦原网站重新刷新页面，document.domain值恢复原状，不能继续跨域访问，所以这种跨域访问策略只能算是局部的、暂时的、基础域名相同的网站间的跨域访问； window.name 浏览器一个窗口（标签页）的window.name属性在时间上是全局的，无论一个窗口中的页面如何跳转，window.name属性不变; 可以看到，如果在一个标签里面跳转网页的话，我们的 window.name 是不会改变的； 由于安全原因，浏览器始终会保持 window.name 是string类型； window.name比document.domain更强大，可以从任意页面获取string类型的数据； JSONP JSONP是一种依靠开发人员的聪明才智创造出的一种非官方跨域数据交互协议； JSONP本质是利用了&lt;script&gt;&lt;img&gt;&lt;iframe&gt;等标签可跨预加载脚本的特性实现数据跨域传输； 本地的js代码将需要请求的数据包装好（如需要某天的某次航班的飞机票数据），发送到远端js，远端js依据本地js提供的信息获取相应的数据传回到本地js； JSONP 的理念就是，我和服务端约定好一个函数名，当我请求文件的时候，服务端返回一段 JavaScript，这段 JavaScript 调用了我们约定好的函数，并且将数据当做参数传入； postMessage postMessage()方法允许来自不同源的脚本（无视协议，端口，域名的不同）采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递； postMessage(data,origin)方法接受两个参数： data:要传递的数据，html5规范中提到该参数可以是JavaScript的任意基本类型或可复制的对象，然而并不是所有浏览器都做到了这点儿，部分浏览器只能处理字符串参数，所以我们在传递参数的时候需要使用JSON.stringify()方法对对象参数序列化，在低版本IE中引用json2.js可以实现类似效果； origin：字符串参数，指明目标窗口的源，协议+主机+端口号[+URL]，URL会被忽略，所以可以不写，这个参数是为了安全考虑，postMessage()方法只会将message传递给指定窗口，当然如果愿意也可以建参数设置为”*”，这样可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“； 对于跨域访问的说明： 对于不同的浏览器、不同的业务类型、不同的安全等级、不同的实际情况，对下述内容的管制也不相同，有的允许有的禁止：跨域写、跨域嵌入、跨域读、跨域API接口访问、跨域数据存储（DB）访问、跨域授权情况； 其他的跨域访问机制：CORS(允许一个域上的网络应用向另一个域提交跨域AJAX请求)、OAuth(跨域授权)； 严格的同源策略限制所有的跨域读写、跨域访问和跨域资源嵌入，虽然保证了安全性，但是对于大型网站来说，强迫他们把一个网站的所有功能放在一个域名下，降低了效率和网站的可扩展性； 所以现有的同源策略、跨域访问策略是在效率和安全性之间做出的最佳权衡；]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 文件压缩和解压]]></title>
    <url>%2F2015%2F10%2F28%2Fjava-zip%2F</url>
    <content type="text"><![CDATA[引言 文件压缩和解压是常见的操作 本文重点总结了java中文件压缩和解压的方法 方法一 zip格式，不支持中文 压缩： 1234567891011121314151617181920212223242526272829303132333435363738import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.util.zip.ZipEntry;import java.util.zip.ZipOutputStream;public class App &#123; public static void main( String[] args ) &#123; byte[] buffer = new byte[1024]; try&#123; FileOutputStream fos = new FileOutputStream("C:\\MyFile.zip"); ZipOutputStream zos = new ZipOutputStream(fos); ZipEntry ze= new ZipEntry("spy.log"); zos.putNextEntry(ze); FileInputStream in = new FileInputStream("C:\\spy.log"); int len; while ((len = in.read(buffer)) &gt; 0) &#123; zos.write(buffer, 0, len); &#125; in.close(); zos.closeEntry(); //remember close it zos.close(); System.out.println("Done"); &#125;catch(IOException ex)&#123; ex.printStackTrace(); &#125; &#125;&#125; 解压 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.util.List;import java.util.zip.ZipEntry;import java.util.zip.ZipInputStream;public class UnZip&#123; List&lt;String&gt; fileList; private static final String INPUT_ZIP_FILE = "C:\\MyFile.zip"; private static final String OUTPUT_FOLDER = "C:\\outputzip"; public static void main( String[] args ) &#123; UnZip unZip = new UnZip(); unZip.unZipIt(INPUT_ZIP_FILE,OUTPUT_FOLDER); &#125; /** * Unzip it * @param zipFile input zip file * @param output zip file output folder */ public void unZipIt(String zipFile, String outputFolder)&#123; byte[] buffer = new byte[1024]; try&#123; //create output directory is not exists File folder = new File(OUTPUT_FOLDER); if(!folder.exists())&#123; folder.mkdir(); &#125; //get the zip file content ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile)); //get the zipped file list entry ZipEntry ze = zis.getNextEntry(); while(ze!=null)&#123; String fileName = ze.getName(); File newFile = new File(outputFolder + File.separator + fileName); System.out.println("file unzip : "+ newFile.getAbsoluteFile()); //create all non exists folders //else you will hit FileNotFoundException for compressed folder new File(newFile.getParent()).mkdirs(); FileOutputStream fos = new FileOutputStream(newFile); int len; while ((len = zis.read(buffer)) &gt; 0) &#123; fos.write(buffer, 0, len); &#125; fos.close(); ze = zis.getNextEntry(); &#125; zis.closeEntry(); zis.close(); System.out.println("Done"); &#125;catch(IOException ex)&#123; ex.printStackTrace(); &#125; &#125; &#125; 方法二 GBK编码，支持中文，zip格式 压缩 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.nio.charset.Charset; import java.util.zip.ZipEntry; import java.util.zip.ZipOutputStream; public class zip &#123; public static void main(String args[]) throws IOException &#123; File inFile = new File("D:\\test.txt"); ZipOutputStream zos = new ZipOutputStream(new FileOutputStream("D:\\test.zip"), Charset.forName("GBK")); zos.setComment("ziped by Ming Cheng."); zipFile(inFile, zos, ""); zos.close(); &#125; public static void zipFile(File inFile, ZipOutputStream zos, String dir) throws IOException &#123; if (inFile.isDirectory()) &#123; File[] files = inFile.listFiles(); for (File file:files) zipFile(file, zos, dir + "\\" + inFile.getName()); &#125; else &#123; String entryName = null; if (!"".equals(dir)) entryName = dir + "\\" + inFile.getName(); else entryName = inFile.getName(); ZipEntry entry = new ZipEntry(entryName); zos.putNextEntry(entry); InputStream is = new FileInputStream(inFile); int len = 0; while ((len = is.read()) != -1) zos.write(len); is.close(); &#125; &#125; &#125; 解压 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.nio.charset.Charset; import java.util.zip.ZipEntry; import java.util.zip.ZipFile; import java.util.zip.ZipInputStream; public class Unzip &#123; public static void main(String args[]) throws IOException &#123; File file = new File("D:\\test.zip"); ZipFile zipFile = new ZipFile(file, Charset.forName("GBK")); ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(file), Charset.forName("GBK")); unpack(zipFile, zipInputStream); &#125; public static void unpack(ZipFile zipFile, ZipInputStream zipInputStream) throws IOException &#123; ZipEntry zipEntry = null; while ((zipEntry = zipInputStream.getNextEntry()) != null) &#123; String fileName = zipEntry.getName(); File temp = new File("D:\\Test\\" + fileName); if (! temp.getParentFile().exists()) temp.getParentFile().mkdirs(); OutputStream os = new FileOutputStream(temp); InputStream is = zipFile.getInputStream(zipEntry); int len = 0; System.out.println(zipEntry.getName()); while ((len = is.read()) != -1) os.write(len); os.close(); is.close(); &#125; zipInputStream.close(); &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 数学函数汇总]]></title>
    <url>%2F2015%2F10%2F27%2Fjs-math%2F</url>
    <content type="text"><![CDATA[引言 javascript中数学函数十分强大，能够帮助我们完成大多数常用的数学计算任务； 本文汇总了这些常用的数学函数； 基本计算 科学计算 实用技巧 快速得出number数组的最大最小值： 12345function math()&#123; var a = [3,1,2,6]; var max = Math.max.apply(Math,a); var min = Math.min.apply(Math,a);&#125; 获取n-m之间的随机数（包含n和m） 123function math()&#123; var num = Math.floor(Math.random()*m + n);&#125;]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 数组操作总结]]></title>
    <url>%2F2015%2F10%2F27%2Fjs-array%2F</url>
    <content type="text"><![CDATA[引言 数组是javascript中的重要数据结构，可以存储各种数据类型，有很多重要的操作必须牢记； 本文系统总结了javascript数组的各种常见操作，欢迎补充！ javascript数组需要掌握的方法 push、pop shift、unshift splice、slice concat、join、sort、reverse 这些方法在下面会详细介绍 数组的定义123456789101112131415161718//方法一，定义后赋值var arr = new Array();arr[0] = 123arr[1] = "abc"arr[5] = falsealert(arr[3]) //undefined//方法二，定义数组长度var arr2 = new Array(2);arr2[0] = "ddd";arr2[1] = 123;arr2[4] = false; //数组长度自动扩展//方法三，定义时赋值var arr3 = new Array(true,123,"aaa");//方法四，直接赋值var arr4 = ["aaa",111,false]; 数组的判断12345var arr = new Array();Array.isArray(arr); //truearr instanceof Array; //truearr.constructor === Array; //true 数组元素的合并123var arr = ['c','b','d'];document.write(arr.join()); //c,b,ddocument.write(arr.join(".")); //c.b.d 数组的属性 length属性 1234var arr = ['c','b','d'];alert(arr.length); //3arr.length = 10; // 数组自动扩展arr.length = 2; //arr[2]丢失 prototype属性 1234567891011121314function max()&#123; var i, max = this[0]; for(i=1; i&lt;this.length; i++)&#123; if(max&lt;this[i])&#123; max = this[i]; &#125; &#125; return max;&#125;Array.prototype.max = max;var x = new Array(1,3,2,4,3,5);alert(x.max()); // 5 数组常见操作 添加元素 1234var arr = [1,2,"aaa",false];arr.push(3); //添加到末尾arr.unshift('c'); //添加到开头，其余元素后移arr.splice(1,0,'d'); //插入到数组下表为1的位置，并且有0个元素被吃掉 删除元素 12345var arr = [1,2,"aaa",false];arr.pop(); //移除最后一个元素arr.shift(); //移除最前面的元素并返回该元素的值arr.splice(1,1); //移除下标为1开始的1个元素delete arr[2]; //移除下标为2的元素 移除特定元素 12345678var arr = ['a','b','c','d'];var index = null;for(var i =0; i&lt;arr.length; i++)&#123; if(arr[i]=='c')&#123; index = i; &#125;&#125;arr.splice(index,1); 截取数组 12var arr = ['a','b','c','d','e'];arr.slice(1,3); // ['b','c'] 连接数组 123var arr = ['a','b','c','d','e'];var arr2 = ['f','g'];arr.concat(arr2); // ['a','b','c','d','e','f','g'] 拷贝数组 12var arr = ['a','b','c','d','e'];var arr2 = arr.concat(); 数组排序 12var arr = ['e','b','a','d','c'];alert(arr.sort()); // a b c d e 数组倒序 12var arr = ['e','b','a','d','c'];alert(arr.reverse()); // e d c b a 判断数组是否包含特定值 123var arr = ['e','b','a','d','c'];alert(arr.indexOf('d')); // 3alert(arr.indexOf('g')); // -1 求number数组最大最小值 12345function math()&#123; var a = [3,1,2,6]; var max = Math.max.apply(Math,a); var min = Math.min.apply(Math,a);&#125; 数组去重 方法一： 利用数组的indexOf方法 12345678function unique (arr) &#123; var result = []; for (var i = 0; i &lt; arr.length; i++) &#123; if (result.indexOf(arr[i]) == -1) result.push(arr[i]); &#125; return result;&#125; 方法二： 利用hash表 可能会出现字符串和数字一样的话出错，如var a = [1, 2, 3, 4, ‘3’, 5],会返回[1, 2, 3, 4, 5] 12345678910111213function unique (arr)&#123; var hash = &#123;&#125;,result = []; for(var i = 0; i &lt; arr.length; i++) &#123; if (!hash[arr[i]]) &#123; hash[arr[i]] = true; result.push(arr[i]); &#125; &#125; return result;&#125; 方法三： 排序后比较相邻，如果一样则放弃，否则加入到result 会出现与方法2一样的问题，如果数组中存在1,1,’1’这样的情况，则会排错 12345678910function unique (arr) &#123; arr.sort(); var result=[arr[0]]; for(var i = 1; i &lt; arr.length; i++)&#123; if( arr[i] !== arr[i-1]) &#123; result.push(arr[i]); &#125; &#125; return result;&#125; 方法四： 最简单但是效率最低的算法,也不会出现方法2和方法3出现的bug 12345678910111213141516function unique (arr) &#123; if(arr.length == 0) return; var result = [arr[0]], isRepeate; for( var i = 0, j = arr.length; i &lt; j; i++ )&#123; isRepeate = false; for( var k = 0, h = result.length; k &lt; h; k++)&#123; if(result[k] === arr[i])&#123; isRepeate = true; break; &#125; if(k == h) break; &#125; if( !isRepeate ) result.push(arr[i]); &#125; return result;&#125; 数组随机扰乱 方法一： 每次随机抽一个数并移动到新数组中 12345678910111213141516function shuffle(array) &#123; var copy = [], n = array.length, i; // 如果还剩有元素则继续。。。 while (n) &#123; // 随机抽取一个元素 i = Math.floor(Math.random() * array.length); // 如果这个元素之前没有被选中过。。 if (i in array) &#123; copy.push(array[i]); delete array[i]; n--; &#125; &#125;&#125; 方法二： 跟方法1类似，只不过通过splice来去掉原数组已选项 12345678910111213function shuffle(array) &#123; var copy = [], n = array.length, i; // 如果还剩有元素。。 while (n) &#123; // 随机选取一个元素 i = Math.floor(Math.random() * n--); // 移动到新数组中 copy.push(array.splice(i, 1)[0]); &#125; return copy;&#125; 方法三： 前面随机抽数依次跟末尾的数交换，后面依次前移 即：第一次前n个数随机抽一个跟第n个交换，第二次前n-1个数跟第n-1个交换，依次类推 1234567891011121314function shuffle(array) &#123; var m = array.length, t, i; // 如果还剩有元素… while (m) &#123; // 随机选取一个元素… i = Math.floor(Math.random() * m--); // 与当前元素进行交换 t = array[m]; array[m] = array[i]; array[i] = t; &#125; return array;&#125; 数组间操作 数组求交集 1234//利用filter和数组自带的indexOf方法array1.filter(function(n) &#123; return array2.indexOf(n) != -1&#125;); 数组求并集 1234567891011//方法原理：连接两个数组并去重function arrayUnique(array) &#123; var a = array.concat(); for(var i=0; i&lt;a.length; ++i) &#123; for(var j=i+1; j&lt;a.length; ++j) &#123; if(a[i] === a[j]) a.splice(j--, 1); &#125; &#125; return a;&#125;; 数组求差集 1234//利用filter和indexOf方法Array.prototype.diff = function(a) &#123; return this.filter(function(i) &#123;return a.indexOf(i) &lt; 0;&#125;);&#125;;]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 函数解析]]></title>
    <url>%2F2015%2F10%2F26%2Fjs-function%2F</url>
    <content type="text"><![CDATA[引言 javascript中，函数是重要的机制，可以避免页面载入时执行该脚本，这些代码只能被事件激活，或者在函数被调用时才会执行； 本文总结了javascript函数的定义和调用方法，以供参考； javascript函数的定义 直接定义函数： 123function test()&#123; alert("...");&#125; 通过函数字面量定义 123var func = function(x)&#123; alert(x);&#125; 通过构造函数定义： 12var x = 1var func2 = new Function(x,alert(x)); javascript函数的调用 直接通过函数名调用： 123456function test()&#123; alert("...");&#125;test(); window.onload = test(); 通过变量调用： 123456function test()&#123; alert("...");&#125;var fun = test; fun(); 下面两种方法可让函数自动执行 1234567(function test()&#123; alert("...");&#125;)()(function test()&#123; alert("...");&#125;()) 下面的代码会发生错误，请注意括号 123function test()&#123; //error alert("...");&#125;()]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 闭包详解]]></title>
    <url>%2F2015%2F10%2F26%2Fjs-Closure%2F</url>
    <content type="text"><![CDATA[js变量作用域 变量的作用域无非就是两种：全局变量和局部变量； Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量： 12345var n=999; function f1()&#123; alert(n); &#125;f1(); // 999 但是，在函数外部自然无法读取函数内的局部变量： 1234function f1()&#123; var n=999; &#125;alert(n); // error 除非不用var声明： 12345function f1()&#123; n=999; &#125; f1();alert(n); // 999 总之，js中作用域是链式的，内部可获取外部变量，反之不行； 如果函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的，但是反过来就不行，f2内部的局部变量，对f1就是不可见的； 既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗； 这种打破常规，实现在函数外部访问函数私有变量的机制叫做闭包； js什么时候进行垃圾回收？ 在javascript中，如果一个对象不再被引用，那么这个对象就会被GC回收； 如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收； 闭包（Closure）的定义 闭包就是能够读取其他函数内部变量的函数； 由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”； 在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁； 闭包的深入理解看下面程序： 123456789101112function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2;&#125;var result=f1();result(); // 999nAdd();result(); // 1000 result实际上就是闭包f2函数，它一共运行了两次，第一次的值是999，第二次的值是1000，这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除； 原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中（不满足上面任何一条垃圾回收条件），而f2的存在依赖于f1，因此f1也始终在内存中（不满足上面任何一条垃圾回收条件），不会在调用结束后被垃圾回收机制（garbage collection）回收； 这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行； 首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量； 其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作； 使用闭包需要注意 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露,解决方法是，在退出函数之前，将不使用的局部变量全部删除； 闭包会在父函数外部，改变父函数内部变量的值，所以如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值； 本文参考：学习Javascript闭包（Closure）]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中this关键字详解]]></title>
    <url>%2F2015%2F10%2F25%2Fjs-this%2F</url>
    <content type="text"><![CDATA[引言 js中，this关键是令人头疼的问题，它的指代对象和this所处的上下文环境、函数调用者等多重因素有关； 我们要解决的问题是，this关键字代指哪个对象； 本文用丰富的实例让您清晰、明确的判断各种情况下，this关键字所指代的对象； 判断原则： 原则一：this指的是直接调用函数的那个对象，没有的话就值window； 原则二：this代指的对象就是它使用的时候（不是定义的时候）所处的环境的上下文； 原则三：当new关键字出现时，this指代new出来的那个对象； this是js关键字，某些程序中出现的that仅仅是普通的变量，不是关键字； 下面，我们用实例说话，一一验证上述原则； 无对象调用函数时this指代window的例子 例一： 123456function test()&#123; this.x = 1; alert(this.x);&#125;test(); //1alert(x); //1 例二： 12345var x = 1;function test()&#123; alert(this.x);&#125;test(); //1 例三： 123456var x = 1;function test()&#123; this.x = 0;&#125;test(); alert(x); //0 例四： 123456789var x = 0;function test()&#123; alert(this.x);&#125;var o = &#123;&#125;;o.x = 1;o.m = test;o.m.apply(); //0 apply参数为空时，默认调用全局对象，故this指向windowo.m.apply(o); //1 test函数的调用者是o，故this指代对象o 例五： 执行第一个this时，function调用者为obj，故this指代obj对象； 执行f函数和匿名函数时，函数没有直接的调用者，故this指代window； 123456789101112131415161718192021var context = "global"; var obj = &#123; context: "object", method: function () &#123; console.log(this + ":" +this.context); // [object Object]:object function f() &#123; var context = "function"; console.log(this + ":" +this.context); // [object Window]:global &#125;; f(); (function()&#123; var context = "function"; console.log(this + ":" +this.context); // [object Window]:global &#125;)(); &#125;&#125;; obj.method(); 有对象调用函数时this指代调用函数者的例子 例一: o调用了test函数，故this指代对象o 1234567function test()&#123; alert(this.x);&#125;var o = &#123;&#125;;o.x = 1;o.m = test;o.m(); //1 例二： getInfo()函数的调用者是ext1，this指代ext1； 例三： getInfo()函数的调用者是ext1，this指代ext1； this.id和this.name都是代指ext1对象的id和name，但是由于ext1对象本身没有name属性，所以需要到原型链上查找name属性； 例四： 内层的funcion中包含了this，但是，内层function没有直接调用者； 故这里的this指window； 例五： object对象调用了外层函数，所以var that = this中的this指代object对象，执行完此句后，that也指代object对象； that并不是js的关键字，仅仅是一个普通的变量，所以下面return that.name的时候，返回的是object.name； 例六： object对象直接调用了外层的function，故var that = this中的this指代object对象，执行完此句后，that也指代object对象； 内层function没有直接调用者，故内层函数中的this指代window； 例七： point对象调用moveTo方法，故this指代point对象； 123456789101112var point = &#123; x : 0, y : 0, moveTo : function(x, y) &#123; this.x = this.x + x; this.y = this.y + y; &#125; &#125;;point.moveTo(1,1); console.log(point.x); //1console.log(point.y); //1console.log(x); //x is not defined 例八： moveX和moveY函数没有调用者，所以其中的this指代window，而不是point对象； 123456789101112131415161718192021var point = &#123; x : 0, y : 0, moveTo : function(x, y) &#123; var moveX = function(x) &#123; this.x = x; &#125;; var moveY = function(y) &#123; this.y = y; &#125;; moveX(x); moveY(y); &#125; &#125;; point.moveTo(1,1); point.x; //=&gt;0 point.y; //=&gt;0 x; //=&gt;1 y; //=&gt;1 this指代new出来的那个对象 例一： 由于存在new关键字，this指代的对象是new出来的对象，即对象o； 12345function test()&#123; this.x = 1;&#125;var o = new test();alert(o.x); //1 例二： this指代对象o，而不是window； 123456var x = 2;function test()&#123; this.x = 1;&#125;var o = new test();alert(x); //2 例三： np对象是new出来的，所以this指代np对象； p对象不是new出来的，且Point函数无调用者，故this指代window； 123456789function Point(x,y)&#123; this.x = x; this.y = y; &#125;var np=new Point(1,1);np.x; //1var p=Point(2,2);p.x; //error, p是一个空对象undefinedwindow.x; //2 例四： apply使得Point函数的调用者为p2，故this指代p2对象； 12345678910111213function Point(x, y)&#123; this.x = x; this.y = y; this.moveTo = function(x, y)&#123; this.x = x; this.y = y; &#125; &#125; var p1 = new Point(0, 0); var p2 = &#123;x: 0, y: 0&#125;; p1.moveTo.apply(p2, [10, 10]); //apply实际上为p2.moveTo(10,10)p2.x; //10 bind/call/apply重定向this关键字指向 例一： apply和call将函数的调用者转变了，所以this指代的对象随之转变； bind创建一个新的函数，这个函数中的this对象指代的内容也由bind函数指定； 123456789101112131415function add(numA, numB)&#123; console.log( this.original + numA + numB);&#125; add(1, 2); // NaN var obj = &#123;original: 10&#125;;add.apply(obj, [1, 2]); // 13add.call(obj, 1, 2); // 13 var f1 = add.bind(obj);f1(2, 3); // 15 var f2 = add.bind(obj, 2);f2(3); // 15 js事件中的this指代 例一： 前面的一个，console调用者是button对象，故this指代button对象； 中间的一个，匿名函数没有直接调用者，所以this指代window； 第三个，通过bind重定向函数中的this指向，所以this代表button对象； 12345678document.write('&lt;button onclick="console.log(this)"&gt;Show this&lt;/button&gt;');// &lt;button onclick="console.log(this)"&gt;Show this&lt;/button&gt;document.write('&lt;button onclick="(function()&#123;console.log(this);&#125;)()"&gt;Show this&lt;/button&gt;');// windowdocument.write('&lt;button onclick="((function()&#123;console.log(this);&#125;).bind(this))()"&gt;Show this&lt;/button&gt;');// &lt;button onclick="((function()&#123;console.log(this);&#125;).bind(this))()"&gt;Show this&lt;/button&gt; 其他的js事件中的this关键字指代请参考这里； this关键字指代对象的暂存方法 说明： 有些时候希望在this指代正确的对象的时候将this指代的对象暂存起来，备用； 例一： 下面程序将this指代的bar对象暂存到self对象中； 1234567891011121314151617var bar = &#123; name: "bar", body: document.getElementsByTagName("body")[0], greeting: function()&#123; console.log("Hi there, I'm " + this + ":" + this.name); &#125;, anotherMethod: function () &#123; var self = this; this.body.addEventListener("click", function()&#123; self.greeting(); &#125;); &#125;&#125;; bar.anotherMethod(); // Hi there, I'm [object Object]:bar 上面的程序也可以用bind实现： 12345678910111213141516var bar = &#123; name: "bar", body: document.getElementsByTagName("body")[0], greeting: function()&#123; console.log("Hi there, I'm " + this + ":" + this.name); &#125;, anotherMethod: function () &#123; this.body.addEventListener("click", (function()&#123; this.greeting(); &#125;).bind(this)); &#125;&#125;; bar.anotherMethod(); // Hi there, I'm [object Object]:bar]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js开发环境配置]]></title>
    <url>%2F2015%2F10%2F24%2Fnode-js-config%2F</url>
    <content type="text"><![CDATA[什么是node.js 维基百科的介绍：Node.js是谷歌V8引擎、libuv平台抽象层以及主体使用Javscript编写的核心库三者集合的一个包装外壳； node.js在国内外的使用情况： linkedin移动版正在向node.js迁移； twitter的消息队列用node.js实现； 知乎、网易的推送信息用node.js实现； 阿里的云计算平台也要部分向node.js迁移； ….. 上面的介绍听起来很抽象，其实，node.js就是一个能够在服务器端运行javascript的框架，实现了众多web开发者在server端使用javascript开发的梦想； node.js有很多优势，比如： 模块化； client和server双向实时通信； 高并发（单线程处理多个请求）； IO非阻塞（一件事情正在完成时可以去干另一件事）； node.js的这些优势，使得它的应用场景十分广泛： 聊天； 队列输入； 推送信息； 数据流传输； 代理； 只要是符合“计算简单、高并发、需要client和server双向通信”的业务模型都可以用！ 本文重点介绍了node.js在windows下的开发环境搭建； node.js开发环境配置 node.js开发环境需要配置如下内容： 在windows上安装Sublime和Webstorm； 在windows上安装VirtualBox和Centos虚拟机； 在windows上安装xShell和xFtp，方便在本机和虚拟机之间传送消息或文件； 在虚拟机上安装Redis和MongoDB； 下面会一一讲解这些步骤； VirtualBox的安装 下载VirtualBox 直接双击安装即可； 在VirtualBox中创建虚拟机 内存分配1024M； 磁盘种类选择默认种类； 安装CentOs basic web server版本，同时安装development tolls； CentOs7的iso镜像文件可从网上下载，添加到虚拟机配置中； 如果你所在的局域网路由器DHCP功能启用了，就设置网卡为桥接网卡，系统会自动分配IP地址； 如果你所在的局域网路由器DHCP功能禁用了，就设置网卡为NAT模式，需要进一步进行端口映射的配置（下面会将具体配置方法）； 安装完reboot虚拟机； 虚拟机的配置 网卡自启动的配置： 进入下列配置文件，并将最后一行ONBOOT设置为yes； 1vi /etc/sysconfig/network-scripts/ifcfg-enp0s3 如果你所在的局域网路由器DHCP功能启用了，此时就可通过ifconfig命令查询到ipv4地址，记下这个地址（当然你可以将它和它对应的域名配置到host文件中）； 如果你所在的局域网路由器DHCP功能禁用了，此时就将虚拟机网卡配置改为NAT网络模式，点击“端口转发按钮”，按照下图方式配置端口映射，这个设置的意思是，只要是访问本机（127.0.0.1）5905端口的消息全部转发给ip为10.0.2.15（这个ip是在虚拟机上运行ifconfig得到的，这是虚拟机在NAT模式下自行分配的ip）的22端口（SSH专用端口为22）； 安装epel： 1yum install epel-release xShell和xFtp安装 介绍： xShell是一款在windows上连接远程终端的软件，类似于SecureCRT，这里我们用它来连接本机上的虚拟机； xFtp用来在windows PC和linux终端间传输文件，这里我们用xFtp来实现本机和上面CentOs之间的文件传输； xShell安装： 下载地址（需先注册获取下载链接）：https://www.netsarang.com/xshell_download.html； 下载后双击安装即可； xFtp安装： 下载地址（需先注册获取下载链接）：https://www.netsarang.com/download/down_xfp.html； 下载后双击安装即可； xShell连接虚拟机： 如果你所在的局域网路由器DHCP功能启用了，直接连接虚拟机的ipv4地址（通过ifconfig命令查询到），端口22； 如果你所在的局域网路由器DHCP功能禁用了，此时连接127.0.0.1，端口5905，系统会自动根据上面的配置将数据映射到虚拟机； 连接成功后，输入用户名密码即可登录虚拟机； 在虚拟机上安装相应软件 安装Nodejs 安装yum install nodejs 查看是否正常安装node --version 安装MongoDB 安装yum install mongodb-server（mongodb服务器端）yum install mongodb（mongodb客户端） 查看是否正常安装mongo --version 安装redis 安装yum install redis 查看是否正常安装redis-cli --version 在windows安装相应软件 应当安装下列IDE或编辑器，不再赘述： sublime text； WebStorm； 第一个node程序 在虚拟机上新建文件test.js，内容为： 1console.log("hello world!") 在node运行这个文件node test.js 执行结果为hello world!，终于实现了在server端运行javascript的梦想！]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript map的实现]]></title>
    <url>%2F2015%2F10%2F03%2F2015-10-3-js-map%2F</url>
    <content type="text"><![CDATA[引言 在java语言中，map是一种重要的数据结构； 在js中，没有现成的map实现； 本文就带您来实现js中的map； map的具体实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function Map()&#123; this.keys = new Array(); this.data = new Object(); this.put = function(key,value)&#123; if(this.data[key]==null)&#123; this.keys.push(key); &#125; this.data[key] = value; &#125; this.get = function(key)&#123; return this.data[key]; &#125; this.remove = function(key)&#123; var index = this.keys.indexOf(key); this.keys.splice(index,1); this.data[key] = null; &#125; this.containsKey = function(key)&#123; if(this.keys.indexOf(key)!= -1)&#123; return true; &#125;else&#123; return false; &#125; &#125; this.size = function()&#123; return this.keys.length; &#125; this.entrySet = function()&#123; var len = this.keys.length; var entrys = new Array(len); for (var i = 0; i &lt; len; i++) &#123; entrys[i] = &#123; key : this.keys[i], value : this.data[this.keys[i]] &#125;; &#125; return entrys; &#125; this.isEmpty = function()&#123; return this.keys.length == 0; &#125;&#125; 自定义map的使用1234567891011121314151617181920//定义mapvar map = new Map();map.put("name","xiaozhang");map.put("age",20);map.put("home","beijing");//遍历mapvar arr = map.entrySet();for(var i =0; i&lt;arr.length; i++)&#123; document.write(arr[i].key+":"+arr[i].value+"&lt;br&gt;");&#125;//获取 移除元素map.get("name"); // xiaozhangmap.remove("home");//其他方法map.containsKey("name"); // truemap.size(); // 2map.isEmpty(); // false]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 事件详解]]></title>
    <url>%2F2015%2F10%2F02%2F2015-10-2-js-event%2F</url>
    <content type="text"><![CDATA[引言 javascript事件是用户在访问页面时执行的操作，事件处理程序用于捕捉用户在页面执行的操作； javascript事件是动态化页面的重要方式； 本文主要总结了重要的javascript事件，以及DOM0和DOM2对事件处理的异同； 事件大全 下面总结了javascript事件，格式：事件名称+浏览器支持+说明 一般事件 onclick IE3、N2 鼠标点击时触发此事件 ondblclick IE4、N4 鼠标双击时触发此事件 onmousedown IE4、N4 按下鼠标时触发此事件 onmouseup IE4、N4 鼠标按下后松开鼠标时触发此事件 onmouseover IE3、N2 当鼠标移动到某对象范围的上方时触发此事件 onmousemove IE4、N4 鼠标移动时触发此事件 onmouseout IE4、N3 当鼠标离开某对象范围时触发此事件 onkeypress IE4、N4 当键盘上的某个键被按下并且释放时触发此事件. onkeydown IE4、N4 当键盘上某个按键被按下时触发此事件 onkeyup IE4、N4 当键盘上某个按键被按放开时触发此事件 页面相关事件 onabort IE4、N3 图片在下载时被用户中断 onbeforeunload IE4、N 当前页面的内容将要被改变时触发此事件 onerror IE4、N3 出现错误时触发此事件 onload IE3、N2 页面内容完成时触发此事件 onmove IE、N4 浏览器的窗口被移动时触发此事件 onresize IE4、N4 当浏览器的窗口大小被改变时触发此事件 onscroll IE4、N 浏览器的滚动条位置发生变化时触发此事件 onstop IE5、N 浏览器的停止按钮被按下时触发此事件或者正在下载的文件被中断 onunload IE3、N2 当前页面将被改变时触发此事件 表单相关事件 onblur IE3、N2 当前元素失去焦点时触发此事件 onchange IE3、N2 当前元素失去焦点并且元素的内容发生改变而触发此事件 onfocus IE3 、N2 当某个元素获得焦点时触发此事件 onreset IE4 、N3 当表单中RESET的属性被激发时触发此事件 onsubmit IE3 、N2 一个表单被递交时触发此事件 滚动字幕事件 onbounce IE4、N 在Marquee内的内容移动至Marquee显示范围之外时触发此事件 onfinish IE4、N 当Marquee元素完成需要显示的内容后触发此事件 onstart IE4、 N 当Marquee元素开始显示内容时触发此事件 编辑事件 onbeforecopy IE5、N 当页面当前的被选择内容将要复制到浏览者系统的剪贴板前触发此事件 onbeforecut IE5、 N 当页面中的一部分或者全部的内容将被移离当前页面[剪贴]并移动到浏览者的系统剪贴板时触发此事件 onbeforeeditfocus IE5、N 当前元素将要进入编辑状态 onbeforepaste IE5、 N 内容将要从浏览者的系统剪贴板传送[粘贴]到页面中时触发此事件 onbeforeupdate IE5、 N 当浏览者粘贴系统剪贴板中的内容时通知目标对象 oncontextmenu IE5、N 当浏览者按下鼠标右键出现菜单时或者通过键盘的按键触发页面菜单时触发的事件 oncopy IE5、N 当页面当前的被选择内容被复制后触发此事件 oncut IE5、N 当页面当前的被选择内容被剪切时触发此事件 ondrag IE5、N 当某个对象被拖动时触发此事件 [活动事件] ondragdrop IE、N4 一个外部对象被鼠标拖进当前窗口或者帧 ondragend IE5、N 当鼠标拖动结束时触发此事件，即鼠标的按钮被释放了 ondragenter IE5、N 当对象被鼠标拖动的对象进入其容器范围内时触发此事件 ondragleave IE5、N 当对象被鼠标拖动的对象离开其容器范围内时触发此事件 ondragover IE5、N 当某被拖动的对象在另一对象容器范围内拖动时触发此事件 ondragstart IE4、N 当某对象将被拖动时触发此事件 ondrop IE5、N 在一个拖动过程中，释放鼠标键时触发此事件 onlosecapture IE5、N 当元素失去鼠标移动所形成的选择焦点时触发此事件 onpaste IE5、N 当内容被粘贴时触发此事件 onselect IE4、N 当文本内容被选择时的事件 onselectstart IE4、N 当文本内容选择将开始发生时触发的事件 数据绑定 onafterupdate IE4、N 当数据完成由数据源到对象的传送时触发此事件 oncellchange IE5、N 当数据来源发生变化时 ondataavailable IE4、N 当数据接收完成时触发事件 ondatasetchanged IE4、N 数据在数据源发生变化时触发的事件 ondatasetcomplete IE4、N 当来子数据源的全部有效数据读取完毕时触发此事件 onerrorupdate IE4、N 当使用onBeforeUpdate事件触发取消了数据传送时，代替onAfterUpdate事件 onrowenter IE5、N 当前数据源的数据发生变化并且有新的有效数据时触发的事件 onrowexit IE5、N 当前数据源的数据将要发生变化时触发的事件 onrowsdelete IE5、N 当前数据记录将被删除时触发此事件 onrowsinserted IE5、N 当前数据源将要插入新数据记录时触发此事件 外部事件 onafterprint IE5、N 当文档被打印后触发此事件 onbeforeprint IE5、N 当文档即将打印时触发此事件 onfilterchange IE4、N 当某个对象的滤镜效果发生变化时触发的事件 onhelp IE4、N 当浏览者按下F1或者浏览器的帮助选择时触发此事件 onpropertychange IE5、N 当对象的属性之一发生变化时触发此事件 onreadystatechange IE4、N 当对象的初始化属性值发生变化时触发此事件 事件的使用和html内联使用123&lt;button id="btn" type="button" value="button" onclick="alert('aaa')"&gt; button&lt;/button&gt; 12345678&lt;body&gt; &lt;button onclick="demo()"&gt;button&lt;/button&gt; &lt;script&gt; function demo()&#123; alert("aaa"); &#125; &lt;/script&gt;&lt;/body&gt; 外部js使用123document.getElementById("txt").onchange = function()&#123; alert("change");&#125; 取消事件绑定12345btn.onclick = function(e)&#123; alert("ok"); &#125;; btn.onclick = null; //取消绑定 DOM2事件详解DOM2事件的特点 DOM2支持同一dom元素注册多个同种事件； DOM2新增了捕获和冒泡的概念； DOM2事件通过addEventListener和removeEventListener管理； 注册事件(addEventListener) 参数一：事件名称，比上面DOM0的事件去掉”on”； 参数二：事件内容，fucntion中； 事件三：布尔型，true代表捕获事件，false代表冒泡事件； 123outer.addEventListener('click',function(e)&#123; alert("outer"); &#125;,false); 捕获和冒泡事件 如果外层和内层的多层DOM结构中，不同的层都注册有事件，先执行谁呢? 从外到内执行叫做捕获类型事件，从内到外执行叫做冒泡类型事件； 捕获类型事件总是比冒泡类型事件先执行； 如果两种类型的事件集中在了同一个元素身上，就不分这两种类型了，此时，哪个事件注册在前（在js中写在前面），他就先执行； 对于一个页面元素来说，他的身上如果集中了多个相同的事件，不会覆盖,都会执行，且定义在前的先执行； 如果普通事件和DOM2事件同时作用于一个元素，则不会出现后注册的覆盖先注册的，都执行，而且定义在前的先执行； 123456789101112131415161718192021222324252627&lt;body&gt; &lt;div id="outer" style="width:300px;height:300px;"&gt; &lt;div id="inner"&gt; &lt;button id="btn" type="button" value="button" onclick="alert('aaa')"&gt; button &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var outer = document.getElementById("outer"); var inner = document.getElementById("inner"); var btn = document.getElementById("btn"); outer.addEventListener('click',function(e)&#123; alert("outer"); //先执行 &#125;,true); inner.addEventListener('click',function(e)&#123; alert("inner"); //最后执行 &#125;,false); btn.addEventListener('click',function(e)&#123; alert("btn"); //再执行 &#125;,false); &lt;/script&gt;&lt;/body&gt; 1234567891011121314151617181920212223&lt;body&gt; &lt;div id="outer" style="width:300px;height:300px;"&gt; &lt;div id="inner"&gt; &lt;button id="btn" type="button" value="button" onclick="alert('aaa')"&gt; button &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var outer = document.getElementById("outer"); var inner = document.getElementById("inner"); var btn = document.getElementById("btn"); inner.addEventListener('click',function(e)&#123; alert("inner1"); //先执行 &#125;,false); inner.addEventListener('click',function(e)&#123; alert("inner2"); //后执行 &#125;,true); &lt;/script&gt;&lt;/body&gt; stopPropagation阻止冒泡1234567891011121314151617181920212223&lt;body&gt; &lt;div id="outer" style="width:300px;height:300px;"&gt; &lt;div id="inner"&gt; &lt;button id="btn" type="button" value="button" onclick="alert('aaa')"&gt; button &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var outer = document.getElementById("outer"); var inner = document.getElementById("inner"); var btn = document.getElementById("btn"); outer.addEventListener('click',function(e)&#123; alert("outer"); //不执行 &#125;,false); inner.addEventListener('click',function(e)&#123; e.stopPropagation(); //阻止冒泡 alert("inner"); //执行 &#125;,false); &lt;/script&gt;&lt;/body&gt; removeEventListener解除事件绑定1234567var btn = document.getElementById("btn");var fn = function(e)&#123; alert("aa");&#125;btn.addEventListener("click",fn,false); //绑定btn.removeEventListener("click",fn,false); //解绑 IE8及之前版本浏览器的DOM2事件說明 IE8以及其之前版本的浏览器并不支持addEventListener()和removeEventListener()； 相应的，IE定义了类似的方法attachEvent()和detachEvent()； attachEvent()和detachEvent()要求只有两个参数：事件类型（前面带上”on”）和事件处理函数，默认冒泡，不支持捕获； 同一个元素定义的同种类型的事件，都会执行，不会覆盖，且定义在后的先执行； stopPropagation()不起作用； ####示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;test&lt;/title&gt; &lt;style&gt; #outter&#123; width: 300px; height: 300px; background-color: #f00; &#125; #inner&#123; width: 200px; height: 200px; background-color: #0f0; &#125; #in&#123; width: 100px; height: 100px; background-color: #00f; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="outter"&gt; &lt;div id="inner"&gt; &lt;div id="in"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; document.getElementById("outter").attachEvent('onclick',function()&#123; alert("outter"); //最后執行 &#125;); document.getElementById("inner").attachEvent('onclick',function()&#123; alert("inner"); //再执行 &#125;); function test()&#123; alert("in1"); &#125; document.getElementById("in").attachEvent('onclick',test); //先执行 &lt;/script&gt; &lt;script type="text/javascript" src="app.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 兼容性说明 添加事件的兼容性：需要先做判断浏览器支持哪种事件处理机制； 12345if(div1.addEventListener)&#123; div1.addEventListener('click', div1Fun, false);&#125;else if(div1.attachEvent)&#123; div1.attachEvent('onclick', div1Fun);&#125; 访问事件对象的兼容性： 123456 function myFun(event)&#123; event = event || window.event; var target = event.target || event.srcElement; console.log(event.type); console.log(target);&#125;]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库并发冲突的解决]]></title>
    <url>%2F2015%2F10%2F02%2F2015-10-2-datebase-conflict%2F</url>
    <content type="text"><![CDATA[引言 数据库读写看似简单，其实蕴含着许多值得思考的问题； 并发读写是令数据库设计者头疼的问题，其实，这个问题不仅令数据库设计者困惑，对于数据库的使用者来说，如何从业务层面高效处理并发读写问题也是不小的挑战； 本文就此问题做简单探讨； 问题描述 在多用户环境中，在同一时间可能会有多个用户更新相同的记录，这会产生冲突，具体为： 丢失更新：一个事务的更新覆盖了其它事务的更新结果，就是所谓的更新丢失。例如：用户A把值从6改为2，用户B把值从2改为6，则用户A丢失了他的更新； 脏读：当一个事务读取其它完成一半事务的记录时，就会发生脏读取。例如：用户A,B看到的值都是6，用户B把值改为2，用户A读到的值仍为6； 数据库层面的并发控制-悲观锁 说明： 假定本次读写一定会发生并发冲突，屏蔽一切可能违反数据完整性的操作； 适用于实际业务中冲突发生可能性较大的情况，比如很有可能不同的人同时修改同一条数据库记录； 如果实际业务中冲突发生可能性较小，则用悲观锁效率很低（因为上锁的代价大）； 使用： 操作之前先上锁； 需要使用数据库的锁机制，比如SQL SERVER 的TABLOCKX（排它表锁） 此选项被选中时，SQL Server将在整个表上置排它锁直至该命令或事务结束，这将防止其他进程读取或修改表中的数据； 数据库层面的并发控制-乐观锁 说明： 假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性，乐观锁不能解决脏读的问题； 适用于实际业务中冲突发生可能性较小的情况，比如几乎不可能不同的人同时修改同一条数据库记录； 使用： 数据表中专门有一个version字段（int型）记录版本信息； 每当这条记录改动时，这条记录对应的version字段增1； 每次更新时检查版本号是否一致，比如数据库中数据版本为6，更新提交时version=6+1,使用该version值(=7)与数据库version+1(=7)作比较，如果相等，则可以更新，如果不等则有可能其他程序已更新该记录，所以返回错误； 结论 在实际生产环境里边，如果并发量不大且不允许脏读，可以使用悲观锁解决并发问题； 但如果系统的并发非常大的话,悲观锁定会带来非常大的性能问题,所以我们就要选择乐观锁定的方法； 上面介绍的锁都是数据库层面的锁，其实，如果从业务层面来看，上面的并发控制机制还是不够的，在数据库设计时，可以设计lock字段，如果要暂时锁定某些行，令lock=1时视为锁定，业务锁面向业务，更加可靠；]]></content>
      <categories>
        <category>datebase</category>
      </categories>
      <tags>
        <tag>datebase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向HTTP的Web性能提升方案]]></title>
    <url>%2F2015%2F10%2F01%2F2015-10-1-http-improve-web%2F</url>
    <content type="text"><![CDATA[引言 前端优化是个永恒的课题 前端优化的方案非常多，诸如加快脚本加载速度、缓存优化、提升js执行效率、运用ajax技术等等； 本文重点介绍面向HTTP的一些Web性能提升方案； 到底发生什么了？ 建立TCP连接 为了进行可靠的数据传输，TCP在进行发送数据之前，会进行TCP三次握手，以此确定接收方能够成功收取传输的数据，而建立连接的过程，必然是要耗费系统资源，以及时间资源的。 服务端处理并响应 当服务端接收到客户端发送来的请求之后，如果请求内容是静态资源，服务端会从硬盘中取出静态资源，然后将静态资源放在响应主体中，发送给客户端。如果是动态资源，服务端首先取出资源，并通过业务逻辑操作，动态生成最终的响应主体，然后发送给客户端。 客户端渲染 客户端接受到服务端传输过来的网络资源，然后进行渲染，绘制等，最终展示给用户。 优化点一：持久连接Keep-Alive HTTP连接设计之初是请求-响应-关闭，也就是每建立一次HTTP连接，只能进行一次资源请求，当需要在同一目标服务器上获取多个资源的时候，就需要多次建立HTTP连接，而这个多次建立连接的过程，便降低了网站的性能。 于是，出现了Connection:Keep-Alive，人称持久连接。Keep-Alive避免了建立或者说重新建立连接的过程，减少了HTTP连接。 而与此配套的有Keep-Alive:timeout=120,max=5 其中,timeout=120 是指这个TCP通道保持120S，max=5 指这个TCP通道最多接收5个HTTP请求，之后便自动关闭该连接。 优化点二：修改时间Last-Modified 和 If-Modified-Since Last-Modified首部是服务端对客户端的HTTP响应所加的一个与缓存有关的HTTP首部，该首部标记了所请求资源在服务端的最后修改时间。类似： 1Last-Modified : Fri , 12 May 2015 13:10:33 GMT 当客户端发现HTTP响应头中有Last-Modified，会对资源进行缓存，在下次请求资源时，在HTTP请求头中添加If-Modified-Since首部，首部中将会添加上次成功请求资源时响应头部的Last-Modified属性值，即： 1If-Modified-Since : Fri , 12 May 2015 13:10:33 GMT 当服务端接收到的HTTP请求中，发现有If-Modified-Since头部时，会将该属性值与请求资源的最后修改时间进行比对，如果最后修改时间与该属性值一致时，服务端会返回一个304 Not Modified响应，该响应中不包括响应实体。浏览器收到304的响应后，会进行重定向，获取本地缓存资源。如果最后修改时间与该属性值不一致，则会从服务端重新获取资源，做出200响应。 优化点三：版本标记 ETag 和 If-None-Match ETag其实与Last-Modified是差不多的方式，但是ETag并没有选择以时间作为标记，而是对所请求文件进行某些算法来生成一串唯一的字符串，作为对某一文件的标记。当收到客户端对某一资源的请求时，服务端在响应时，添加ETag首部,如下： 1ETag:W/"a627ff1c9e65d2dede2efe0dd25efb8c" 当客户端发现ETag头部时，同样会对资源进行缓存，并在下次请求时，在请求头部添加If-None-Match，如： 1If-None-Match:W/"a627ff1c9e65d2dede2efe0dd25efb8c" 当服务端收到请求中含有该头部时，会使用同样的ETag生成算法对文件ETag进行计算，并与If-None-Match属性值进行比对，如果一致，则返回一个304 Not Modified响应，基本与上一种方式是一致的。 优化点四：缓存时间 Expires 和 Cache-Control 上述两种方式中，每次请求资源时，虽然在有缓存的情况下，选择缓存进行渲染绘制，但是在这之前还是发起了一次HTTP请求，虽然并没有真实的响应实体，但是依然会造成一些资源消耗。而Expires与上述两种方式使用了不同的思路。 当服务端希望客户端浏览器对某一资源进行缓存时，为了免去客户端每次都要询问自己：我上次的缓存现在还能用吗？所以，服务端选择了放权。只去告诉浏览器，我这次给你的资源你可以用多长时间，在这个时间段内，你可以一直使用它，无需每次咨询我。而服务端就是通过Expires属性来告诉客户端浏览器可以多长时间内不需要询问服务端。如下： 1Expires:Thu, 19 Nov 2015 15:00:00 GMT 当客户端在响应首部中发现该属性值时，便会将该资源缓存起来，而缓存的过期时间即是Expires中的时间。在这个时间段内，浏览器完全自主。 但是，Expires有一个不足的地方是，如果服务端时间与客户端本地时间不统一时，可能服务端让客户端可以对该资源缓存一个小时，而客户端本地时间比服务端时间快了两个小时，那就意味着，所有缓存都将不会生效。 于是有了弥补该不足的一个属性，即：Cache-Control。如果服务端在响应首部添加该属性时，客户端将直接使用该属性值来生成本地时间的缓存过期时间，这样便解决了这个问题，如下： 1Cache-Control:max-age=3600 如果客户端在2015年10月01日13时00分00秒收到该响应时，便会加上3600秒也就是2015年10月01日14时00分00秒作为缓存过期时间。如果响应头部既有Expires和Cache-Control，浏览器会首选Cache-Control。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络五层结构功能汇总]]></title>
    <url>%2F2015%2F09%2F12%2F2015-9-12-five-layer%2F</url>
    <content type="text"><![CDATA[引言 网上有很多博客介绍过计算机网络五层结构，但专门汇总五层结构功能的博文非常少； 本文从纵向的角度，清晰概述计算机网络五层结构的功能和特点； 本文总结了计算机网络五层结构的协议名和专用术语，并对一些结构性问题加以解释； 本文没有介绍五层结构的实现细节； 五层结构的作用汇总 层级名称 主要作用和功能 物理层 发送和接收比特流；负责将比特流调制到载波上面（调幅、调频、调相）；可以用信道复用等技术提升发送速率； 数据链路层 负责相邻设备间通信，这两个设备间没有交换节点，具体表现为点对点通信（PPP协议）和广播通信（CSMA/CD协议）；用MAC地址识别参与通信的两个节点（源节点、目的节点），MAC地址是本层及以下层专用；上层网络层根据目的IP确定下一跳IP地址，数据链路层(交换机)根据下一跳IP地址就能确定下一跳的MAC地址，并将网络层数据报再次封装，加上目的MAC地址，交由物理层传送；负责帧的差错检测，丢弃错误的帧（只检错不纠错），错误可能是帧丢失、帧重复、帧失序； 网络层 负责不相邻的两个节点间的通信，比如我的电脑和网页服务器之间的通信；用IP地址识别源地址、目的地址，IP地址是本层及以上层专用；能够确定转发路线，使得效率最高； 运输层 识别并将数据报正确交付相应的应用程序，识别数据报属于哪个应用程序的方法为看端口；TCP可靠传输，UDP不可靠传输； 应用层 使用得到的报文段，为用户提供各种服务（浏览器、邮件、远程通信）；向上面向用户（域名给用户看），向下面向运输层和网络层（域名解析给他们看）； 五层结构传输单元名称 层级名称 传输单元名称 应用层 报文 运输层 TCP：报文段；UDP：用户数据报； 网络层 分组或IP数据报（简称数据报） 数据链路层 帧 物理层 比特 各层协议和专用术语汇总 层级名称 传输单元名称 应用层 网际组管理协议IGMP：使得连接在本局域网上的多播路由器知道本局域网上是否有主机（指主机上的进程）参加或退出某个多播组；DNS：域名系统；简单文件传送协议TFTP；文件传送协议FTP；NFS：网络文件系统；动态主机配置协议DHCP：用于自动分配IP地址；简单网络管理协议SNMP；简单邮件传送协议SMTP：用于发送邮件；邮件读取协议POP和IMAP：用于读取邮件；远程终端协议TELNET；超文本传送协议HTTP；socket：IP和端口统称套接字，java语言中称为java socket编程；安全外壳SSH（Secure Shell）：不是一种协议，是运用运输层SSL协议构建的一个类似telnet的应用，SSH = TELNET + SSL，和web开发框架中的SSH框架没有任何关系（SSH=Struts+Spring+Hibernate）； 运输层 传输控制协议TCP：面向连接；用户数据报协议UDP：无连接；安全套接层SSL：是一种在运输层对网络数据进行加密的协议; 网络层 地址解析协议ARP：已知一台机器的IP地址，需要找出其相对应的硬件MAC地址；网际控制报文协议ICMP：分为ICMP差错报文和ICMP询问报文，用于主机和路由器报告差错和异常情况，ping命令是在应用层直接使用网络层协议的例子；内部网关协议IGP：一个自治系统内部使用的路由协议，包括RIP和OSPF协议；外部网关协议EGP：自治系统间路由协议，包括BGP协议；VPN：虚拟专用网技术，用到了网络地址转换NAT技术； 数据链路层 PPP：点对点信道所使用的协议；CSMA/CD：广播信道使用的协议；MAC地址； 物理层 传输介质：双绞线、同轴电缆；信道复用技术：频分复用、时分复用、码分复用；宽带接入技术：ADSL（非对称用户数字线）； 各层典型设备 层级名称 设备名称 应用层 网关：连接两个或多个使用不同协议的网络，充当“协议转换器”，是两个局域网之间的通道； 运输层 暂无 网络层 路由器：连接不同网络的设备，自动选择设定路由，寻找最佳路径，在某些情况下，路由器也被称做网关； 数据链路层 网卡（网络适配器）：当接收帧错误时就丢弃，正确时就交付网络层，内含MAC地址；交换机：相当于多个网桥，将好多计算机连接成一个局域网，负责局域网内部的数据交换，相当于扩展的网桥，允许在还没把数据帧接受完全的情况下转发帧；网桥/桥接器：把一个局域网隔离成许多网段，维护转发表，对收到的帧进行转发、过滤或丢弃（完全接收到一帧后才转发）； 物理层 集线器/转发器：简单转发比特，不维护任何表； 几个结构性问题的解释 为何不能只有MAC地址，IP地址没有行不行？ 这和”能不能只有数据链路层，没有网络层”的问题一样； 他们处理的是不同层面的事务，前者专注于相邻节点传输、后者则专注于不相邻节点传输； 这是”网络”这个事务由小到大、量变产生质变的必然选择； 为何不将TCP可靠传输的任务交由网络层负责？ 其实这是”可靠”怎么理解的问题，如果网络层可靠了，但是在传输层不可靠，数据也无法正确及时的送达应用程序手中； 如果网络层和运输层都保证可靠，协议未免太过复杂，效率降低； 所以只在运输层保证可靠，是在效率、可靠性之间权衡做出的最佳选择；]]></content>
      <categories>
        <category>computer</category>
      </categories>
      <tags>
        <tag>computer</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS技巧汇总]]></title>
    <url>%2F2015%2F09%2F11%2F2015-9-11-css-use%2F</url>
    <content type="text"><![CDATA[引言 使用CSS渲染页面是当今网页常用的技术。 本文汇总了CSS使用时的注意事项和技巧。 浏览器支持 webkit/safari/chrome：-webkit-； firefox：-moz-； IE：-ms-； opera：-o-； 一般来说，对于下面介绍的一些较新的css3特性，为了兼容旧版浏览器，需要添加-webkit-前缀； 技巧汇总 描述 方法 改变控件的四个角的弧度 border-radius属性，另有border-top-left-radius、border-top-right-radius、border-bottom-right-radius、border-bottom-left-radius等扩展属性 改变input标签中placeholder的样式 使用伪类 input::-webkit-input-placeholder, textarea::-webkit-input-placeholder 使元素自由浮动 使用float属性 使元素从他自己的位置偏移 使用position:relative属性,配合left、right等属性使用 使元素固定位置 使用position:fixed属性，并配合z-index属性设置元素的层叠顺序 设置元素绝对位置 使用position:absolute属性 设置文字的位置 使用text-align属性 设置元素是否显示 使用display属性 设置元素溢出后样式 使用overflow属性 设置鼠标悬停样式 使用cursor属性 设置文本阴影 使用text-shadow属性，此属性为CSS3增强特性 设置元素透明度 使用opacity属性]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2F2015%2F07%2F31%2F2015-7-31-git-command%2F</url>
    <content type="text"><![CDATA[引言 git是常用的版本管理工具 本文总结了git最常用的命令，应当熟记于心 使用git应当尽量使用命令行，这样可以帮助熟悉git的流程 配置和状态：git status git现在状态 git init 初始化git，生成 .git 文件； 常用动作：git clone (url) 将工程的master分支clone下来； git clone (url) (空格) (目录) 仅仅将repository某个目录clone到本地； git clone (url) (空格) /(目录) 将git这个目录下的所有文件下载到本地这个目录下； git clone -b branchName (url) 将一个分支clone到本地； git checkout -b csy_ui origin/csy_ui_m clone另一个分支到本地的新建分支中； git checkout branchName 切换到某个分支，在checkout前需保证当前分支已经commit，否则会报错； git merge (被合并分支名称) 将被合并分支合并到当前分支，执行此命令后，没有冲突的都已经merge到当前分支，有冲突的会提示，用编辑器解决完冲突后，直接add以及commit即可完成整个merge过程，不用重新merge； git branch test 新建名为test的分支； git checkout -b test 新建名为test的分支，并checkout到该分支； git add . add改动到暂存区域； git commit -a -m “….” commit改动到repository； git push origin master push到名字为origin的远端的master分支中； git diff 对比当前分支在当前状态下和刚刚写换到这个分支的时候有什么不同，列出改动的文件和具体改动哪些内容； git mv old_name new_name 重命名文件 历史和记录：git log/git log –graph 查看git历史动作 history 查看git命令历史记录]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进制、文件和编码的理解]]></title>
    <url>%2F2015%2F07%2F30%2F2015-7-30-files-encode%2F</url>
    <content type="text"><![CDATA[引言 进制、文件、编码是计算机系统的重要概念，应当理解； 本文介绍了进制、文件、编码应当掌握的基本内容 进制 进制间转换请戳这里； 编码 编码是信息从一种形式或格式转换为另一种形式的过程； 常见编码格式：ascii、GBK、UTF-8； 无论何种编码，最终要在计算机中以二进制形式存储，英文和中文占用字节数目不同，具体占用几个字节由编码方式决定； 计算机的文件分为二进制文件和文本文件，二进制文件是经过编译后的，用编辑器打开肯定是乱码，而文本文件中存储了此文件的编码方式，如果编辑器可以自动识别这个文本文件的编码方式，则用编辑器打开文本文件时就会自动正确解码，不会有乱码现象； 文件 计算机的文件有两种：文本文件、二进制文件； 计算机的存储在物理上是二进制的，所以文本文件与二进制文件的区别并不是物理上的，而是逻辑上的，也可以说文本文件是二进制文件的特殊形式； 两者区别： 文本文件是基于字符编码的文件，常见的编码有ASCII编码，UNICODE编码等等，先将文件中的人类可识别的字符转换为一串数字（具体怎么转换由编码方式决定），然后以二进制的形式存储在计算机中； 二进制文件是基于值编码的文件，你可以根据具体应用，指定某个值是什么意思； 文本文件能够用编辑器打开，二进制文件不能（乱码），二进制文件能够用特定的软件读取其中的内容（WinHex、UltraEdit）； 例子1： 文本文件：中文和英文文档、源代码文档； 二进制文件：经过编译后的.class文件、可执行文件.exe； 例子2： 如果用文本文件存储int类型的数字1，其中存储的是1的ascii码（假定用ascii编码）49（一个字节），再将49转换成二进制进行物理存储，读取的时候读到的是49，经过解码显示数字1； 如果用二进制文件存储int类型的数字1，由于int类型占用四个字节，故文件中存储的是四个字节00000000 00000000 00000000 00000001，在读取文件的时候应当告知以int方式读取，即四个四个字节读取；]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用快捷键]]></title>
    <url>%2F2015%2F07%2F29%2F2015-7-29-key-shortcuts%2F</url>
    <content type="text"><![CDATA[引言 本文分类总结了常用快捷键 编程时应当尽量使用键盘输入，避免过多的鼠标操作，可以提升编程效率 必要时可以为IDE安装emmet等插件，方便编程和开发 编辑：ctrl+c：复制 ctrl+v：粘贴 ctrl+shift+v：无格式粘贴 ctrl+x：剪切 ctrl+f：查找 ctrl+z：返回上一状态 ctrl+y：返回下一状态 ctrl+s：保存 ctrl+a：全选 windows系统：ctrl+tab：标签页切换 alt+tab：窗口切换 alt+滑轮：字体大小转换 windows+d：桌面 windows+e：打开计算机文件夹 windows+r：打开终端 启动按F12：显示启动项 浏览器：F5：刷新； F12：开发者工具； Ctrl+U：查看源代码； F11：全屏； Ctrl+N：打开新窗口； Alt+F4：关闭当前窗口； Ctrl+T：打开新标签页； Ctrl+W：关闭当前标签页或弹出式窗口； Ctrl+Tab：切换到下一个标签页 ； Ctrl+Shift+Tab：切换到上一个标签页； Ctrl+1到Ctrl+8：切换到指定位置编号的标签页； linux系统：ctrl+alt+T：打开终端 ctrl+alt+L：锁屏 编程/普通编辑器/IDE：ctrl+space或alt+/：补全代码 ctrl+p：Show parameters for selected method，函数参数提示； shift+alt+F：格式化代码 ctrl+/：注释代码 ctrl+L：清空控制台 ctrl+Home/End：选中当前光标所在位置之前/之后的一个单词； ctrl+shift+Home/End：选中当前光标所在位置之前/之后的所有字符； shift+左右箭头：以字符为单位选中； ctrl+左右箭头：以单词为单位跳转； shift+ctrl+左右箭头：以单词为单位选中； alt+shift+上下箭头：本行和上下行换行； ctrl+x：删除行； ctrl+d：复制本行到下一行； shift+alt+s：自动生成代码（比如get set方法）； 选中代码块右键&gt;surround with：自动生成代码（比如try…catch块儿）；]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM运行时数据区]]></title>
    <url>%2F2015%2F07%2F29%2F2015-7-29-JVM-data-field%2F</url>
    <content type="text"><![CDATA[JVM运行时数据区的理解 运行时数据区面向线程，而不面向类或方法或对象； 线程共享：方法区、堆内存（heap）,线程私有：虚拟机栈（栈内存stack）、本地方法栈、程序计数器； 程序计数器：存放线程执行位置（main函数也是一个线程）； 虚拟机栈（栈内存）：生命周期和对应的线程相同，存放该线程的局部变量、对象的引用；方法中可能嵌套调用别的方法，这些方法的变量以”先进后出、后进先出“的方式在栈内存中存储，所以内层方法无法访问外层方法的变量（他们在栈底），执行外层方法时内层方法的变量已经弹出栈消失了，所以外层方法也不会访问到内层方法的变量；一个方法的执行过程，就是这个方法对于帧栈的入栈出栈过程； 本地方法栈：作用和虚拟机栈完全相同；虚拟机栈对应普通的java方法，本地方法栈对应native方法；native方法是一个java调用非java代码的接口； 方法区：JVM内存管理中最大一块；存储常量（final修饰）、类变量/成员变量（static修饰）、类信息（每个类的访问控制符、修饰符、继承关系等）； 堆内存：JVM启动时创建，存放对象本身，不存放对对象的引用（引用存在栈内存）； JVM垃圾收集特指收集堆内存中的失去引用的对象的存储空间；栈内存存储空间不予收集；如果一个对象长期不失去引用、但在程序中已经没有用，那么系统不会进行垃圾收集，可能造成内存泄露/内存溢出；]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MapReduce编程技巧和注意事项]]></title>
    <url>%2F2015%2F05%2F11%2F2015-5-11-mapreduce-program%2F</url>
    <content type="text"><![CDATA[引言 在编写Mapreduce程序的过程中会遇到各种各样的问题，本文为您梳理了常见的问题、注意事项和技巧； MapReduce中常见的数据类型转换方法 类型转换 方法汇总 int&gt;String int i=12345; String s=””; 第一种方法：s=i+””; 第二种方法：s=String.valueOf(i); String&gt;int s=”12345”; int i; 第一种方法：i=Integer.parseInt(s); 第二种方法：i=Integer.valueOf(s).intValue(); LongWritable&gt;String LongWritable.toString() String&gt;long Long.parseLong(String) Text&gt;String Text.toString() long&gt;LongWritable new LongWritable(long) String&gt;Text new Text(String) 编程注意事项 hadoop特有的数据类型（LongWritable、IntWritable和Text等）和java的数据结构（set、list、map等）不兼容，以下使用情形会出错：例如：Set &lt;Text&gt; userSet = new HashSet&lt;Text&gt;(); 或者 List &lt;LongWritable&gt; list = new ArrayList &lt;LongWritable&gt;();所以尽量不要同时使用； reduce中遍历values的过程只能执行一遍，因为values是Iterable迭代器类型；如果需要多次遍历values内容，要么每次遍历前移动迭代器指针到初始位置，要么第一次遍历时将values内容放入list中，方便以后重复访问； map的输出必须是Writable类型的（比如IntWritable、LongWritable、Text），如果是普通java类型（Integer、Long、String）会出错（报错：Unable to initialize MapOutputCollector）； map的输入固定为，输入类型为，这些都不能随意更改，如需更改，要重写inputFormat； Mapreduce程序参数设置 参数 设置方法 不执行reduce函数 job.setNumReduceTasks(0);此时不执行reduce，输出文件的数量就是map的数量； 设置执行map的类 job.setMapperClass(FlowFilter.class); 设置执行combine的类（一般就是reduce类） job.setCombinerClass(Reduce.class); 设置执行reduce的类 job.setReducerClass(DNTGUserInfoReducer.class); 设置map的数量 job.setNumMapTasks(maps)； 设置reduce数量（最终输出文件数量） job.setNumReduceTasks(reduces); 设置文件输入类型（默认为inputFormat，一行一行读取） job.setInputFormatClass(ProvinceInputFormat.class); 设置map的输出类型（key、value类型） job.setMapOutputKeyClass(HMKey.class); job.setMapOutputValueClass(HMValue.class); 设置redcue的输出类型（key、value类型） job.setReduceOutputKeyClass(Text.class); job.setReduceOutputValueClass(IntWritable.class); 统一设置map和reduce的输出类型 job.setOutputKeyClass(Text.class); job.setOutputValueClass(IntWritable.class); 设置整个程序输入、输出路径 FileInputFormat.addInputPath(job, new Path(otherArgs[0])); FileOutputFormat.setOutputPath(job, new Path(otherArgs[1]));]]></content>
      <categories>
        <category>hadoop</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>mapreduce</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MapReduce设计模式实例解析]]></title>
    <url>%2F2015%2F05%2F10%2F2015-5-10-mapreduce-model%2F</url>
    <content type="text"><![CDATA[引言 MapReduce设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的代码设计经验总结； 使用设计模式的目的：使用设计模式是为了提高编码效率、提高代码重用率、让代码更容易被他人理解、保证代码可靠性； 设计模式千万种，本文为您梳理出来最重要、最常用的几种设计模式，方便理解和掌握； 本文的每一种设计模式都搭配了实例程序，以及输入和输出，让您更好更快地理解； 计数（Counting）一 问题定义：在数据文件中包含大量的记录，每条记录中包含了某个实体的若干数值属性，目标问题是要计算每个实体的某个数值属性的函数表达式值，例如求和、平均值等； 具体问题描述：现在有一个英文文件，需要统计其中每个单词的个数（wordcount）； 解决方案：在map中分离每个单词，传入reduce，在reduce中将每个单词的value相加； 程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package wordcountTest;import java.io.IOException;import java.util.StringTokenizer;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.*;import org.apache.hadoop.mapreduce.Job;import org.apache.hadoop.mapreduce.Mapper;import org.apache.hadoop.mapreduce.Reducer;import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;import org.apache.hadoop.util.GenericOptionsParser;public class WordCount &#123; public static class Map extends Mapper&lt;LongWritable, Text, Text, IntWritable&gt;&#123; private final static IntWritable one = new IntWritable(1); // type of output value private Text word = new Text(); // type of output key public void map(LongWritable key, Text value, Context context ) throws IOException, InterruptedException &#123; StringTokenizer itr = new StringTokenizer(value.toString()); // line to string token while (itr.hasMoreTokens()) &#123; word.set(itr.nextToken()); // set word as each input keyword context.write(word, one); // create a pair &lt;keyword, 1&gt; &#125; &#125; &#125; public static class Reduce extends Reducer&lt;Text,IntWritable,Text,IntWritable&gt; &#123; private IntWritable result = new IntWritable(); public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context ) throws IOException, InterruptedException &#123; int sum = 0; // initialize the sum for each keyword for (IntWritable val : values) &#123; sum += val.get(); &#125; result.set(sum); context.write(key, result); // create a pair &lt;keyword, number of occurences&gt; &#125; &#125; // Driver program public static void main(String[] args) throws Exception &#123; Configuration conf = new Configuration(); String[] otherArgs = new GenericOptionsParser(conf, args).getRemainingArgs(); // get all args if (otherArgs.length != 2) &#123; System.err.println("Usage: WordCount &lt;in&gt; &lt;out&gt;"); System.exit(2); &#125; // create a job with name "wordcount" Job job = new Job(conf, "wordcount"); job.setJarByClass(WordCount.class); job.setMapperClass(Map.class); job.setReducerClass(Reduce.class); // uncomment the following line to add the Combiner job.setCombinerClass(Reduce.class); // set output key type job.setOutputKeyClass(Text.class); // set output value type job.setOutputValueClass(IntWritable.class); //set the HDFS path of the input data FileInputFormat.addInputPath(job, new Path(otherArgs[0])); // set the HDFS path for the output FileOutputFormat.setOutputPath(job, new Path(otherArgs[1])); //Wait till job completion System.exit(job.waitForCompletion(true) ? 0 : 1); &#125;&#125; 示例输入输出： 123456789输入：一篇英文文章，单词之间用空格分割apple banana banana yellowyellow orange apple orange输出：词频统计结果apple 2banana 2yellow 2orange 2 计数（Counting）二 具体问题描述：输入文件为两列，分别为用户手机号和流量数，现需要统计每个用户的总流量数； 解决方案：map中将每个用户的手机号、流量分别作为key和value传入reduce，由reduce来统计总流量数； 程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package wordcountTest;import java.io.IOException;import java.util.StringTokenizer;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.*;import org.apache.hadoop.mapreduce.Counter;import org.apache.hadoop.mapreduce.Job;import org.apache.hadoop.mapreduce.Mapper;import org.apache.hadoop.mapreduce.Reducer;import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;import org.apache.hadoop.util.GenericOptionsParser;public class WordCount &#123; public static class Map extends Mapper&lt;LongWritable, Text, Text, IntWritable&gt;&#123; private final static IntWritable one = new IntWritable(1); // type of output value private Text user = new Text(); // type of output key private IntWritable flow = new IntWritable(); public void map(LongWritable key, Text value, Context context ) throws IOException, InterruptedException String line = value.toString(); String [] array = line.split("\t"); if(array.length==2)&#123; user.set(array[0]); flow = new IntWritable(Integer.parseInt(array[1])); context.write(user, flow); &#125;else&#123; return; &#125; &#125; &#125; public static class Reduce extends Reducer&lt;Text,IntWritable,Text,IntWritable&gt; &#123; private IntWritable result = new IntWritable(); public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context ) throws IOException, InterruptedException &#123; int sum = 0; // initialize the sum for each keyword for (IntWritable val : values) &#123; sum += val.get(); &#125; result.set(sum); context.write(key, result); // create a pair &lt;keyword, number of occurences&gt; &#125; &#125; // Driver program public static void main(String[] args) throws Exception &#123; Configuration conf = new Configuration(); String[] otherArgs = new GenericOptionsParser(conf, args).getRemainingArgs(); // get all args System.out.println(System.getenv("HADOOP_HOME")); if (otherArgs.length != 2) &#123; System.err.println("Usage: WordCount &lt;in&gt; &lt;out&gt;"); System.exit(2); &#125; // create a job with name "wordcount" Job job = new Job(conf, "userflow"); job.setJarByClass(WordCount.class); job.setMapperClass(Map.class); job.setReducerClass(Reduce.class); // uncomment the following line to add the Combiner // job.setCombinerClass(Reduce.class); // set output key type job.setOutputKeyClass(Text.class); // set output value type job.setOutputValueClass(IntWritable.class); //set reduce number job.setNumReduceTasks(1); //set the HDFS path of the input data FileInputFormat.addInputPath(job, new Path(otherArgs[0])); // set the HDFS path for the output FileOutputFormat.setOutputPath(job, new Path(otherArgs[1])); //Wait till job completion System.exit(job.waitForCompletion(true) ? 0 : 1); &#125;&#125; 示例输入输出： 1234567891011输入：用户手机号和流量，用空格分割13500000000 1013800000000 2013500000000 2013800000000 1518700000000 20输出：每个手机号的总流量13500000000 3013800000000 3518700000000 20 分类（classfication） 问题定义：在数据文件中包含大量的记录，每条记录中包含了某个实体的若干属性，目标问题是在给定一个计算函数的情况下，将此计算函数计算后得到的结果相同的实体放在一起； 具体问题描述：输入数据为两列，分别是手机号和其访问的网址，目的是统计同一个网址有哪些手机号访问过； 解决方案：map阶段把网址、手机号分别作为key、value传入reduce，由reduce实现分类； 程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package wordcountTest;import java.io.IOException;import java.util.StringTokenizer;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.*;import org.apache.hadoop.mapreduce.Counter;import org.apache.hadoop.mapreduce.Job;import org.apache.hadoop.mapreduce.Mapper;import org.apache.hadoop.mapreduce.Reducer;import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;import org.apache.hadoop.util.GenericOptionsParser;public class WordCount &#123; public static class Map extends Mapper&lt;LongWritable, Text, Text, LongWritable&gt;&#123; private final static IntWritable one = new IntWritable(1); // type of output value private Text webPage = new Text(); // type of output key private LongWritable flow = new LongWritable(); public void map(LongWritable key, Text value, Context context ) throws IOException, InterruptedException &#123; String line = value.toString(); String [] array = line.split(" "); if(array.length==2)&#123; webPage.set(array[1]); flow = new LongWritable(Long.parseLong(array[0])); context.write(webPage,flow); &#125;/*else&#123; return; &#125;*/ &#125; &#125; public static class Reduce extends Reducer&lt;Text, LongWritable, Text, LongWritable&gt; &#123; private IntWritable result = new IntWritable(); public void reduce(Text key, Iterable&lt;LongWritable&gt; values, Context context ) throws IOException, InterruptedException &#123; for (LongWritable val : values) &#123; context.write(key, val); &#125; &#125; &#125; // Driver program public static void main(String[] args) throws Exception &#123; Configuration conf = new Configuration(); String[] otherArgs = new GenericOptionsParser(conf, args).getRemainingArgs(); // get all args System.out.println(System.getenv("HADOOP_HOME")); if (otherArgs.length != 2) &#123; System.err.println("Usage: WordCount &lt;in&gt; &lt;out&gt;"); System.exit(2); &#125; // create a job with name "wordcount" Job job = new Job(conf, "userflow"); job.setJarByClass(WordCount.class); job.setMapperClass(Map.class); job.setReducerClass(Reduce.class); // uncomment the following line to add the Combiner // job.setCombinerClass(Reduce.class); // set output key type job.setOutputKeyClass(Text.class); // set output value type job.setOutputValueClass(LongWritable.class); //set reduce number job.setNumReduceTasks(3); //set the HDFS path of the input data FileInputFormat.addInputPath(job, new Path(otherArgs[0])); // set the HDFS path for the output FileOutputFormat.setOutputPath(job, new Path(otherArgs[1])); //Wait till job completion System.exit(job.waitForCompletion(true) ? 0 : 1); &#125;&#125; 示例输入输出： 12345678910111213141516171819输入：手机号和网址，用空格分割18500000001 sina.com18500000002 souhu.com18500000003 sina.com18500000004 sina.com18500000005 souhu.com18500000006 github.com18500000007 sina.com18500000008 github.com输出：每个网址对应的访问过它的手机号github.com 18500000006github.com 18500000008sina.com 18500000001sina.com 18500000003sina.com 18500000004sina.com 18500000007souhu.com 18500000002souhu.com 18500000005 说明：本程序并不能实现将每一个网址放入单独的文件输出，这是因为在“shuffle”过程中，计算出的partitionID相同的key被分到一个reduce中，然而，不同的key的partitionID可能相同，即同一个key肯定被分到同一个reduce，但是同一个reduce中可能有不同的key，所以上述算法不能实现完全分类。关于shuffle请参考我的另一篇博客Mapreduce过程详解 过滤（filtering） 问题定义：在数据文件中包含大量的记录，每条记录中包含了某个实体的若干属性，目标问题是在将符合某个条件的记录取出（或进行格式转换）； 具体问题描述：输入文件为三列：手机号、属性、访问网站，目标是将属性为0的记录过滤掉； 解决方案：map中将前两列作为key，最后一列为value，判断属性后输出过滤结果即可，不需要reduce过程； 程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package wordcountTest;import java.io.IOException;import java.util.StringTokenizer;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.*;import org.apache.hadoop.mapreduce.Counter;import org.apache.hadoop.mapreduce.Job;import org.apache.hadoop.mapreduce.Mapper;import org.apache.hadoop.mapreduce.Reducer;import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;import org.apache.hadoop.util.GenericOptionsParser;public class WordCount &#123; public static class Map extends Mapper&lt;Object, Text, String, Text&gt; &#123; private final static IntWritable one = new IntWritable(1); private KVcount user = new KVcount(); // type of output key private Text webPage = new Text(); public void map(Object key, Text value, Context context ) throws IOException, InterruptedException &#123; String line = value.toString(); String [] array = line.split(" "); if(array.length==3)&#123; user.setphoneNum(Long.parseLong(array[0])); user.setattribute(Integer.parseInt(array[1])); webPage = new Text(array[2]); if(user.attribute!=0)&#123; context.write(String.valueOf(user.phoneNum)+" "+String.valueOf(user.attribute),webPage); &#125; &#125;else&#123; return; &#125; &#125; &#125; //本程序不需要reduce过程 public static class Reduce extends Reducer&lt;KVcount, Text, Text, LongWritable&gt; &#123; private IntWritable result = new IntWritable(); public void reduce(Text key, Iterable&lt;LongWritable&gt; values, Context context) throws IOException, InterruptedException &#123; &#125; &#125; // Driver program public static void main(String[] args) throws Exception &#123; Configuration conf = new Configuration(); String[] otherArgs = new GenericOptionsParser(conf, args) .getRemainingArgs(); // get all args System.out.println(System.getenv("HADOOP_HOME")); if (otherArgs.length != 2) &#123; System.err.println("Usage: WordCount &lt;in&gt; &lt;out&gt;"); System.exit(2); &#125; // create a job with name "wordcount" Job job = new Job(conf, "userflow"); job.setJarByClass(WordCount.class); job.setMapperClass(Map.class); // job.setReducerClass(Reduce.class); // uncomment the following line to add the Combiner // job.setCombinerClass(Reduce.class); // set output key type job.setMapOutputKeyClass(KVcount.class); job.setMapOutputValueClass(Text.class); // job.setOutputKeyClass(Text.class);// // set output value type// job.setOutputValueClass(LongWritable.class); // set reduce number job.setNumReduceTasks(0); // set the HDFS path of the input data FileInputFormat.addInputPath(job, new Path(otherArgs[0])); // set the HDFS path for the output FileOutputFormat.setOutputPath(job, new Path(otherArgs[1])); // Wait till job completion System.exit(job.waitForCompletion(true) ? 0 : 1); &#125;&#125; 示例输入输出 123456789101112131415输入：手机号、属性、网站18500000001 0 sina.com18500000002 0 souhu.com18500000003 1 sina.com18500000004 0 sina.com18500000005 1 souhu.com18500000006 1 github.com18500000007 1 sina.com18500000008 0 github.com输出：属性为1的被过滤出来18500000003 1 sina.com18500000005 1 souhu.com18500000006 1 github.com18500000007 1 sina.com 排序（Sorting） 问题定义：在数据文件中包含大量的记录，每条记录中包含了某个实体的若干属性，目标问题是在将记录按照一定规则排序后输出； 具体问题描述：输入为三列，手机号、上行流量、下行流量，要求计算每个手机号的总流量并按照从小到大的顺序输出； 解决方案：在map中将上下行流量相加，得出总流量，以&lt;手机号，总流量&gt;形式输出；reduce中将每个手机号按照总流量从小到大的顺序排序后输出； 程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package wordcountTest;import java.io.IOException;import java.util.ArrayList;import java.util.Arrays;import java.util.Collection;import java.util.Comparator;import java.util.List;import java.util.StringTokenizer;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.*;import org.apache.hadoop.mapreduce.Counter;import org.apache.hadoop.mapreduce.Job;import org.apache.hadoop.mapreduce.Mapper;import org.apache.hadoop.mapreduce.Reducer;import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;import org.apache.hadoop.util.GenericOptionsParser;import com.sun.org.apache.bcel.internal.generic.NEW;import com.sun.xml.internal.bind.v2.runtime.unmarshaller.XsiNilLoader.Array;import com.sun.xml.internal.ws.policy.privateutil.PolicyUtils.Collections;public class WordCount &#123; public static class Map extends Mapper&lt;Object, Text, LongWritable, LongWritable&gt; &#123; private final static IntWritable one = new IntWritable(1); private LongWritable phoneNumber = new LongWritable(); private LongWritable totalFlow = new LongWritable(); //记录总流量 public void map(Object key, Text value, Context context) throws IOException, InterruptedException &#123; String line = value.toString(); String[] array = line.split(" "); totalFlow = new LongWritable(Long.parseLong(array[1]) + Long.parseLong(array[2])); //上下行流量相加 if (array.length == 3) &#123; context.write(new LongWritable(Long.parseLong(array[0])), totalFlow); &#125; else &#123; return; &#125; &#125; &#125; public static class Reduce extends Reducer&lt;LongWritable, LongWritable, LongWritable, Object&gt; &#123; private IntWritable result = new IntWritable(); public void reduce(LongWritable key, Iterable&lt;LongWritable&gt; values, Context context) throws IOException, InterruptedException &#123; List &lt;Long&gt; totalUserFlow = new ArrayList&lt;Long&gt;(); for (LongWritable val : values) &#123; totalUserFlow.add(val.get()); &#125; Object[] arrObjects =totalUserFlow.toArray(); Arrays.sort(arrObjects); for(int j=0; j&lt;arrObjects.length; j++)&#123; context.write(key, arrObjects[j]); &#125; &#125; &#125; // Driver program public static void main(String[] args) throws Exception &#123; Configuration conf = new Configuration(); String[] otherArgs = new GenericOptionsParser(conf, args) .getRemainingArgs(); // get all args System.out.println(System.getenv("HADOOP_HOME")); if (otherArgs.length != 2) &#123; System.err.println("Usage: WordCount &lt;in&gt; &lt;out&gt;"); System.exit(2); &#125; // create a job with name "wordcount" Job job = new Job(conf, "userflow"); job.setJarByClass(WordCount.class); job.setMapperClass(Map.class); job.setReducerClass(Reduce.class); // uncomment the following line to add the Combiner // job.setCombinerClass(Reduce.class); // set output key type job.setMapOutputKeyClass(LongWritable.class); job.setMapOutputValueClass(LongWritable.class); job.setOutputKeyClass(LongWritable.class); job.setOutputValueClass(Object.class); // set reduce number job.setNumReduceTasks(1); // set the HDFS path of the input data FileInputFormat.addInputPath(job, new Path(otherArgs[0])); // set the HDFS path for the output FileOutputFormat.setOutputPath(job, new Path(otherArgs[1])); // Wait till job completion System.exit(job.waitForCompletion(true) ? 0 : 1); &#125;&#125; 示例输入输出： 1234567891011输入：手机号、上行流量、下行流量，以空格分割15700000000 3333 222213900000000 3333 444415700000000 1111 222213900000000 2222 1111输出：按照总流量大小排序输出13900000000 333313900000000 777715700000000 333315700000000 5555 去重计数（Distinct Counting） 问题定义：在数据文件中包含大量的记录，每条记录中包含了某个实体的若干属性，目标问题是在计算某几个属性组合后去掉相同重复组合后，其中某一属性的统计值； 具体问题的描述：输入为两列，手机号、访问网址，要求统计每个网址都有几种手机号访问； 解决方案：map中将网址作为key、手机号作为value，发送给reduce；计数、去重的工作都由reduce完成；去重的工作由HashSet完成； 程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package wordcount_test;import java.io.IOException;import java.util.ArrayList;import java.util.HashSet;import java.util.List;import java.util.Set;import java.util.StringTokenizer;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.io.LongWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Job;import org.apache.hadoop.mapreduce.Mapper;import org.apache.hadoop.mapreduce.Reducer;import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;public class WordCount &#123; public static class TokenizerMapper extends Mapper&lt;Object, Text, Text, LongWritable&gt;&#123; private LongWritable phoneNum = new LongWritable(); private Text webPage = new Text(); public void map(Object key, Text value, Context context ) throws IOException, InterruptedException &#123; String line = value.toString(); String[] array = line.split(" "); if(array.length==2)&#123; phoneNum = new LongWritable(Long.parseLong(array[0])); webPage = new Text(array[1]); context.write(webPage, phoneNum); &#125;else&#123; return; &#125; &#125; &#125; public static class IntSumReducer extends Reducer&lt;Text,LongWritable, Text, IntWritable&gt; &#123; private IntWritable result = new IntWritable(); public void reduce(Text key, Iterable&lt;LongWritable&gt; values, Context context ) throws IOException, InterruptedException &#123; int sum = 0; Set &lt;String&gt; phoneNumSet = new HashSet&lt;String&gt;(); for(LongWritable val : values)&#123; phoneNumSet.add(val.toString()); &#125; for(String s : phoneNumSet)&#123; sum++; &#125; result.set(sum); context.write(key, result); &#125; &#125; public static void main(String[] args) throws Exception &#123; Configuration conf = new Configuration(); Job job = Job.getInstance(conf, "word count"); job.setJarByClass(WordCount.class); job.setMapperClass(TokenizerMapper.class);// job.setCombinerClass(IntSumReducer.class); job.setReducerClass(IntSumReducer.class); job.setNumReduceTasks(1); job.setMapOutputKeyClass(Text.class); job.setMapOutputValueClass(LongWritable.class); job.setOutputKeyClass(Text.class); job.setOutputValueClass(IntWritable.class); FileInputFormat.addInputPath(job, new Path(args[0])); FileOutputFormat.setOutputPath(job, new Path(args[1])); System.exit(job.waitForCompletion(true) ? 0 : 1); &#125;&#125; 示例输入输出： 1234567891011输入：手机号、访问网址，用空格分割15700000000 qq.com13900000000 qq.com13900000000 sina.com15700000000 qq.com15700000000 sina.com12900000000 sina.com输出：每个网址对应的手机号种类数量qq.com 2sina.com 3 相关计数（Cross-Correlation） 问题定义：输入若干数组，每个数组是由若干实体构成，目标问题是计算数组中实体以一定条件要求成对出现的次数或概率； 具体问题描述：输入数据是2列，手机号、访问网址，现在需要统计每个手机号访问每个网址的次数； 解决方案：Stripes方法–map中将手机号作为key、访问网址和计数值1作为value，reduce中进行统计；Pairs方法–map中将手机号和访问网址作为key、计数值1作为value，reduce中进行统计； 程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899Stripes方法:package wordcount_test;import java.io.IOException;import java.util.ArrayList;import java.util.HashSet;import java.util.List;import java.util.Set;import java.util.StringTokenizer;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.io.LongWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Job;import org.apache.hadoop.mapreduce.Mapper;import org.apache.hadoop.mapreduce.Reducer;import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;public class WordCount &#123; public static class TokenizerMapper extends Mapper&lt;Object, Text, LongWritable, Text&gt;&#123; private LongWritable phoneNum = new LongWritable(); private Text webPage = new Text(); public void map(Object key, Text value, Context context ) throws IOException, InterruptedException &#123; String line = value.toString(); String[] array = line.split(" "); if(array.length==2)&#123; phoneNum = new LongWritable(Long.parseLong(array[0])); webPage = new Text(array[1]); context.write(phoneNum, webPage); &#125;else&#123; return; &#125; &#125; &#125; public static class IntSumReducer extends Reducer&lt;LongWritable,Text, String, IntWritable&gt; &#123; private IntWritable result = new IntWritable(); public void reduce(LongWritable key, Iterable&lt;Text&gt; values, Context context ) throws IOException, InterruptedException &#123; int sum = 0; Text webText; String webString; List &lt;String&gt; webList = new ArrayList&lt;String&gt;(); Set &lt;String&gt; webSet = new HashSet&lt;String&gt;(); //将values迭代器内容放入list中，方便之后重复访问 for(Text val : values)&#123; webList.add(val.toString()); &#125; //唯一的网址存入webSet for (String val : webList) &#123; webSet.add(val); &#125; //分别统计当前手机号（key）的每个访问网址的次数并输出 for(String s: webSet)&#123; for (String web : webList) &#123; if(s.equals(web))&#123; sum++; &#125; &#125; result.set(sum); context.write(key.toString()+" "+s, result); sum =0; &#125; &#125; &#125; public static void main(String[] args) throws Exception &#123; Configuration conf = new Configuration(); Job job = Job.getInstance(conf, "word count"); job.setJarByClass(WordCount.class); job.setMapperClass(TokenizerMapper.class);// job.setCombinerClass(IntSumReducer.class); job.setReducerClass(IntSumReducer.class); job.setNumReduceTasks(1); job.setMapOutputKeyClass(LongWritable.class); job.setMapOutputValueClass(Text.class); job.setOutputKeyClass(String.class); job.setOutputValueClass(IntWritable.class); FileInputFormat.addInputPath(job, new Path(args[0])); FileOutputFormat.setOutputPath(job, new Path(args[1])); System.exit(job.waitForCompletion(true) ? 0 : 1); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182pairs方法：package wordcount_test;import java.io.IOException;import java.io.StringWriter;import java.util.ArrayList;import java.util.HashSet;import java.util.List;import java.util.Set;import java.util.StringTokenizer;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.io.LongWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Job;import org.apache.hadoop.mapreduce.Mapper;import org.apache.hadoop.mapreduce.Reducer;import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;public class WordCount &#123; public static class TokenizerMapper extends Mapper&lt;Object, Text, Text, IntWritable&gt;&#123; private final static IntWritable one = new IntWritable(1); private String phoneNum = new String(); private String webPage = new String(); public void map(Object key, Text value, Context context ) throws IOException, InterruptedException &#123; String line = value.toString(); String[] array = line.split(" "); if(array.length==2)&#123; phoneNum = array[0]; webPage = array[1]; context.write(new Text(phoneNum+" "+webPage), one); &#125;else&#123; return; &#125; &#125; &#125; public static class IntSumReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt; &#123; private IntWritable result = new IntWritable(); public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context ) throws IOException, InterruptedException &#123; int sum = 0; for (IntWritable val : values) &#123; sum ++; &#125; result.set(sum); context.write(key, result); &#125; &#125; public static void main(String[] args) throws Exception &#123; Configuration conf = new Configuration(); Job job = Job.getInstance(conf, "word count"); job.setJarByClass(WordCount.class); job.setMapperClass(TokenizerMapper.class);// job.setCombinerClass(IntSumReducer.class); job.setReducerClass(IntSumReducer.class); job.setNumReduceTasks(1); job.setMapOutputKeyClass(Text.class); job.setMapOutputValueClass(IntWritable.class); job.setOutputKeyClass(Text.class); job.setOutputValueClass(IntWritable.class); FileInputFormat.addInputPath(job, new Path(args[0])); FileOutputFormat.setOutputPath(job, new Path(args[1])); System.exit(job.waitForCompletion(true) ? 0 : 1); &#125;&#125; 示例输入输出： 123456789101112输入：手机号、网址，中间用空格分割15700000000 qq.com13900000000 qq.com13900000000 sina.com15700000000 qq.com15700000000 sina.com输出：手机号、访问网址和对应的次数统计结果13900000000 qq.com 113900000000 sina.com 115700000000 qq.com 215700000000 sina.com 1]]></content>
      <categories>
        <category>hadoop</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>mapreduce</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号制作技巧]]></title>
    <url>%2F2015%2F05%2F06%2F2015-5-6-We-Chat-Public%2F</url>
    <content type="text"><![CDATA[引言 微信公众号是当今最受欢迎的宣传和推广平台，它凭借微信这个大舞台，让许多个人和小微企业有了宣传自己和推广自己的有力武器； 要想让别人更多的关注和分享抑或是收藏自己的微信公众号，就必须做得漂亮，本文介绍一些我在做公众号的经验和总结； 微信公众号的使用方法 注册用户：https://mp.weixin.qq.com/cgi-bin/loginpage?t=wxm2-login&amp;lang=zh_CN； 自定义菜单中可以添加手机下方的菜单项，方便用户查看； 用户管理中可以给用户分组，发布的时候可以更有针对性投放广告； 素材管理中可以添加素材，添加后可选择是否发布； 统计菜单中可以查看分类的统计数据，方便决策； 公众号设置中可以获取二维码； 微信公众号编辑方法 登陆微信公众号； 点击素材管理&gt;新建“单图文消息”； 在里面编辑相应的标题、作者、封面、摘要、正文，正文内容可以用下面推荐的编辑器、素材库编辑； 编辑完成后，单击“预览”输入自己的微信号可预览； 预览检查没有问题后，点击“保存并发布”，扫描二维码向管理员申请发布； 在自定义菜单中加入自己做的这个图文消息的菜单，方便用户查看； 整理“图片库”中的图片，将自己用到的图片放在相应的分组中； 推荐素材库 仅仅用微信公众号自带的素材无法制作出漂亮的页面，下面提供几个素材库； 素材库使用方法：注册账号后即可使用，可以通过添加素材、复制、粘贴的方法将素材放入微信公众号的素材中； 135编辑器 秀米编辑器 微信编辑器 美化二维码工具 logo的制作：AAA Logo软件； 几个技巧 添加gif动图：从网上下载所需gif动图，保存为…gif格式，微信公众号编辑时正常上传这张图片即可，普通用户也支持gif图片的显示； 添加指纹识别：从网上下载指纹图样、从公众号中的“公众号设置”菜单下载合适大小的二维码图样，用美图秀秀的拼图功能无缝拼接两张图片，将制作好的图片放入公众号编辑器中即可； 微信公众号样式参考 《Hadoop大数据处理》免费教程系列6-MapReduce原理 SQL on Hadoop性能对比－Hive、Spark SQL、Impala]]></content>
      <categories>
        <category>WeChat</category>
      </categories>
      <tags>
        <tag>publicity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gitlab基本原理]]></title>
    <url>%2F2015%2F04%2F26%2F2015-4-26-gitlab-explain%2F</url>
    <content type="text"><![CDATA[引言 gitlab是常用的版本管理工具。 相对于github来说，gitlab不收费，而且基本具有github的全部功能，因此特别适合小微企业和学校实验室等用作版本管理工具。 gitlab具有比svn强大多的功能，在代码控制、版本控制、任务进度控制、甚至工资绩效等方面发挥着重大作用。 gitlab中有很多容易混淆的过程和名字，本文解释了gitlab的运行过程，可作为初学者的参考。 本地和远端 特别要注意的是，本地和远端remote是相对的概念。一般来说将PC作为本地，服务器作为远端。事实上，普通的PC也可以作为远端，本地和远端的地位是平行的，不存在远端地位较高只说。 远端的名字默认为origin，所以push的时候一般用命令git push origin master，即将本地的内容拉取到名字为origin的远端的master分支上去。如果远端名称不叫origin，则命令要相应变化。 本地和远端的交互动作 下图是网上找到的一张图，清晰地描绘了git本地和远端的交互过程： fetch：将本地已有的工程从远端拉取到本地repository； clone：将本地没有的工程从远端拉取到本地repository； pull：直接将本地没有的工程从远端拉取到本地工作目录； checkout：将本地repository存储的某个版本作为工作目录； add：将本地的更改添加到索引中； commit：将索引中的修改一次性写入本地repository； push：将repository中的更改拉取到远端，实现版本非本地端备份； checkout和commit是相反动作，clone/fetch和push是相反动作； 版本管理动作 上图中没有的一些动作，对于版本管理也必不可少，下面将介绍。 branch：分支，分支的作用是方便大家同时开发不同的模块。 merge：将两个分支合并，比如自己的分支和master合并。 哈希值：gitlab会自动为每个版本计算哈希值，用哈希值来识别版本。 gitlab常用命令 git clone url：clone到本地； git add .：添加改动到index; git commit -a -m &quot;...&quot;：添加改动到本地库； git push origin master：这个命令上面已经说过，将本地某个版本push到远端，实现版本备份； gitlab中经典的开发场景解析 最常见的开发场景就是用netbeans中代码管理，下面是流程。 第一步：在远端建立自己的分支； 第二步：将这个分支clone到本地（netbeans中team菜单项&gt;git&gt;clone），注意要将master和自己的分支都clone下来； 第三步：选择netbeans菜单项team&gt;git&gt;repository browser，右键单击remote里面的自己的分支，选择checkout revision，就将本地工作目录设定为了自己的分支； 第四步：按照要求修改代码； 第五步：修改完成代码后，右键单击工程，选择git&gt;commit，然后提交commit信息，将改动添加到本地库； 第六步：commit后，右键单击工程，选择git&gt;remote&gt;push，然后将本地的修改push到远端备份； 第七步：在远端提交merge request，等待上级领导的审阅和合并通过。到此为止，一个完整的有gitlab版本控制参与的开发流程就结束了！]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDFS详解]]></title>
    <url>%2F2015%2F04%2F25%2F2015-4-25-hdfs%2F</url>
    <content type="text"><![CDATA[引言 HDFS是Hadoop中的重要组件，是一种重要而文件存储机制。 HDFS可以同时保证文件读写的效率和安全性，不怕宕机和断电。 HDFS内部的机制相当复杂，本文会详细讲解这些机制的作用。 HDFS特点 流量大，流速并不快； 适合读写大块的文件，不适合读写大量小文件； HDFS的组件构成 client：如果用PC连接集群，则PC就是client，用户直接操纵client； namenode：HDFS管理者，保存各个文件块（默认64MB）的位置信息，保存各个datanode的状态信息，保存机架感知的信息，和datanode心跳通信； secondnamenode：namenode的备份； datanode：存储具体的文件块，每个文件块要在不同的机器上一共存储三份，保证文件的安全性； HDFS读文件的流程 client要读文件； client问namenode这个文件的几个块都放在那个datanode上面（一个文件块备有三份分别存在不同的datanode上面），优先选择离client近的数据； client获知datanode信息后，去相应的机器上读取文件块； client依次读取这个文件的所有文件块，组成完整的文件； 中间如果读取某个块出错，会从这个块的备份块所在datanode继续读取； HDFS写文件流程 client要写文件； client问namenode这个文件的几个块都要写在哪个datanode上面（HDFS的备份机制要求同一个文件块要写在三个datanode上面三份，其中两个datanode处于同一机架，另一个和他们不处于同一机架）； client获知datanode信息后，去相应的机器上写文件块（client先把数据全部写在datanode1上面，datanode1将数据某一块写在datanode2，datanode2将数据某一块写在datanode3，以此类推，最后这个大文件的每一块都在相应的机器上）； 这样做（而不是namenode同时向三台datanode写文件）的原因：client向datanode写的网络IO有限，但是datanode之间的网络IO非常宽，有利于并行； 如果写入过程出错，将文件写入这个datanode的节点会通知namenode写入失败，请求namenode重新分配datanode写入； 三个节点全部写入完毕后，分别ACK通知namenode写入完毕； HDFS容错机制 应对datanode可能坏掉：datanode和namenode间的心跳机制； 应对网络可能断掉：ACK握手协议等； 应对文件/硬盘可能坏掉：对文件块进行校验码或者纠错码验证，如MD5； 应对namenode坏掉：用secondnamenode定期镜像备份； 应对突然宕机造成的内存中的数据丢失：下面的FsImage+内存元数据+EditLog经典架构，这种架构既不只用内存（效率高但是安全性差），也不只用磁盘（效率低但是安全性好），一般是读/写数据直接面向内存，内存达到一定限值后写入磁盘，同时保证效率和安全性； HDFS机架感知 namenode保存机架树信息； 一个文件块存了三份，读文件时给client优先推荐离得近的那一份； 写文件时，每一个文件块都选取和client在一个机架上面的一台机器、和client相邻机架的两台机器，一共写三份； 这样做的好处：既保证了读写效率（一个机架上的网络IO比机架间的网络IO高），而且又在别的机架备份保证了安全性；]]></content>
      <categories>
        <category>hadoop</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>hdfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web技术名词解释]]></title>
    <url>%2F2015%2F04%2F15%2F2015-4-15-names-in-web-technology%2F</url>
    <content type="text"><![CDATA[引言 web开发框架中有很多技术，这些技术支撑着web开发向前发展。我们今天看到的各种各样的漂亮的网页也是在这些技术下得以实现的。本文梳理了web开发中的常用技术，作为参考。 浏览器端基础语言框架 html：页面显示语言，浏览器识别并解析； javascript：前端开发用的轻量级脚本语言，用于页面的控制和内容获取； E4X：javascript的扩展，向JavaScript添加了对 XML 的直接支持，是正式的javascript标准之一； 页面渲染技术 css（Cascading Style Sheets）：层叠样式表技术，用于新框架下的页面渲染； less：一种动态的css语言，在浏览器端解析； sass：一种动态的css语言，在服务器端解析； bootstrap（twitter支持）：由less编写的一套页面渲染框架（样式库），栅格系统和屏幕适配性是它的优势所在； Javascript常用IDE Sublime Text ； WebStorm ； netbeans； Brackets ； Atom； 常用Javascript辅助工具 grunt：自动完成js代码合并压缩等，支持自动化测试； node.js：充当浏览器的js解析器的功能，还可以外加很多插件，方便调试； bower：基于node.js，依赖管理工具，自动下载、管理、监测package的依赖关系； HTTP-server：基于node.js，轻量级的服务器，用于通过http协议访问本机文件夹； KARMA/Jasmine：基于node.js，前端代码单元测试工具（相当于java的JUnit），KARMA提供测试工具驱动，Jasmine提供测试语法； protractor：针对angularjs的自动化测试工具，不能用于其他js库； selenium：Web应用程序测试的工具，自动完成用户操作以便测试网站，可用于轮播系统的制作； 前端网页开发框架 框架名称 描述 优缺点 依赖 angularjs 免费，google支持；辅助JavaScript的网页开发框架；和ExtJS处于竞争地位； 灵活性高但是完备性中等；UI控件库不如ExtJS全面，但是可定制性强；不直接支持移动端； 由于没有全面的UI控件，一般用angularUI或者bootstrap进行页面布局和渲染； ExtJS 收费；辅助JavaScript的网页开发框架；和angularjs处于竞争地位； 完备性高但是灵活性中等；拥有非常全面的UI控件库，浏览器间可移植性极强，但是用户定制性稍差；直接支持移动端； jQueryUI 免费； UI控件较为混乱；可定制性强；直接支持移动端； NEJ(Nice Easy Javascript) 网易前端开发框架；辅助JavaScript的网页开发框架； 前端框架支持库 支持库名称 描述 优缺点 jQuery 纯粹的JavaScript代码库，目的是简化DOM操作 和prototype做的事情相同，方法不同，jQuery火了，prototype没有火起来； prototype 纯粹的JavaScript代码库，目的是简化DOM操作 没有jQuery火 YUI(Yahoo! UI Library) 开放源代码的 JavaScript 函数库； 异步请求技术ajax（asynchronous javascript and xml）：此技术破除了旧的web框架“只能请求一次”的限制，使得程序员可以指定浏览器什么时候发出请求、发出什么请求、请求内容是什么，ajax已经封装在前端框架中（诸如angularjs等框架），无需人为添加库； 服务器端基础语言 php：开源脚本语言，用于小型web开发，服务器端语言，比java的学习成本和复杂度低得多，但是功能有限，比较简陋； java：后台可以用java去写； jsp（Java Server Pages）：动态网页技术标准，用于大型web开发，语言是在html中插入java； servlet：是一种面向底层的jsp； asp：动态服务器页面（Active Server Page），是一种后台编程脚本语言，可以与数据库交互； python：知乎和豆瓣在python写后台； .net：是Microsoft面向XML Web服务的平台，支持的原生语言是c#，.net目前只能运行在windows上； SSH框架 Struts2（view）：对浏览器请求处理的一整套框架； Spring（control）：提供了依赖注入的思想，提供了大量模板类，配合和支持Struts2完成对用户请求的页面响应； Hibernate（model）：面向java环境的对象/关系数据库映射工具，封装了和数据库的连接部分； 这种老框架的劣势：框架太多、太复杂； RESTful框架 RESTful（用java实现的话叫做JAX-RS）： 基于HTTP协议的（get put post等方法），一种分层的目录型的设计风格（任何资源可被唯一的URI访问到），支持JSON和XML格式的数据，在javaEE中具体表现为REST.java文件； 它之所以叫做RESTful指的是server端不用承担全部的页面内容传递和逻辑的全部任务，显示逻辑交由client端，剩下的（rest）交给server端； ORM（Object Relational Mapping，用java实现的话叫做JPA）： 一种在面向对象语言和数据库等数据源之间传递数据的桥梁，作用是数据映射，在javaEE中具体表现为entity.java文件； JAX-RS（Java API for RESTful Web Services）：RESTful设计风格在java中的具体表现，在java中具体表现为REST.java文件； JPA（java persistence API）：ORM标准在java中的具体表现，在java中具体表现为entity.java文件； 服务器软件 apache：跨平台，安全性高； tomcat：典型的jsp容器，由apache开源组织开发，免费的开放源代码的Web应用服务器，属于轻量级应用服务器，适合中小企业； jetty：典型的jsp容器，由eclipse基金会开发维护； glassfish：一款强健的商业兼容应用服务器，达到产品级质量，可免费用于开发、部署和重新分发； 数据格式 数据格式名称 描述 JOSN 一种数据格式，新版框架下浏览器请求数据时，服务器会返回这种格式的数据，可用javascript解析，可用ajax技术传输； XML 一种数据格式，比JOSN重，面向数据传输； 设计思想 设计思想 描述 DOM框架 是一种页面元素控制的设计思想，他的树形结构便于获取页面元素； MVC框架 是一种前端到后端的设计思想，model、view、controller三者分离，要什么请求什么，更加灵活，易于扩展和测试； 同源策略 网景公司（Netscape）提出的著名的安全策略，禁止服务器跨域读取数据； 组织团体 W3C（World Wide Web Consortium）：万维网联盟的缩写，是对网络标准制定的一个非赢利组织，致力在万维网发展方向上达成共识；]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MapReduce过程详解]]></title>
    <url>%2F2015%2F04%2F01%2F2015-4-1-mapreduce%2F</url>
    <content type="text"><![CDATA[引言 mapreduce的过程看似简单，其实，要保证数据处理过程中的高效率、高容错性，mapreduce中有很多精巧的机制值得我们学习和参考。本文主要介绍mapreduce的过程以及其中涉及到的重要的思想。 Mapreduce总体过程 作业启动 作业初始化 作业/任务调度 Map任务执行 shuffle Reduce任务执行 作业完成 作业启动 用户编写mapreduce程序，并且打成jar包，将jar包放在本地集群，将输入数据放在HDFS上面； 用户执行”hadoop jar“命令，启动作业； JobClient是大boss，他收到任务后，向”业务主管“JobTracker申请新的作业ID，YARN界面上显示的ID即job ID； JobClient检查输入输出路径、检查这个路径的权限等，如果一切正常则开始下一步； 作业初始化 JobTracker可能会收到JobClient不同作业的请求，维护一个队列处理这些请求，交由作业调度器调度作业（见【附录–作业调度机制】）； 分片数量由用户指定（见【附录–map数量的确定】），分片数量等于map数量，JobTracker根据map数量创建一批map任务； 作业/任务调度 map任务分配是被动的而不是主动的。TaskTracker启动后，通过心跳和JobTracker保持联系并查询是否有任务可做，如果有任务则被分配任务； 每个TaskTracker有固定数量的map任务槽和reduce任务槽若干个，分别用来接收map和reduce任务，系统会自动优先填满map任务槽，待map任务槽被填满后才会被分配reduce任务（因为map的优先级总是高于reduce）； Map任务执行 某个TaskTracker领取map任务； 这个TaskTracker将作业的jar包文件和相关配置文件复制到本地工作目录下（传输jar包而不传输数据的原则，代码靠近数据的原则）； TaskTracker启动单独的JVM运行这个map任务； map的输出结果中相同的key不一定在一块，为了下面的combine过程简洁，这里对map输出结果中的key进行快速排序（sort过程）； map任务的结果存入内存，并在内存有限的情况下定期写入磁盘（spill过程），将某一个map的输出的相同的key的value合并（即combine过程），spill与combine经常交替进行； 多次spill会产生许多小文件在磁盘中，merge过程将他们合并； TaskTracker和JobTracker定期通信，报告进度； shuffle map的输出是（key, value）对（下面简称KV对）； 将某一个map的输出的相同的key的value合并，即combine过程； 决定这个map的结果给哪一个reduce：通过hash(key)mod(reduce数目)计算出partition的ID，上述的key就被分配给这个partition；一个partition中可以有多个key，但是同一个key只存在于一个partition中；一个partition对应一个reduce； 有的partition负载可能很重，有的则很轻，需要通过一定的协调机制平衡负载（比如根据自己的需求重写partition函数）； partiton作为reduce的输入，每个reducer获得的是每个Key在在每个mapper上输出的结果，它需要使用reduce函数把相同Key的不同mapper的输出统计在一起。 Reduce任务执行 在部分map任务执行完后（不用等到所有map任务结束）JobTracker开始分配reduce任务到TaskTracker； TaskTracker启动单独的JVM运行这个reduce任务； TaskTracker从远地下载中间结果文件到本地（指partition文件、一个partition对应一个reduce），为reduce任务真正开展做准备，但不会开始执行reduce()函数； 待所有的map任务都完成以后，JobTracker通知所有的TaskTracker开始做reduce任务； TaskTracker和JobTracker定期通信，报告进度； 作业完成 每个TaskTracker都将reduce任务的结果文件放到HDFS的临时文件中； 当所有reduce任务完成后，这些临时文件会合并成最终输出文件放在用户指定的输出目录下； JobTracker收到所有任务的完成通知后，并通知JobClient作业已经完成，YARN管理系统会显示已完成的信息； 附录一：map数量的确定 用户通过指定期望的map数和期望的分片最小值来调控map数量，具体是系统通过下面几步算出map个数； 附录二：作业调度机制 JobTracker可同时调度多个作业任务，具体有如下几种调度机制： 先进先出调度机制：设定VERY_HIGH、HIGH、NORMAL、LOW、VERY_LOW五个等级的优先级，任务优先级高的先执行，如果优先级相同，先进入调度器的任务先执行； 公平调度机制：JobTracker掌管着所有的资源，平均为进入队列的任务分配资源，支持资源抢占； 能力调度器：如果一个任务所需资源多，就为他多分配资源，反之少分配资源； ###附录三：JobTracker容错机制 心跳机制：JobTracker和TaskTracker定期通信（通过mapred.tasktracker.expiry.interval设定间隔时间，默认为10分钟），TaskTracker报告任务完成情况；未正常返回的任务，JobTracker会重新分配TaskTracker去完成； 黑名单机制：每个job维护一个TaskTracker黑名单，一旦TaskTracker无法完成任务即进入黑名单，JobTracker不会再给他分配任务； 集群黑名单：如果一个TaskTracker进入job黑名单的次数过多，或者这个TaskTracker进入job黑名单的次数明显超过平均进入次数，则将其加入集群黑名单，以后不再向其分配任务； 检错机制：如果JobTracker发现某个TaskTracker不正常或者完成任务速度明天低于平均水平，JobTracker会将这个任务另外交由另外一个TaskTracker去完成，如果这个TaskTracker完成的非常快，则JobTracker认为原来的TaskTracker有问题，遂kill原TaskTracker进程，并且判断是否将其加入黑名单；]]></content>
      <categories>
        <category>hadoop</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>mapreduce</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MapReduce过程名词解释]]></title>
    <url>%2F2015%2F04%2F01%2F2015-4-1-mapreduce-name-explain%2F</url>
    <content type="text"><![CDATA[引言 在mapreduce的运行过程中，有很多精巧的机制保证整个作业运行在高效率、相对公平和高容错性的环境下。 mapreduce运行过程中（特别是shuffle过程中）有很多容易混淆的名词。本文通过罗列这些名词的含义来对这些过程加以解释说明。 名词解释 名词 含义 shuffle 将map的输出作为输入传给reducer的过程的总称； spill map的结果从内存往磁盘写数据的过程；中文译为“溢写”，但并不一定是当内存溢出后才写入磁盘； partitioner 指partitioner接口，作用是根据key或value及reduce的数量决定当前的这对输出数据应交给哪个reduce task处理； sort 指快速排序；当map内存占用达到一定比例时，需对于内存中的key做sort，以便combiner过程； combiner 将一个map内存中具有相同对的value加起来，以减少spill到磁盘的数据量；将已经写到磁盘的文件进行上述动作也称为combiner； merge 若map产生的数据量较大，一个map会有多个spill过程从而在磁盘中产生多个spill文件。将磁盘中多个spill文件合并成一个的过程称为spill；merge的本质是合并文件的过程，具有相同key的value并没有在merge过程中相加，而是在combiner中实现；]]></content>
      <categories>
        <category>hadoop</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>mapreduce</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[退出Docker后如何再次进入Hadoop运行环境]]></title>
    <url>%2F2015%2F03%2F12%2F2015-3-12-docker%2F</url>
    <content type="text"><![CDATA[引言 docker是单机上模拟集群的好工具。它既具有虚拟机的特性，同时，由于它不包含操作系统内核，docker比传统的的虚拟机显得更加轻量级。 本文主要讲述了在退出docker后，如何再次进入hadoop运行环境； docker再次进入hadoop运行环境的几个步骤 启动docker； 用secureCRT连接192.168.59.103，用户名docker，密码tcuser（官方默认初始密码）； 用docker images可以看到已经安装的master、slave1、slave2三个镜像； 用下面的命令启动三个镜像的容器： docker start master docker start slave1 docker start slave2 用docker ps可以看到已经启动的三个容器； 分别开三个选项卡，然后分别用下面命令进入相应容器（首次建立运行环境时已经配置过hosts文件，所以这里不用写ip）： docker attach master docker attach slave1 docker attach slave2 用chkconfig检查和hadoop相关的服务是否已经启动，没有启动的话按照类似下面的命令启动：service hadoop-hdfs-namenode start；]]></content>
      <categories>
        <category>hadoop</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DIY年夜饭2015]]></title>
    <url>%2F2015%2F02%2F18%2F2015-2-18-DIY%E5%B9%B4%E5%A4%9C%E9%A5%AD2015%2F</url>
    <content type="text"><![CDATA[引言 今年继续DIY全家人的年夜饭，先上图一张： 下面是我做的几道菜，如果您也对烹饪感兴趣，欢迎联系我，联系方式在“关于”额。 我做的年夜饭 三色菜丁：黄瓜、胡萝卜、虾仁。 清蒸草鱼： 炸鸡翅： 红烧肉： 鸡蛋南瓜汤：]]></content>
      <tags>
        <tag>cooking</tag>
        <tag>feeling</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java命名规范]]></title>
    <url>%2F2015%2F01%2F31%2F2015-1-31-java-style%2F</url>
    <content type="text"><![CDATA[引言 编写java程序时，程序的易读性是评判程序好坏的很重要的指标，那么写java时，对象的命名要注意哪些方面呢？请看本节分解！ 参考：google java style 命名注意事项 Package names：全部小写，不要加特殊字符，比如com.example.deepspace，以下写法是错误的com.example.deepSpace，com.example.deep_space； Class names：写成UpperCamelCase，比如HashIntegrationTest，Character; Method names：写成lowerCamelCase，比如sendMessage，testPop_emptyStack； Constant names：写成全部大写形式，比如CONSTANT_CASE,static final int NUMBER = 5;,static final ImmutableList&lt;String&gt; NAMES = ImmutableList.of(&quot;Ed&quot;, &quot;Ann&quot;);,static final Joiner COMMA_JOINER = Joiner.on(&#39;,&#39;);,static final SomeMutableType[] EMPTY_ARRAY = {};； 其他注意事项 不要在程序中写孤零零的数字，要么它有明确的含义（60×60×24），要么就将他定义为final常量放在程序最上面，程序中引用即可； 名称的含义尽量明确，尽量用全称，不要用缩写，除非是大家都公认的名称，比如：num,temp； 程序中的注释就少不就多，而且尽量用英文注释； 尽量避免代码重复； 写程序的过程中要考虑代码的可移植性；]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机开机过程详解]]></title>
    <url>%2F2015%2F01%2F12%2F2015-1-12-computer-start%2F</url>
    <content type="text"><![CDATA[引言 计算机开机过程似乎是个非常复杂的过程，本文为您梳理出计算机开机最重要的若干阶段，让您对计算机开机过程一目了然； 参考资料：计算机是如何启动的 第一阶段：BIOS 按下开机键，读取ROM内容； 硬件自检，屏幕会显示检测的CPU、内存、硬盘的信息，如果有错则蜂鸣； 按照用户的设定，决定计算机从哪里启动（是从硬盘、还是从DVD、还是从优盘），这一步之前用户可以通过长按F12修改从哪里启动； 第二阶段：主引导记录 磁盘逻辑结构见下图： 决定从硬盘启动； 从硬盘的0号扇区读取主引导记录（master boot record，MBR）； MBR结尾是分区表(上图)，告诉计算机每个分区的起始和终止地址； 确定活动分区（装有操作系统的分区），读取这个分区的引导块（第一个块），执行它； 引导块中的程序负责装载该分区的操作系统； 操作系统启动，加载操作系统内核，启动任务管理器等；]]></content>
      <categories>
        <category>computer</category>
      </categories>
      <tags>
        <tag>computer</tag>
        <tag>hardware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[家常菜谱汇总]]></title>
    <url>%2F2015%2F01%2F07%2F2015-1-7-menu%2F</url>
    <content type="text"><![CDATA[引言 在编代码累的时候，不妨给自己放松一下，做一道可口美味的佳肴犒劳一下自己； 作为一个吃货，不仅要会吃，而且要会做，这才叫高端大气上档次的吃货； 如果遇见朋友来家中做客，亲自下厨不仅给朋友不一样的体验，而且能够让对方切身感受到自己的真诚； 喜欢做饭的我在此给大家分享下家常菜的菜谱，欢迎补充； 基础家常菜 菜名 所需食材 制作工艺 拍黄瓜 黄瓜、蒜 黄瓜洗净，拍成小块，加入醋、蒜汁、香菜、芝麻酱等 地三鲜 土豆，茄子，青椒 去皮切滚刀块–热油加郫县豆瓣和蒜–爆炒不要加水 麻婆豆腐 嫩豆腐、麻婆豆腐调料、葱 嫩豆腐切块–下热油锅–加混合到水里的调料汁–三分钟即可出锅–用绿色葱装饰 葱香豆腐 老豆腐、鸡蛋、粉芡、葱姜、番茄酱（番茄）、糖盐 老豆腐从里到外依次裹上：盐、葱姜、粉芡、鸡蛋液；炸豆腐至金黄色；锅中加少量水、糖，放入豆腐、番茄酱红烧； 手撕包菜 包菜（圆白菜） 热油下葱姜蒜和干辣椒–下包菜爆炒–放酱油、陈醋、少量糖即可（不加水） 蒜茄子 茄子、芝麻酱、蒜 茄子切条蒸熟–拌入蒜汁、芝麻酱、香菜 鲜汁香煎带鱼 带鱼 带鱼切段刨肚洗净控干–加料酒、盐、葱姜腌制–裹上薄面控干–油炸熟透；少量热油放入葱姜、料酒–出锅放入酱油–浇到带鱼表面； 三色虾仁 虾仁、黄瓜、胡萝卜、料酒 虾仁洗净，用少量料酒腌制（不要放淀粉之类的！），黄瓜和胡萝卜切丁，热油炒虾仁盛出，热油炒黄瓜胡萝卜，放入虾仁，爆炒即可出锅 乡野小炒鸡 N个冰冻鸡腿、土豆块、香菇 鸡肉剁块洗净（也可稍微过开水去血）– 放盐腌制–放葱姜、酱油、郫县豆瓣（料酒和糖同放同不放）腌制一个小时，热油下锅爆炒–加水刚好没过鸡块（只加一次水且千万不要加多）–炖熟–加入土豆块、香菇–炖熟 粉蒸肉 带皮的五花肉、粉蒸肉调料 肉切成薄片（否则蒸不熟）–将肉和粉蒸肉调料拌在一起，下锅蒸熟即可出锅 红烧肉 五花肉、葱姜、红烧肉专用调料 上等五花肉整块放在清水中煮差不多熟，将肉捞出切块，热锅热油，下大料和姜片，然后下煮过的肉，加入料酒，炒至肉表面金黄，加少量水再次炖煮保证熟透，加入生抽或红烧肉专用调味料，小火炖煮、大火收汁即可上桌 五彩菜丁 绿色青椒（红色青椒）、胡萝卜、老豆腐、土豆、黄瓜、洋葱、黑木耳 所有食材切成大小不一的块状–加入郫县豆瓣–爆炒出锅 高端大气上档次的美味佳肴 菜名 所需食材 制作工艺 清蒸鲈鱼（草鱼） 鲈鱼（草鱼）、葱姜、生抽料酒 鲈鱼杀好洗净，用盐、料酒、葱姜、生抽腌制鲈鱼，下锅蒸15分钟即可，放上葱丝、姜丝，热油浇在鱼身上即可上桌 油焖香辣虾 大对虾N只 虾洗净剪去须须（不剥壳不剪头）–盐、葱姜、料酒腌制一小时–裹淀粉油炸大虾–加入腌制时用的调料闷熟–必要时可每个虾单独装盘，盘中黄色汤汁、配以绿色西兰花、红色椒丝、黑色胡椒酱； 香酥龙利鱼排 龙利鱼、鸡蛋、面包糠、番茄酱、菜花 龙利鱼去头剥皮切片–用盐和胡椒粉腌制鱼片–鱼片先蘸干面粉，再拖鸡蛋液，然后裹上面包糠–热油将鱼片炸熟摆盘–淋上少量番茄酱配色、加绿色菜花装饰 椒丝糖醋排骨 排骨，青椒，多种调味料 排骨煮30分钟撇沫子（尽量弄熟了）–料酒、酱油、香醋腌制排骨–油炸排骨并烧熟盛出–三勺白糖、两勺酱油、一勺料酒、3勺香醋、5勺清水制作汤汁–油锅中爆葱姜蒜–排骨下油锅翻炒–浇上汤汁后炒熟并收汁装盘–排骨成盘里–加青椒葱丝、胡萝卜雕花等配色 鲜鸡蛋肉卷 肉馅、香菇、鸡蛋、葱姜、大豆酱、蒸包子专用调料 猪肉馅剁碎，放入拌馅专用调料、大豆酱、酱油、盐、葱姜、香菇等–平底锅加热，放入少量油，倒入一个打碎的鸡蛋（一个鸡蛋饼只用一个鸡蛋），用铲子摊成薄饼状，等放凉后出锅–将肉馅均匀摊在鸡蛋饼上（不要太厚），卷起来–将鸡蛋卷蒸熟（10分钟），出锅切片即可 牛肉小丸子 牛肉馅、专用调料、大豆酱、酱油、葱姜、鸡蛋、淀粉、娃娃菜、香菜等 牛肉馅剁碎，加入拌馅专用调料、大豆酱、酱油、葱姜、鸡蛋、鸡精、胡椒粉、香油、淀粉（使丸子不易碎）等–油锅炸丸子–娃娃菜下锅翻炒–成盘待用–将炸过的牛肉丸子加水炖煮，待丸子漂浮起来后，放入刚刚炒过的娃娃菜，加盐和鸡精–娃娃菜在下，牛肉丸在上盛入小碗中，加入香菜和青椒丝调色；]]></content>
      <tags>
        <tag>cooking</tag>
        <tag>feeling</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远离压力小窍门]]></title>
    <url>%2F2015%2F01%2F06%2F2015-1-6-stress%2F</url>
    <content type="text"><![CDATA[引言 现代社会生活节奏快，人人都有压力，可能还是很沉重的压力； 互联网行业尤其如此，但是我们不要抱怨压力，而要善于释放压力，将压力变成提升自己、完善自己的动力； 本文分享几种释放压力的好方法，有需要的朋友不妨一试，欢迎补充； 时间遗忘法 时间是最好的解药，当我们出现情感问题与心理压力时，随着时间的逝去，积极地忘记过去的、眼前的不愉快，随时修正自己的认知观念，那么，痛苦的经历将不再会影响你的未来。 音乐放松法 音乐与声音可以影响我们的情绪。他人的赞扬声、指责声、议论声等都会影响你的心态，优美的轻音乐可以调整我们的情绪与心理压力，让我们的心灵放松下来，享受被音乐包围的美妙感觉。 自信激励法 心理暗示的作用大到你自己都无法想象的程度。多鼓励自己，能让自己更自信与振作起来。只要你相信自己是最好的、最可以依赖的，是无所不能的，那么，你可能就真的可以做到无所不能。 顺其自然法 顺其自然看起来很简单，做起来却很难，但是，它的效果也是最显著的。当你能做到宠辱不惊，去留无意，那么还有什么不能放下的，还有什么心理压力不能放松呢？ 淡化功利法 面对一个功利价值观比较盛行的社会，很多人都是为了功利而在努力奋斗着。适当的功利心并没有坏处，但是过度就会让我们的心理压力增大。建立合理的、客观的自我期望值，奋斗目标要合理。 换位思考法 换一个角度，换一种认知去看待问题，也许在你眼中那些不公平的事情、不协调的人际关系、不愉快的情感体验就会一笑而过！ 相互拥抱 2007年的一项动物实验中，一只草原田鼠与群体隔离单独饲养后，其身上表现出不安、压力、忧郁等症状，经注射催产素后症状便得到缓解。催产素虽然一般在性行为、分娩、哺乳时自然分泌，但如果有与朋友作轻度肌肤接触的拥抱或者与爱犬嬉戏等行为，也能促使催产素分泌。 有计划地担忧 美国宾夕法尼亚大学研究发现，一天专门抽出30分钟时间忧虑，有助缓解心理压力。研究指出，安排出固定的时间去思考需要担忧的问题，而不是浪费过多时间与精力去作无谓的忧虑，更有助于把心思集中在工作、学习与生活上，能更有效地减轻心理压力。]]></content>
      <tags>
        <tag>feeling</tag>
        <tag>psychology</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活中的10大心理学效应]]></title>
    <url>%2F2015%2F01%2F05%2F2015-1-5-psychological-effect%2F</url>
    <content type="text"><![CDATA[引言 偶尔在网上看到了心理学效应的总结，自己归纳整理了下，在此分享给喜欢心理学的朋友们； 瓦拉赫效应 奥托•瓦拉赫是诺贝尔化学奖获得者，他的成功过程极富传奇色彩。瓦拉赫在开始读中学时，父母为他选择了一条文学之路，不料一学期下来，教师为他写下了这样的评语：“瓦拉赫很用功。但过分拘泥，难以造就文学之材。”此后，父母又让他改学油画，可瓦拉赫既不善于构图，又不会润色，成绩全班倒数第一。面对如此“笨拙”的学生，绝大部分老师认为他成才无望，只有化学老师认为做事一丝不苟，具备做好化学实验的素质，建议他学化学，这下瓦拉赫智慧的火花一下子被点燃了，终于获得了成功。瓦拉赫的成功说明了这样一个道理：学生的智能发展是不均衡的，都有智慧的强点和弱点，他们一旦找到了发挥自己智慧的最佳点，使智能得到充分发挥，便可取得惊人的成绩。后人称这种现象为“瓦拉赫效应”。 门坎效应 所谓门坎效应，是指一个人接受了较低层次的要求后，适当引导，往往会逐步接受更高层次的要求。该效应是美国社会心理学家弗里德曼与弗雷瑟于1966年在做无压力屈从：登门坎技术的现场实验中提出的。 共生效应 自然界有这样一种现象：当一株植物单独生长时，显得矮小、单调，而与众多同类植物一起生长时，则根深叶茂，生机盎然。人们把植物界中这种相互影响、相互促进的现象，称之为“共生效应”。事实上，我们人类群体中也存在“共生效应”。英国“卡迪文实验室”从1901年至1982年先后出现了25位诺贝尔获奖者，便是“共生效应”一个杰出的典型。 刻板效应 社会心理学认为，那种用老眼光看人造成的影响称为“刻板效应”。它是对人的一种固定而笼统的看法，从而产生一种刻板印象。在学校经常可见到这种现象，教师对那些天资聪颖、学习成绩优秀的学生，脸上往往流露出喜爱的神色，并受到器重和青睐。而天资愚笨、学习成绩较差的学生则往往受到歧视，教师表现出急躁、厌烦的情绪，令人沮丧的话常挂在嘴边。实践证明，经常受到这种“待遇”的学生，会顿觉凉水浇身，丧失了学习信心，失掉了克服困难的勇气，以至产生颓废情绪。 首因效应 首因效应有时又称为第一印象的作用，指的是知觉对象给知觉者留下第一印象对社会知觉的影响作用。具体说，就是初次与人或事接触时，在心理上产生对某人或某事带有情感因素的定势，从而影响到以后对该人或该事的评价。所以，我们可以看出，对决策中收集正确的情报加以分析而言，这种效应是不利的。无论第一印象是好或是坏都是片面的，不利于全面地了解、分析。第一印象所产生的作用称之为首因效应。根据第一印象来评价一个人的好坏，往往比较偏颇。如果在招聘考试和考察员工绩效时，只凭第一印象，就会被某些表面现象蒙蔽。首因效应在招聘过程中主要表现有两个方面：一是以貌取人。对仪表堂堂、风度翩翩的应聘者容易赢得主考官的好感，二是以言取人，那些口若悬河、对答如流者往往给人留下好印象。因此在选拔人才时，既要听其言、观其貌，还要察其行、考其绩。 近因效应 近因效应指的是某人或某事的近期表现在头脑中占据优势，从而改变了对该人或该事的一贯看法。近因效应与首因效应是相对应的两种效应。首因效应一般在较陌生的情况下产生影响，而近因效应一般在较熟悉的情况下产生影响。两者都是对人或事的片面了解而主观臆断，使得决策信息失真。 晕轮效应（光环效应） 晕轮效应是指某人或某事由于其突出的特征留下了深刻的印象，而忽视了其它的心理和行为品质。它有时会产生“积极肯定的晕轮”，有时会产生“消极否定的晕轮”，这都会干扰对信息的评价，要克服晕轮效应就必须坚持客观，不掺杂主观成分。 蝴蝶效应 1960年，美国麻省理工学院教授洛伦兹研究“长期天气预报”问题时，出现了疑难问题：她在计算机上用一组简化数据模拟天气的演变，原本是想利用计算机的高速运算来提高天气预报的准确性。但是，事与愿违，多次计算表明，初始条件的极微小差异，会导致错误的结论。心理情绪也是如此，有一组漫画显示，一个人在单位被领导训了一顿，心里很恼火，回家冲妻子发起了脾气，妻子无来由地被训，也很生气，就摔门而去。走在街上，一条宠物狗拦住了去路，“汪汪”狂吠，妻子更生气啦，就一脚踢过去，小狗受到踢打，狂奔路过一个老人面前，把老人吓了一跳。正巧这位老人有心脏病，被突然冲出的小狗一吓，当场心脏病发作，不治身亡。洛伦兹发现了微小差异导致的巨大反差，她用一个形象的比喻来表达这个发现，一只小小的蝴蝶在巴西上空振动翅膀，它煽动起来的小小漩涡与其他气流汇合，可能在一个月后的美国得克萨斯州会引起一场风暴——这就是混沌学中著名的“蝴蝶效应”。在对人力资源的管理中，人事管理工作者如果灵活运用人事心理效应，就能充分调动下属或人才的积极性，使人尽其才，才尽其能，从而使工作效能达到最优。 罗森塔尔效应 美国心理学家罗森塔尔考查某校，随意从每班抽3名学生共18人写在一张表格上，交给校长，极为认真地说：“这18名学生经过科学测定智商很高。”事过半年，罗氏又来到该校，发现这18名学生的确表现超常。罗森塔尔效应就是期望心理中的共鸣现象。运用到人事管理中，就要求领导对下属要投入感情、希望和特别的诱导，使下属得以发挥自身的主动性和创造性。如领导在交办某一项任务时，不妨对下属说：“我相信你一定能办好”、“我想早点听到你成功的消息。”这样下属就会朝你期待的方向发展，人才也就在期待之中得以产生。 贝尔效应 英国学者贝尔天赋极高，有人说他毕业后若研究晶体和生物化学，定会赢得多次诺贝尔奖。但他却心甘情愿地走另一条道路，把一个个开拓性的课题提出来，指引别人登上了科学高峰，此举被称为贝尔效应。贝尔效应要求领导者具有伯乐精神和人梯精神，要以单位和集体为先，慧眼识才，放手用才，敢于提拔任用能力比自己强的人，积极为有才干的下属创造机会。]]></content>
      <tags>
        <tag>feeling</tag>
        <tag>psychology</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于前端开发的几点感悟]]></title>
    <url>%2F2015%2F01%2F02%2F2015-1-2-front-end-feelings%2F</url>
    <content type="text"><![CDATA[引言 做前端开发时间不算长，虽然在很多方面仍是小白，但是毕竟也悟出了一些东西，借此平台分享，也算是自己成长道路上的一点积累； 广度还是深度 自己对这个问题纠结了好久，最后得出的结论是：不用纠结，just do it！下面引用实验室一位牛人的看法，以此告诫自己just do it才是最重要的！ 在一无所知的时候，当然是广度重要，需要先知道、后深入； 在知道了一些后，当然是深度更加重要，不同的框架、语言、知识都是相通的，如果真正将一门技术、一门语言学深入、甚至达到了精通，并且能够抽象出来一种适合自己的学习方法，那么学习其他技术也会触类旁通； 学习一门新技术的方法 了解技术的应用状况和应用前景： 在知乎、博客上搜索； 这项技术多少人在用、哪些公司在用； 这项技术处于上升还是下降阶段，是否会一直流行； 确定深入学习的路线图： 了解业内评价较好的专业书籍导论、目录； 进行第一遍普及性学习，此阶段的目标不是深入理解，而是会用、上手、基础性代码跑通： 官方文档、W3Cschool总结性文档； 公开课（比如极客学院）； 入门博客； 入门书籍； 在学习深入到一定程度后，会发现一个瓶颈，那就是会用、但是不明白原理。此时应当进行第二遍研究性学习，此阶段目标不是广度，而是对某一技术点的深入挖掘，要达到看懂源码、完全了解内部运作机制的程度： 确定需要深入挖掘的几个技术点； 专业性书籍； 专业性博客； 官方文档细节； 在github上搜索别人的代码，阅读优秀代码； 自己实践一个小项目； 分享和提升： 在研究过程中产出自己的理解，试着写github和blog等，分享自己的思想； 回过头看看在”第一遍普及性学习”中的疑问是否解决； Web系统开发流程 我还没有真正步入职场，但是根据在实验室的项目经历，也能悟出一些在web应用开发过程中的团队合作技巧和注意点； 首次讨论，不考虑技术细节： 系统的逻辑架构； 系统的物理架构； 系统需要哪些页面，之间怎样跳转，大概设计什么页面功能； 讨论后写wiki文档，让大家再想想细节，确定可行的方案； 第二次讨论，确定主要技术点的具体方案： 用户需求定稿； 页面样式设计图定稿； 数据库设计定稿； 系统主要技术点定稿，确实困难的技术点要确定几个备用技术； 讨论后将系统总体任务分解成小任务，提issue分配到人，确定时间进度； 原则：同一个页面交给同一个人去做和维护； 开发过程： 原则：只考虑把东西做出来，暂不考虑性能问题； 每个点：新建分支、写代码、commit和push、备份代码和数据库到本地、及时合并代码到master； 及时和用户、产品经理沟通（如果有双重管理更应如此），沟通好再开工，避免用户需求的更改导致重复劳动； 开发文档写在wiki； issue完成及时关闭； 整体完成后上线测试： 考虑性能问题； 考虑代码优化； 考虑测试中遇到的各种实际问题； 搜索技巧 刚开始用google的时候总是搜不到自己想要的东西，原本以为是自己英语太渣，现在看来是没有掌握住“关键词”，下面就把我总结的常用的搜索技巧分享给大家； js官方文档：MDN 扩展内容：cuntomized 实例内容：example 搜教程：tutorial doc 搜下载：download 代码测试器：plunker 同级概念：… vs … 搜快捷键： 代码补全：code/hint/completion/assist 代码格式化：code format]]></content>
      <tags>
        <tag>feeling</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[This is me!]]></title>
    <url>%2F2015%2F01%2F01%2F2015-1-1-about-me%2F</url>
    <content type="text"><![CDATA[个人简介 中文名：常思源 英文名：Eric 性别：男 家乡：河南-洛阳 毕业院校：北京邮电大学(2014-2017)、郑州大学(2010-2014) 就职公司：斯伦贝谢 工作理念：- quick：快速学习，快速解决问题，快速定位bug； - drive：主动做好每一件事，主动挖掘自己的潜力，注重细节； - learn：善于学习，快速学习，持续学习； 个人博客：http://changsiyuan.github.io/ 个人主页：http://www.yinshuisiyuan.net/ Github：https://github.com/changsiyuan LinkedIn：Eric Chang 知乎：饮水思源 微博：siyuan2015 Email：changsiyuan2011@126.com 爱好：读书、游泳、厨艺、心理学 欢迎扫一扫关注我的微信公众号： 我的技术栈 前端 HTML(5) CSS(3) JavaScript Bootstrap jQuery AngularJs 后端 数据处理 数据库 Java/C# NodeJs/Python SQL PostgreSQL/MongoDB Hadoop MapReduce Standard W3C ECMAScript MVC RESTful 语义化 响应式设计 工具 编辑器 Git/TFS Markdown Eclipse Netbeans Visual Studio Sublime 项目经历和实习经历 参见我的主页 教育经历北京邮电大学(保送) 硕士 2014.09 - 2017.03排名：前5%信息与通信工程学院，信息与通信工程专业北邮网络体系构建与融合北京市重点实验室 2014.09-2017.03：担任北邮数据科学中心微信公众号责任编辑，编写全部技术文章和新闻稿； 2016.03：以学生一作身份发表EI检索论文一篇《A Parallel Space Saving Algorithm and Performance Test》(IHMSC 2016) 2016.01：以学生一作身份获得两项发明专利； Method for implementing metadata management in massive network data environmentMethod for storing and updating corresponding relation between IP and domain name 2015.12：北京邮电大学一等学业奖学金； 2015.06：北京邮电大学厨艺大赛一等奖； 郑州大学 学士 2010.09 - 2014.06排名：2/150信息工程学院，电子信息工程专业 2013.12：国家奖学金； 2013.11：河南省三好学生； 2013.02：“清华大学-洛阳市省级示范高中联合创新学习计划”优秀答辩评委； 2012.12：郑州大学三好学生(三次)； 2012.12：郑州大学一等奖学金； 2011.10：国家励志奖学金； 2011.03：中国郑开国际马拉松赛郑州大学志愿者组组长、优秀志愿者； 证书：CET-6(492)，计算机三级，全国信息技术应用培训教育工程工程师证书，驾驶证。 您可以用手机扫描二维码以进一步了解我或下载我的简历]]></content>
      <tags>
        <tag>me</tag>
      </tags>
  </entry>
</search>