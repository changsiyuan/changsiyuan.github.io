<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="www.yinshuisiyuan.net">
<meta property="og:type" content="website">
<meta property="og:title" content="Eric Chang's Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Eric Chang's Blog">
<meta property="og:description" content="www.yinshuisiyuan.net">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Eric Chang's Blog">
<meta name="twitter:description" content="www.yinshuisiyuan.net">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> Eric Chang's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  











  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1258423514&web_id=1258423514" language="JavaScript"></script>
  </div>






  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Eric Chang's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-feeling">
          <a href="/tags/feeling" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-coffee"></i> <br />
            
            生活
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/tags/me" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/18/2018-7-18-Architecture-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eric Chang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric Chang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/07/18/2018-7-18-Architecture-7/" itemprop="url">
                  Architecture（七）旁路缓存策略
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-18T00:00:00+08:00">
                2018-07-18
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/07/18/2018-7-18-Architecture-7/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/07/18/2018-7-18-Architecture-7/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="引言">引言</h3><ul>
<li>本文介绍数据库中的旁路缓存策略；</li>
</ul>
<h3 id="旁路缓存策略">旁路缓存策略</h3><ul>
<li>旁路缓存策略（cache aside pattern）是一种数据库结合缓存的设计模式；</li>
<li>基本架构：<ul>
<li>数据库有主数据库（用于写）、从数据库（用于读），另有缓存用于提升读写效率；</li>
</ul>
</li>
</ul>
<h3 id="策略概述">策略概述</h3><ul>
<li>读请求：<ul>
<li>先读缓存，如果不命中，再读从数据库；</li>
<li>如果缓存不命中，读从数据库后，写入缓存，方便下次命中；</li>
</ul>
</li>
<li>写请求：<ul>
<li>先写主数据库，再淘汰缓存；原因：数据总是以数据库为准，而不是以缓存为准，先写作为标准的一方；</li>
<li>淘汰缓存，而不是更新缓存；原因：如果更新而不淘汰缓存，则A\B两个进程并行写时，A写主数据库-&gt;B写主数据库-&gt;B更新缓存-&gt;A更新缓存，则业务期望的缓存为B写入的，但事实缓存中留存A写入的；</li>
</ul>
</li>
</ul>
<h3 id="存在的问题">存在的问题</h3><ul>
<li>由于主数据库和从数据库不能及时同步，且读请求总是从从数据库中读并更新缓存，导致缓存始终和从数据库一致，即缓存旧数据的时候，主数据库已经是新数据了；</li>
<li>解决方案：当主数据库同步到从数据库时，清除缓存。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/17/2018-7-17-Architecture-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eric Chang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric Chang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/07/17/2018-7-17-Architecture-6/" itemprop="url">
                  Architecture（六）数据库架构设计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-17T00:00:00+08:00">
                2018-07-17
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/07/17/2018-7-17-Architecture-6/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/07/17/2018-7-17-Architecture-6/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="引言">引言</h3><ul>
<li>本文介绍数据库中的架构设计；</li>
<li>通常，单机是无法满足大系统对数据库的读写要求的，必须用集群的方式来解决；</li>
<li>引入集群意味着提升了系统的复杂度，使系统变得复杂和不好维护；</li>
<li>通常采用数据库负载均衡策略、读写分离策略、分库分表策略等加以优化；</li>
</ul>
<h3 id="负载均衡">负载均衡</h3><ul>
<li>扩展性强：当系统要更高数据库处理速度时，只要简单地增加数据库服务器就可以得到扩展；</li>
<li>可维护性：当某节点发生故障时，系统会自动检测故障并转移故障节点的应用，保证数据库的持续工作；</li>
<li>安全性：<ul>
<li>因为数据会同步的多台服务器上，可以实现数据集的冗余，通过多份数据来保证安全性；</li>
<li>将数据库放到了内网之中，更好地保护了数据库的安全性；</li>
</ul>
</li>
<li>易用性：对应用来说完全透明，集群暴露出来的就是一个IP(1) 不能够按照Web服务器的处理能力分配负载；</li>
<li>缺点：负载均衡器(控制端)故障，会导致整个数据库系统瘫痪；</li>
</ul>
<h3 id="读写分离">读写分离</h3><ul>
<li>当读和写的频率相差很多时（ebay的读写比率是260:1），为了提升效率，减少磁盘IO压力，采取读写分离；</li>
<li>实现原理：<ul>
<li>数据库服务器搭建主从集群，一主一从、一主多从都可以；</li>
<li>数据库主机负责读写操作，从机只负责读操作；</li>
<li>数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了所有的业务数据；</li>
<li>业务服务器将写操作发给数据库主机，将读操作发给数据库从机；</li>
</ul>
</li>
<li><p>主从机数据不一致的解决：</p>
<ul>
<li>数据不一致：当数据写入主服务器后，要在下次同步后才能查询到；</li>
<li>读从机失败后再读一次主机；</li>
<li><p>关键业务(账号、转账等)读写操作全部指向主机，非关键业务采用读写分离；</p>
<p><img src="/images/Architecture/Architecture12.png" alt="term"></p>
</li>
</ul>
</li>
</ul>
<h3 id="分库分表">分库分表</h3><h4 id="分数据库">分数据库</h4><ul>
<li>是指按功能模块拆分到不同的数据库，比如分为订单库、商品库、用户库；</li>
<li>join只适用于同一数据库的不同表联合查询，拆分后不同数据库之间无法用join语句进行查询，只能分几次查询；</li>
<li>事务是同一数据库中的概念，要想在不同数据库之间实现事务的回滚，只能用查询log回滚的方式；</li>
<li>成本高，拆分到不同的数据库意味着需要建立多个备份数据库；</li>
</ul>
<h4 id="分数据库表_-_垂直(纵向)拆分">分数据库表 - 垂直(纵向)拆分</h4><ul>
<li>原先是一个表中包含所有10个字段；</li>
<li>现在将查询频率特别高的字段分离到另外的表中（比如婚恋网站的name, sex, age三个字段），其他字段（如个人介绍destribution等）留在原表；</li>
<li>优点：查询性能提升，如果只查询重要字段，无需将其他字段也查出来，速度很快；</li>
<li>缺点：如果要查出所有字段，必须经过两次查询；</li>
</ul>
<h4 id="分数据库表_-_水平(横向)拆分">分数据库表 - 水平(横向)拆分</h4><ul>
<li>将同一个表的数据进行分块保存到不同的数据库中，这些数据库中的表结构完全相同；</li>
<li>顺序路由：<ul>
<li>如可以按订单的日前按年份才分，2003年的放在db1中，2004年的db2,以此类推；</li>
<li>缺点是数据分布不均，可能2003年的订单有100W，2008年的有500W；</li>
</ul>
</li>
<li>hash路由：<ul>
<li>对user_id进行hash（或者如果user_id是数值型的话直接使用user_id的值也可），然后用一个特定的数字，比如应用中需要将一个数据库切分成4个数据库的话，我们就用4这个数字对user_id的hash值进行取模运算，决定存在哪个表中；</li>
<li>如果现在想将4个表变成5个表，改变膜值，则所有的数据都需要改变位置，很麻烦；</li>
</ul>
</li>
<li>配置路由：<ul>
<li>就是建立一个DB，这个DB单独保存user_id到DB的映射关系，每次访问数据库的时候都要先查询一次这个数据库，以得到具体的DB信息，然后才能进行我们需要的查询操作；</li>
<li>优点：灵活性强，一对一关系；</li>
<li>缺点：每次查询之前都要多一次查询，会造成一定的性能损失；</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/16/2018-7-16-Architecture-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eric Chang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric Chang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/07/16/2018-7-16-Architecture-5/" itemprop="url">
                  Architecture（五）微服务概述
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-16T00:00:00+08:00">
                2018-07-16
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/07/16/2018-7-16-Architecture-5/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/07/16/2018-7-16-Architecture-5/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="引言">引言</h3><ul>
<li>本文介绍微服务架构。</li>
</ul>
<h3 id="微服务特点">微服务特点</h3><ul>
<li>对服务来说：<ul>
<li>服务小，松耦合：服务面向一个独立的业务逻辑，SOA（service oriented architecture）；</li>
<li>独立的进程；</li>
<li>轻量级通信：用https协议通信，用json数据格式；</li>
</ul>
</li>
<li>对团队来说：<ul>
<li>独立开发：不同团队无需相同技术栈，每个团队维护自己的数据源；</li>
<li>独立部署：不需要过多协调不同团队进度；</li>
<li>康威法则：设计系统的组织，其产生的设计等同于组织之内、组织之间的沟通结构；</li>
</ul>
</li>
<li>弊端：<ul>
<li>技术栈众多；</li>
<li>分布式系统，数据只能保证最终一致；</li>
<li>运维和测试复杂；</li>
</ul>
</li>
</ul>
<h3 id="实践建议">实践建议</h3><ul>
<li>何时使用：<ul>
<li>系统复杂性较低时不使用微服务，使用单块应用，因为微服务所需的基础设施成本高，业务不复杂时微服务的优势无法体现出来；</li>
<li>系统复杂性提升时，逐步将单块应用拆解为微服务；</li>
</ul>
</li>
<li>拆分粒度：<ul>
<li>微服务拆分粒度过粗，则体现不出微服务的价值；</li>
<li>拆分过细又导致：维护、测试成本上升，效率下降；服务调用链太长，问题定位不方便，性能也会下降；</li>
<li>一般一个微服务由2-3个人负责最为合适；每个人能够全面理解系统；能够相互讨论避免出错；</li>
</ul>
</li>
<li>自动化：<ul>
<li>随着微服务的增多，自动化工具必须提供，否则维护成本太高；</li>
</ul>
</li>
</ul>
<h3 id="如何拆分">如何拆分</h3><ul>
<li>根据业务逻辑拆分；</li>
<li>根据服务成熟度拆分：成熟服务，可能会变化的服务；</li>
<li>根据可靠性需求拆分：必须保证99.999%可靠的核心服务，保证99%可靠就可以的非核心服务；</li>
<li>根据性能需求拆分：将性能要求高或者性能压力大的模块拆分出来，避免性能压力大的服务影响其他服务；</li>
</ul>
<h3 id="微服务需要考虑">微服务需要考虑</h3><p><img src="/images/Architecture/Architecture10.png" alt="term"></p>
<h3 id="微服务和SOA的区别">微服务和SOA的区别</h3><ul>
<li><strong>Class</strong> Microservice <em>implements</em> SOA；</li>
</ul>
<p><img src="/images/Architecture/Architecture11.png" alt="term"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/15/2018-7-15-Architecture-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eric Chang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric Chang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/07/15/2018-7-15-Architecture-4/" itemprop="url">
                  Architecture（四）负载均衡
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-15T00:00:00+08:00">
                2018-07-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/07/15/2018-7-15-Architecture-4/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/07/15/2018-7-15-Architecture-4/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="引言">引言</h3><ul>
<li>本文介绍几种负载均衡架构及算法。</li>
</ul>
<h3 id="总体策略">总体策略</h3><ul>
<li>DNS负载均衡用于实现地理级别的负载均衡；</li>
<li>硬件负载均衡用于实现集群级别的负载均衡；</li>
<li>软件负载均衡用于实现机器级别的负载均衡；</li>
</ul>
<p><img src="/images/Architecture/Architecture7.png" alt="term"></p>
<h3 id="硬件负载均衡">硬件负载均衡</h3><ul>
<li>类似路由器、交换机；</li>
<li>优点：<ul>
<li>支持各种负载均衡算法；</li>
<li>支持100万并发（一般软件负载均衡也就支持10万并发）；</li>
<li>很多设备同时支持负载均衡、防火墙、防DDOS攻击功能；</li>
</ul>
</li>
<li>缺点：<ul>
<li>价格高昂；</li>
</ul>
</li>
</ul>
<h3 id="软件负载均衡">软件负载均衡</h3><ul>
<li>优点：<ul>
<li>便宜；</li>
<li>维护和部署简单（安装Ngnix软件即可）；</li>
</ul>
</li>
<li>缺点：<ul>
<li>并发量远小于硬件负载均衡，Linux服务器上装一个Nginx大概能到5万每秒；</li>
<li>一般不具备防火墙、防DDOS攻击等功能；</li>
</ul>
</li>
</ul>
<p><img src="/images/Architecture/Architecture8.png" alt="term"></p>
<h3 id="DNS负载均衡">DNS负载均衡</h3><ul>
<li>实现地理级别的负载均衡；</li>
<li>DNS服务器将域名解析为最靠近用户的主机的IP地址，提升访问速度；</li>
<li>缺点：<ul>
<li>DNS缓存不能及时更新，有可能定位到一个已经移走的主机；</li>
<li>除了映射IP地址，没有提供其他的负载均衡算法和策略；</li>
</ul>
</li>
</ul>
<p><img src="/images/Architecture/Architecture9.png" alt="term"></p>
<h3 id="均衡算法">均衡算法</h3><ul>
<li>轮询：<ul>
<li>负载均衡系统收到请求后，按照顺序轮流分配到服务器上；</li>
<li>算法简单，没有考虑机器的状态；</li>
</ul>
</li>
<li>加权轮询：<ul>
<li>分给32核机器的概率是分给16核机器的概率的两倍；</li>
<li>考虑了机器性能，但无法根据机器状态动态调整；</li>
</ul>
</li>
<li>负载最低优先：<ul>
<li>根据及其具体状态决定负载均衡策略；</li>
<li>考虑：机器连接数、机器的HTTP连接数、CPU占用率、IO占用率；</li>
</ul>
</li>
<li>性能最佳优先：<ul>
<li>根据及其具体状态决定负载均衡策略；</li>
<li>考虑：服务器响应时间；</li>
</ul>
</li>
<li>Hash：<ul>
<li>对源IP地址hash决定任务分配到哪台服务器；</li>
<li>对session ID进行hash决定任务分配到哪台服务器，可以保证同一个会话的包都发送到同一台服务器处理；</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/10/2018-7-10-Architecture-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eric Chang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric Chang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/07/10/2018-7-10-Architecture-3/" itemprop="url">
                  Architecture（三）基本架构
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-10T00:00:00+08:00">
                2018-07-10
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/07/10/2018-7-10-Architecture-3/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/07/10/2018-7-10-Architecture-3/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="引言">引言</h3><ul>
<li>本文介绍几种基本架构及其优缺点</li>
</ul>
<h3 id="CAP原理">CAP原理</h3><ul>
<li>独裁者架构：<ul>
<li>优点：只有一个决策者，不会混乱；决策者随时掌控所有机器状态（上报者发送信条给决策者），实现统一调度；决策机器不存储数据，其他机器存储；</li>
<li>缺点：一旦决策者宕机，集群群龙无首；</li>
</ul>
</li>
</ul>
<p><img src="/images/Architecture/Architecture3.png" alt="term"></p>
<ul>
<li>主备协商：<ul>
<li>优点：主机备机都存数据；从机平时不提供数据，只在主机出问题时升级为主机；主机坏了马上切换到备机；</li>
<li>缺点：一旦主备机之间的通讯中断，则数据不同步。备机连不上主机，如果备机认为主机损坏，则自己升级为主机，如果主机实际上没有坏，外部用户会以为这个系统有两个主机，造成混乱。如果备机认为主机没有损坏，则自己不会升级为主机，如果主机实际上坏了，外部用户会以为这个系统没有主机，造成混乱。</li>
</ul>
</li>
</ul>
<p><img src="/images/Architecture/Architecture4.png" alt="term"></p>
<ul>
<li>主从协商：<ul>
<li>优点：从机正常情况下也是要提供读的操作；主从复制在主机故障时，读操作相关的业务可以继续运行；不浪费从机资源；</li>
<li>缺点：可能数据不一致；</li>
</ul>
</li>
</ul>
<p><img src="/images/Architecture/Architecture5.png" alt="term"></p>
<ul>
<li>民主选举：<ul>
<li>介绍：只有一个管理者；多个独立个体自由交换信息；个体通过一定规则的选举生成管理节点；获得多数票者取胜；</li>
<li>缺点：如果个体间部分通讯中断，则系统很有可能分裂为多个小集群，如果每个小集群都选举出一个管理者，则造成混乱，解决方法是规定投票节点数必须超过系统总节点数一半；</li>
</ul>
</li>
</ul>
<p><img src="/images/Architecture/Architecture6.png" alt="term"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/21/2018-6-21-Architecture-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eric Chang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric Chang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/06/21/2018-6-21-Architecture-2/" itemprop="url">
                  Architecture（二）CAP原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-21T00:00:00+08:00">
                2018-06-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/21/2018-6-21-Architecture-2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/06/21/2018-6-21-Architecture-2/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="引言">引言</h3><ul>
<li>本文介绍了CAP原理；</li>
</ul>
<h3 id="CAP原理">CAP原理</h3><ul>
<li>在一个分布式系统中，Consistency（数据一致性）、 Availability（服务可用性）、Partition tolerance（分区容错性），三者不可兼得；</li>
<li>一般来说，分布式系统优先实现P和A，C用最终一致性代替；</li>
</ul>
<h3 id="详细解释">详细解释</h3><ul>
<li>一致性：All nodes see the same data at the same time；</li>
<li>可用性：A non-failing node will return a reasonable response within a reasonable amount of time (no error or timeout)；</li>
<li>分区容错性：出现消息丢失或者分区错误时系统能够继续运行；</li>
</ul>
<h3 id="使用案例">使用案例</h3><ul>
<li>保证CP牺牲A：当系统不同节点间通讯中断、不能及时同步数据时，为了保证数据一致，此时对用户请求返回error错误信息，即系统暂时不可用；</li>
</ul>
<p><img src="/images/Architecture/Architecture1.png" alt="term"></p>
<ul>
<li>保证AP牺牲C：有可能向用户返回旧数据，即脏读；</li>
</ul>
<p><img src="/images/Architecture/Architecture2.png" alt="term"></p>
<ul>
<li>保证AC牺牲P：系统中只有一个节点，已经不是分布式系统；</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/16/2018-4-16-Architecture-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eric Chang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric Chang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/16/2018-4-16-Architecture-1/" itemprop="url">
                  Architecture（一）架构简介
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-16T00:00:00+08:00">
                2018-04-16
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/04/16/2018-4-16-Architecture-1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/04/16/2018-4-16-Architecture-1/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="引言">引言</h3><ul>
<li>架构的设计在软件设计中极为重要，一个好的架构设计能够成倍提升开发和运维效率、提升产品的交付能力；</li>
<li>架构设计的思路和软件编程有很大不同，这不仅仅体现在所需知识的不同、而且思维模式和设计理念也各不相同；</li>
<li>在工作之余，我认真学习了极客时间的<a href="https://time.geekbang.org/column/81" target="_blank" rel="external">从0开始学架构</a>课程，受益匪浅；</li>
<li>接下来我会用若干篇幅的博客展示一下学习笔记，欢迎大家指教；</li>
<li>本文对架构设计的原则和目的加以总结；</li>
</ul>
<h3 id="架构设计的目的">架构设计的目的</h3><ul>
<li>目的：解决软件系统复杂性带来的问题；</li>
<li>核心：balance；<ul>
<li>平衡希望系统高性能、高扩展性和时间成本、开发成本之间的矛盾；</li>
<li>对各种设计的优缺点做取舍；</li>
</ul>
</li>
</ul>
<h3 id="架构设计原则">架构设计原则</h3><ul>
<li><strong>合适优于业界领先</strong>：很适合别的系统的架构，不一定适合当前项目，不是每个系统都需要架构设计；</li>
<li><strong>简单优于复杂</strong>：架构设计不是为了片面追求系统的高可用性、高扩展性、高性能，而是最适合业务的实际情况；</li>
<li><strong>演化优于一步到位</strong>：架构是演化出来的，而不是设计出来的，谁都不可能在刚开始开发的时候、业务需求不明确的时候设计出完整的架构；</li>
</ul>
<h3 id="架构设计需要考虑">架构设计需要考虑</h3><ul>
<li>高性能：<ul>
<li>单机：充分利用CPU、disk、memory、IO等资源；</li>
<li>集群：如何扩展单机的处理能力，满足业务需求，比如春节发红包、双十一等；</li>
</ul>
</li>
<li>高可用：<ul>
<li>保证服务不间断正常运行；</li>
<li>应对：硬件故障，软件故障、网络故障，外部故障（水灾地震）；</li>
<li>保证高可用的核心：冗余；</li>
</ul>
</li>
<li>可扩展性：<ul>
<li>正确预测变化、完美封装变化；</li>
<li>所有的预测都存在出错的可能性；</li>
<li>适度的预测而不是完美的预测；</li>
</ul>
</li>
<li>安全性；</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/16/2018-2-16-quantum/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eric Chang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric Chang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/16/2018-2-16-quantum/" itemprop="url">
                  不确定的世界 - 量子论和量子通信
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-16T00:00:00+08:00">
                2018-02-16
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/02/16/2018-2-16-quantum/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/02/16/2018-2-16-quantum/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="引言">引言</h3><ul>
<li>量子论和相对论是现代物理学的两大支柱，共同构成了现代物理学的基本观点和理论；</li>
<li>在物理学的发展历程中，牛顿的经典物理学长期占据了不可撼动的主导地位，但人类对于宏观宇宙的探索不断表明，经典物理学仅适用于描述和解释低速、宏观物质的现象，并不能够解释物质在高速运动下表现出的规律和性质，所以才有了相对论；</li>
<li>相对论完美的阐释了时间、空间的本质，以及时空在目前宇宙尺度上的关系，并对处于人类观测极限的黑洞等天体的性质作出预测；</li>
<li>但随着科技的发展，人们逐步意识到相对论也不是完美的，在原子、质子以及电子的微观尺度上，发生了很多违背相对论原理的现象，这就说明在及其微观的尺度上，物质、时间、空间的性质和宏观尺度大不相同，描述和研究方法也应当有所转变，经过长时间的探索和不懈的追求，量子论横空出世，它以一种超乎寻常的全新的视角解释这个世界所发生的一切，让人类对于宇宙和自身的认知达到了新的高度；</li>
<li>量子论并不是理论的终点，也不是什么终极理论，量子论只是冰山一角，是解开这个宇宙所有谜团的入口，有更多的全新的事物等待人类继续不懈探索和追求；</li>
<li>本文结合自己对量子论的学习和认知，总结了量子论的基本观点，并对量子通信原理加以阐述，供您参考；</li>
<li>我不是物理学专业，如有错误敬请指出，为了方便理解，本文不含有任何公式；</li>
</ul>
<h3 id="量子的定义">量子的定义</h3><ul>
<li>量子是一切具有量子特性的微观粒子的统称，比如原子、质子、电子等等；</li>
<li>上述定义中的“量子特性”包括但不限于：波粒二象性、量子纠缠、不确定性等，这些性质本文中会一一阐述；</li>
<li>另一种定义方式：量子是能表现出某物质或物理量特性的最小单元；</li>
<li>实施上，上述定义中的“微观粒子”“最小单元”都是模糊的概念，由于量子学发展并未非常深入，所以这种定义本身就是模糊的，除非人类的认识达到了比量子还高的一个维度，才能在这个维度中对量子做出更加准确的定义；</li>
</ul>
<h3 id="相对论的时空观">相对论的时空观</h3><ul>
<li>在全面阐述量子论之前，首先对相对论的时空观加以概述，这样可以使读者抛弃宏观、低速的视角和思维模式，开启面向整个宇宙的思考，这样有利于更好的理解量子论；</li>
</ul>
<h4 id="宏观状态下的物质">宏观状态下的物质</h4><ul>
<li>牛顿的经典物理学对宏观低速状态的物质的性质做了非常经典的描述：<ul>
<li>第一定律：不受外力的物体将保持静止或匀速直线运动；</li>
<li>第二定律：一个物体的外合力＝质量*加速度；</li>
<li>第三定律：两个物体相互作用时，对彼此施加的力大小相等方向相反；</li>
<li>万有引力定律：两个粒子间的作用力正比于它们质量的乘积，反比与它们中心点距离的平方；</li>
<li>开普勒定律：在相等的时间内，太阳和围绕它运动的行星连线所扫过的面积相等；</li>
</ul>
</li>
</ul>
<h4 id="相对论对光速的基本假设">相对论对光速的基本假设</h4><ul>
<li>光速(电磁波速)在任何情况、任何测量条件下保持恒定；</li>
<li>任何物质和信息速度不超过光速，在某种程度上，光速定义了整个宇宙；</li>
<li>光子没有静质量；</li>
</ul>
<h4 id="相对论对时间的描述">相对论对时间的描述</h4><ul>
<li>当物质的速度不断接近光速时，其性质不能够用经典物理学描述；</li>
<li>钟慢效应：当物质的速度不断接近光速时，物质的变化会相对于其静止时减慢，即物质的“时钟”变慢；</li>
<li>尺缩效应：当物质的速度不断接近光速时，测量的长度或距离，比地面上测得的短；</li>
<li>质量增加：快达到光速时，再向物体传递能量不能使速度明显增加，此时能量转化为质量；</li>
</ul>
<h4 id="相对论对空间的描述">相对论对空间的描述</h4><ul>
<li>万有引力的本质是大质量物质引起的空间形变，并不是力；</li>
<li>引力越大，天体内测光行进路线越短，由于光速不变，所以大质量天体内侧的时间流逝速度比外侧慢；</li>
<li>万有引力和加速度在对时空的影响上等效，一个飞行员如果承受了很大的加速度，他的时间会变慢；</li>
<li>对于人造卫星，由于相对地表速度快，所以时间流逝速度比地面慢，又由于高度位于地球外侧，所以时间流逝速度比地面快，后者的效应比前者大一个数量级，故人造卫星的时间快于地面，需要定期校准，否则卫星的时钟和地面的时钟不匹配，会造成GPS定位不准等一系列问题；</li>
</ul>
<h3 id="量子的物理属性">量子的物理属性</h3><ul>
<li>既然量子是物理学研究的范畴，那么必须要用相应的物理量来表征量子的性质；</li>
<li>量子的物理属性包括：质量、自旋、电荷，请注意，这里的“质量”这个物理属性和宏观物质的“质量”有本质不同，“自旋”是量子特有的属性，宏观物质不具备；</li>
<li>质量：<ul>
<li>对于微观粒子质量等价于能量，描述粒子裹携的能量的多少；</li>
<li>对于微观粒子，质量和能量界限很模糊，对于宏观物质，质量和能量的界限很明确；</li>
<li>组成质子的所有夸克质量相加只占质子质量的1%，质子的其他质量来源于夸克的动能，即夸克的巨大的但被束缚在一起的能量外在表现为质子的质量；</li>
<li>这也说明物质的本质是能量，从宇宙的尺度上来讲，质量和能量本是一回事，质量是能量的特殊组织形式和外在表现；</li>
<li>质量和能量一定条件下能相互转化，比如在物质高速运动时，对物体施加的动能可能转化为物体的质量；在核裂变反应中，物质的质量会转化为巨大的能量；</li>
</ul>
</li>
<li>自旋：粒子在各个位置出现的概率分布图不断变化，变化一轮所需的周期；</li>
<li>电荷：描述粒子相互作用时产生各种电磁现象难易程度，分为正负，正电荷和负电荷对应的电磁现象正好相反；</li>
</ul>
<h3 id="量子的性质">量子的性质</h3><ul>
<li>本节介绍量子的基本性质；</li>
</ul>
<h4 id="不确定性原理">不确定性原理</h4><ul>
<li>宏观物质一般是确定的、可测的；</li>
<li>微观粒子一般是不确定的、不可测的；</li>
<li>微观粒子的速度、动量、位置、质量等物理量不能同时具有确定数值；</li>
<li>一个值测的越准另一个值就越不准确；</li>
<li>单个粒子的这些属性往往以概率云的形式存在，仅仅在测量时(有光子干扰时，有信息交换时)概率云塌缩为确定的数值；</li>
</ul>
<h4 id="量子纠缠">量子纠缠</h4><ul>
<li>微观粒子具有量子纠缠现象，即互为纠缠态的两个粒子无论空间距离多么遥远，也能瞬间影响对方的状态；</li>
<li>并不能利用这一现象使信息超光速传递，量子纠缠并不违反相对论基本原理；</li>
<li>量子纠缠的比喻：在美国的女儿生下孩子那一瞬间，远在中国的母亲就变成了姥姥，即便她自己还不知道，之所以她是姥姥别人不是，而且她一定会成为姥姥，就是因为她和女儿之间有一种“纠缠”关系；</li>
</ul>
<h4 id="波粒二象性">波粒二象性</h4><ul>
<li>对波粒二象性的错误理解：单个粒子是”粒子”一大堆粒子就表现出”波”的性质；</li>
<li>波粒二象性是指，单个粒子本身即是波又是粒子；</li>
<li>这是因为单个粒子本身以概率云的形式存在，例如，一个电子既可以是波(一个电子不如果不对其测量，它可以同时穿过两条狭缝产生干涉条纹，但如果去测量它，产生了它与外界的信息交换，它会确切的随机的穿过某一条狭缝而不产生干涉条纹)，又可以是粒子(可以与光子碰撞)；</li>
</ul>
<h4 id="如何理解薛定谔的猫">如何理解薛定谔的猫</h4><ul>
<li>薛定谔的猫是著名的思想实验；</li>
<li>将一只猫关在一钢盒内，盒中有极残忍的装置（必须保证此装置不受猫的直接干扰），在盖革计数器中有一小块辐射物质，它非常小，或许在1小时中只有一个原子衰变，在相同的几率下或许没有一个原子衰变；</li>
<li>如果发生衰变，计数管便放电并通过继电器释放一个锤，击碎一个小小的氰化物瓶毒杀了这只猫，否则不会；</li>
<li>常识告诉我们那只猫非死即活，两者必居其一，可是按照量子力学的规则，盒内整个系统处于两种态的叠加之中，一态中有活猫，另一态中有死猫，即量子理论告诉我们，这个不幸的动物处于一种悬而未决的死活叠加状态中；</li>
<li>这个实验巧妙地将微观世界的不确定性原理和宏观世界的确定、可测联系起来，让人摸不着头脑，事实上，宏观世界的确定和微观世界的不确定两者并不矛盾，只是人们尚未发现为何及其大量的微观不可测事件导致了宏观的确定性，我们到底是生活在确定还是不确定中目前还没有定论；</li>
</ul>
<h3 id="量子的分类">量子的分类</h3><h4 id="费米子">费米子</h4><ul>
<li>具有半整数自旋，每一种都有反粒子相对应；</li>
<li>夸克：<ul>
<li>下夸克：自旋1/2，电荷－1/3；</li>
<li>上夸克：自旋1/2，电荷＋2/3；</li>
<li>奇夸克：自旋0，电荷－1/3；</li>
<li>粲夸克：自旋0，电荷＋2/3；</li>
<li>底夸克：自旋0，电荷－1/3；</li>
<li>顶夸克：自旋0，电荷＋2/3；</li>
</ul>
</li>
<li>轻子：<ul>
<li>电子/正电子：电荷±1；</li>
<li>μ子/反μ子：电荷±1；</li>
<li>τ子/反τ子：电荷±1；</li>
<li>(反)电子中微子：电荷0；</li>
<li>(反)μ子中微子：电荷0；</li>
<li>(反)τ子中微子：电荷0；</li>
</ul>
</li>
</ul>
<h4 id="玻色子">玻色子</h4><ul>
<li>具有整数自旋；</li>
<li>光子：自旋1，电荷0，静质量0(指的是没有静止不动的光子)，能量来自电磁相互作用；</li>
<li>W玻色子：自旋1，电荷1，能量来自弱相互作用；</li>
<li>Z玻色子：自旋1，电荷0，能量来自弱相互作用；</li>
<li>胶子：自旋1，电荷0，能量来自强相互作用；</li>
<li>引力子：自旋2，电荷0，能量来自引力相互作用；</li>
<li>希格斯玻色子：自旋0，电荷0，能量来自电弱交互作用；</li>
</ul>
<h3 id="量子通信基本原理">量子通信基本原理</h3><ul>
<li>量子通信本质上是利用量子的“纠缠”特性；</li>
<li>利用量子论实现光量子通信的过程如下：<ul>
<li>首先先构建一对相互纠缠的粒子，将这两个粒子分别放在发送方和接收方；</li>
<li>将具有未知量子态的粒子与发送方的粒子进行联合测量(一种操作)，这种操作改变了发送方粒子的量子态；</li>
<li>根据量子的自旋特性，接收方的粒子会在瞬间(不耗费任何时间)发生坍塌(一种量子性质的改变) ，坍塌后的状态与发送方的粒子坍塌后的状态是对称的；</li>
<li>然后将联合测量的信息通过经典信道传送给接收方，接收方根据接收到的信息对坍塌的粒子进行幺正变换(相当于逆转变换)，即可得到与发送方完全相同的未知量子态;</li>
</ul>
</li>
<li>经典通信较光量子通信相比，其安全性和高效性都无法与之相提并论：<ul>
<li>安全性：量子通信绝不会“泄密”，其一体现在量子加密的密钥是随机的，即使被窃取者截获，也无法得到正确的密钥，因此无法破解信息；其二，分别在通信双方手中具有纠缠态的2个粒子，其中一个粒子的量子态发生变化，另外一方的量子态就会随之立刻变化，并且根据量子理论，宏观的任何观察和干扰，都会立刻改变量子态，引起其坍塌，因此窃取者由于干扰而得到的信息已经破坏，并非原有信息；</li>
<li>高效，被传输的未知量子态在被测量之前会处于纠缠态，即同时代表多个状态，例如一个量子态可以同时表示0和1两个数字，7个这样的量子态就可以同时表示128个状态或128个数字0~127，光量子通信的这样一次传输，就相当于经典通信方式的128次；</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/18/2018-1-18-ElasticSearch-Intro/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eric Chang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric Chang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/18/2018-1-18-ElasticSearch-Intro/" itemprop="url">
                  ElasticSearch原理简介
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-18T00:00:00+08:00">
                2018-01-18
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/01/18/2018-1-18-ElasticSearch-Intro/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/01/18/2018-1-18-ElasticSearch-Intro/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="引言">引言</h3><ul>
<li>ELK是重要的日志分析系统，在开源的日志分析系统中独占鳌头，最近公司业务用ELK分析告警日志，故系统研究了Elasticsearch的工作原理。</li>
<li>本文是转载的<a href="http://www.shaheng.me/blog/2015/06/elasticsearch--.html" target="_blank" rel="external">一篇文章</a>加上我自己的整理和分析，某些内容和ELK官网重复，在此感谢作者的整理。</li>
</ul>
<h3 id="基本概念">基本概念</h3><ul>
<li>简介：<ul>
<li>ElasticSearch(以下简称ES)是一个基于Lucene构建的开源(open-source)，分布式(distributed)，RESTful，实时(real-time)的搜索与分析(analytics)引擎。</li>
<li>它可以让你在浏览数据时具备非常快的速度和优秀的可扩展性。它用于全文索引、结构化数据索引、数据分析以及三者的结合。</li>
<li>它可以运行在你的笔记本上，或者扩展至数百台的服务器节点上来处理PB级的数据。 ES建立在Lucene的基础之上，但是Lucene仅仅是一个库，如果要发挥它的优势，你必须使用它然后再结合自己的开发来构造一个具体的应用。</li>
<li>更坏的是你必须了解Lucene才能更好的使用它，但是Lucene本身就很复杂。所以ES意在取Lucene的优点，隐蔽其复杂性来构造一个简洁易用的RESTful风格的全文搜索引擎。</li>
</ul>
</li>
<li>与关系型数据库的名词对照</li>
</ul>
<table>
<thead>
<tr>
<th>SQL database</th>
<th>No-sql database</th>
</tr>
</thead>
<tbody>
<tr>
<td>database</td>
<td>database</td>
</tr>
<tr>
<td>table</td>
<td>collection</td>
</tr>
<tr>
<td>row</td>
<td>document</td>
</tr>
<tr>
<td>column</td>
<td>field</td>
</tr>
<tr>
<td>primary key</td>
<td>primary key</td>
</tr>
</tbody>
</table>
<ul>
<li><p>ElasticSearch专用名词解释：</p>
<ul>
<li>document：一行数据；</li>
<li>index：一个database，是多个document的集合（和sql数据库的索引的概念不同），在kibana上显示为一组日志；</li>
<li>shard：ELK的底层存储是file，shared包含一个或多个file，是数据最小存储单元，一个index被划分为若干shared分片，一个shared可以备份到其他节点上（备份的份数可以自定义）；</li>
<li>node：物理节点；</li>
<li>cluster：集群；</li>
</ul>
</li>
<li><p>面向文档(Document Oriented)</p>
<ul>
<li>在应用程序中的对象(Objects)，不仅仅是keys和values的罗列，更多的是，他们是由更为复杂的数据结构组成的数据构成的。迟早你会将这些对象存储到DataBases(这里指更广义的持久层)。如果你要将这些已经通过复杂的结构体组织好的对象存储到传统的ROWS-COLUMNS的关系型数据库里无疑等于压榨你的财富：因为你必须将这些已经组织好了的复杂结构扁平化来适应传统数据库的表结构(通常是一个列一个字段)，然后以后每次在你要使用这个数据的时候再重组它们。</li>
<li>ES面向文档，这就意味着你可以存储完整的对象或者文档。ES不仅存储它们，并且对它们的每一个文档的内容做了索引以便可以查询到它们。在ES中，你是对文档进行的建索引、查询、排序、过滤，而不是对关系型数据的一行数据。这就是ES处理数据的一个最基本的不同点，这也是ES为什么能处理全文索引的关键。</li>
</ul>
</li>
<li><p>精确索引VS全文索引</p>
<ul>
<li>在ES中的数据可以分为两类：精确值(exact values)以及全文(full text)。 精确值：例如日期类型date，若date其有两个值:2014-09-15与2014，那么这两个值不相等。又例如字符串类型foo与Foo不相等。 全文：通常是人类语言写的文本，例如一段tweet信息、email的内容等。</li>
<li>精确值很容易被索引：一个值要么相当要么不等。 索引全文值就需要很多功夫。例如我们不仅要想：这个文档符合我们的查询吗？还要想：这个文档有多符合我们的查询？换句话说就是：这个文档跟我们的查询关联大吗？我们很少精确的去匹配整个全文，我们最想要的是去匹配全文文本的内部信息。除此，我们还希望搜索能够理解我们的意图;</li>
<li>例如,如果你搜索UK，我们需要包含United Kingdom的文本也会被匹配。如果你搜索jump，那么包含jumped,jumps,jumping,更甚者leap的文本会被匹配。</li>
<li>为了更方便的进行全文索引，ES首先要先分析文本，然后使用分析过的文本去创建倒序索引。</li>
</ul>
</li>
<li><p>倒序索引&amp;文本分析</p>
<ul>
<li>ES使用倒序索引来加速全文索引。一个倒序索引由两部分组成：在文档中出现的所有不同的词；对每个词，它所出现的文档的列表。 例如：如果我们有两个文档，每一个文档有一个content字段，包含的内容如下：</li>
</ul>
</li>
</ul>
<blockquote>
<p>1.The quick brown fox jumped over the lazy dog<br>2.Quick brown foxes leap over lazy dogs in summer</p>
</blockquote>
<p>要创建一个倒序索引，首先要将content分割成单独的词(称为terms or tokens)，创建一个所有terms的列表，然后罗列每一个term出现的文档。此过程称为tokenization。如下图：</p>
<p><img src="/images/elk/1-1.png" alt="term"></p>
<p>现在，如果我们想要搜索 quick brown，我们仅仅只需要找每一个term出现的文档即可。如下图：</p>
<p><img src="/images/elk/1-2.png" alt="term"></p>
<p>每一个文档都匹配到了，但是第一个比第二个要匹配的多。如果我们使用一个简单的相似性算法仅仅只计算匹配的数量，那么我们可以称第一个文档要比第二个匹配的好(与我们的查询更有关联)。<br>但是现在的倒序索引有一些问题：</p>
<blockquote>
<p>Quick与quick是两个不同的term，但是搜索的用户会认为它们应该是一样的term才是合理的。<br>fox和foxes，dog和dogs是一样的词根，应该列为同一个term。 jumped和leap虽然词根不一样，但是意义却相同。</p>
</blockquote>
<p>如果改善了上面的问题，那么倒序索引应该如下图：</p>
<p><img src="/images/elk/1-3.png" alt="term"></p>
<p>但是此时如果用户搜索Quick还会失败，因为term不含精确值Quick。但是，如果我们对QueryString使用与上述改善步骤相同的策略，那么用户搜索的Quick将会被转换为quick，此过程称为normalization。那么将会成功匹配。 对content的处理tokenization和normalization称为analysis过程。ES有很多种内置的analyzer处理这些。</p>
<h3 id="Elasticsearch设计原理">Elasticsearch设计原理</h3><h4 id="一个空的集群">一个空的集群</h4><p><img src="/images/elk/2-1.png" alt="term"></p>
<ul>
<li>如果我们启动了一个节点，没有索引没有数据，那么看起来就像上图一样。 一个节点Node运行着ES的实例，一个集群由一个或多个使用着同样名字(cluster.name)的节点组成，分享数据和负载。 当Node从集群中添加或删除时，集群会重组自己，使数据平摊的更均匀。</li>
<li>集群中需要有一台master节点。master的作用是掌管集群的管理工作： 例如创建和删除索引。 从集群中添加或删除一台节点。 master节点无需掌管文档级的变更和索引。这也意味着在只有一台master的情况下，随着负载的增加master不会成为瓶颈。 所有的节点都可能变成master。</li>
<li>作为user，我们可以与任何一台节点通信，包括master。每一台节点都知道每一个文档的位置并且可以将user的请求路由到文档所在的节点，并且这台节点负责接收它路由到的node or nodes的响应，并且将数据组织起来返回给用户。这些对用户都是透明的。</li>
</ul>
<h4 id="创建一个索引—index,shard,cluster">创建一个索引—index,shard,cluster</h4><ul>
<li>将数据添加到ES的前提是，我们需要一个索引(名词):index——一个存储与这个索引相对应数据的地方。实际上，index仅仅只是一个命名空间来指向一个或多个实际的物理分片(shard)。</li>
<li>一个分片(shard)是一个比较低层的工作单元来处理这个索引(index)的所有数据的一个切片(slice)。一个shard实际上是一个Lucene实例，在它的能力范围内拥有完整的搜索功能(在处理它自己拥有的数据时有所有的功能)。我们所有文档的索引indexed(动词)和存储工作都是在shard上，但这是透明的，我们不需要直接和shard通信，而是和我们创建的index(名词)通信。</li>
<li>shards是ES将数据分布式在你的集群的关键。想象下shards是数据的容器，文档存储在shards里，而shards被分配在集群的每一个节点Node里。当你的集群规模增长和降低时，ES会自动的在Nodes间迁移shards以保持集群的负载均衡。</li>
<li>shard的分类与作用：<ul>
<li>shard可分为primary shard和replica shard。</li>
<li>在一个index里的每一个文档都属于一个单独的primary shard，所以primary shard的数量决定了你最大能存储的数据量(对应于一个index)。</li>
<li>注意：shard是归属与index的，而不是cluster的。</li>
</ul>
</li>
<li>replica shard是primary shard的拷贝。replica有两个作用：   <ul>
<li>冗余容灾</li>
<li>提供读请求服务，例如搜索或读取文档primary shard的数量在索引创建时确定后不能修改，replica可以在任何时候修改。 例： 见Figure2，在2.1的集群上创建一个index，拥有3个primary shards以及1个replica shards。</li>
</ul>
</li>
</ul>
<p><img src="/images/elk/2-2.png" alt="term"></p>
<p>由于只有一台Node，而Primary shard的Replicas与其在同一台节点上毫无意义，所以集群没有初始化replicas，这时添加另外一台Node。见Figure3，每一个primary shard初始化了一个replica。</p>
<p><img src="/images/elk/2-3.png" alt="term"></p>
<h4 id="水平扩容">水平扩容</h4><p>当我们继续添加一台节点时，Node1和Node2中的各取一个shard移动到了Node3.见Figure4</p>
<p><img src="/images/elk/2-4.png" alt="term"></p>
<p>这样，我们每一台Node上只有两个shard。这就意味着每一台Node的硬件资源(CPU,RAM,I/O)将会被更少的shards共享，提高了每一个shard的性能。在这个案例中，6个shards最多可使用6台Node，这样每个shard就可以使用100%的node硬件资源。<br>现在我们修改replica的数量到2，如Figure5</p>
<p><img src="/images/elk/2-5.png" alt="term"></p>
<p>这样我们就有了一个3primary shards，6replica shards的Cluster。我们可将Node提高到9台。水平扩容了集群性能。</p>
<h4 id="容灾">容灾</h4><p>ES可以容下当节点宕机情况下的异常。例如现在我们杀掉Node1节点。见Figure6</p>
<p><img src="/images/elk/2-6.png" alt="term"></p>
<p>我们杀掉的是master节点。一个Cluster必须要有master以保证集群的功能正常。所以集群要做的第一件事是选择一个新的master：Node2. 当我们杀掉1节点时，Primary shards 1和2丢失了。如果丢失了primary shard，index(名词)将不能正常的工作。此时P1和P2的拷贝存在Node2和Node3上。所以此时新升级的master(Node2)将做的第一件事就是将NODE2和NODE3上的replica shard1和replica shard2升级为primary shard。此时如果我们杀掉NODE2，整个集群的容灾过程同理，还是可以正常运行。</p>
<p>这时，如果我们重启了NODE1，cluster将会重新分配缺少的两个replica shards(现在每个primary shard只有2个replicas，配置是3个，缺少2个)。如果NODE1的数据是旧的，那么它将会继续利用它们，NODE1只会从现在的Primary Shards拷贝这期间更改的数据。</p>
<h3 id="分布式文档存储">分布式文档存储</h3><h4 id="Shards文档路由">Shards文档路由</h4><p>当你对一个文档建立索引时，它仅存储在一个primary shard上。ES是怎么知道一个文档应该属于哪个shard？当你创建一个新的文档时，ES是怎么知道应该把它存储至shard1还是shard2？ 这个过程不能随机无规律的，因为以后我们还要将它取出来。它的路由算法是：</p>
<blockquote>
<p>shard = hash(routing) % numberofprimary_shards</p>
</blockquote>
<p>routing的值可以是文档的id，也可以是用户自己设置的一个值。hash将会根据routing算出一个数值然后%primaryshards的数量。这也是为什么primary_shards在index创建时就不能修改的原因。</p>
<p>问题：当看到这里时，产生了一个问题:ES为什么要这样设计路由算法，这样就强制使primaryshards不可变，不利于以后index的扩容，除非事前就要对数据规模有所评估来设计可扩展的index。为什么不能使用一致性hash解决primaryshards改变时的情况呢？</p>
<h4 id="Primary/Replica_Shards的交互">Primary/Replica Shards的交互</h4><p>假如我们有Figure8的集群。我们可以向这个集群的任何一台NODE发送请求，每一个NODE都有能力处理请求。每一个NODE都知道每一个文档所在的位置所以可以直接将请求路由过去。下面的例子，我们将所有的请求都发送到NODE1。</p>
<p><img src="/images/elk/2-7.png" alt="term"></p>
<p>注：最好的实践方式是轮询所有的NODE来发送请求，以达到请求负载均衡。</p>
<h4 id="写操作">写操作</h4><p>创建、索引、删除文档都是写操作，这些操作必须在primary shard完全成功后才能拷贝至其对应的replicas上。见Figure9。</p>
<p><img src="/images/elk/2-8.png" alt="term"></p>
<blockquote>
<p>1.客户端向Node1发送写操作的请求。<br>2.Node1使用文档的_id来决定这个文档属于shard0，然后将请求路由至NODE3，P0所在的位置。<br>3.Node3在P0上执行了请求。如果请求成功，则将请求并行的路由至NODE1 NODE2的R0上。当所有的replicas报告成功后，NODE3向请求的node(NODE1)发送成功报告，NODE1再报告至Client。<br>当客户端收到执行成功后，操作已经在Primary shard和所有的replica shards上执行成功了。</p>
</blockquote>
<h4 id="读操作">读操作</h4><p>一个文档可以在primary shard和所有的replica shard上读取。见Figure10</p>
<p><img src="/images/elk/2-9.png" alt="term"></p>
<blockquote>
<p>1.客户端发送Get请求到NODE1。<br>2.NODE1使用文档的_id决定文档属于shard 0.shard 0的所有拷贝存在于所有3个节点上。这次，它将请求路由至NODE2。<br>3.NODE2将文档返回给NODE1，NODE1将文档返回给客户端。 对于读请求，请求节点(NODE1)将在每次请求到来时都选择一个不同的replica。<br>shard来达到负载均衡。使用轮询策略轮询所有的replica shards。</p>
</blockquote>
<h4 id="更新操作">更新操作</h4><p>更新操作，结合了以上的两个操作：读、写。见Figure11</p>
<p><img src="/images/elk/2-10.png" alt="term"></p>
<blockquote>
<p>1.客户端发送更新操作请求至NODE1<br>2.NODE1将请求路由至NODE3，Primary shard所在的位置<br>3.NODE3从P0读取文档，改变source字段的JSON内容，然后试图重新对修改后的数据在P0做索引。如果此时这个文档已经被其他的进程修改了，那么它将重新执行3步骤，这个过程如果超过了retryon_conflict设置的次数，就放弃。<br>4.如果NODE3成功更新了文档，它将并行的将新版本的文档同步到NODE1和NODE2的replica shards重新建立索引。一旦所有的replica<br>shards报告成功，NODE3向被请求的节点(NODE1)返回成功，然后NODE1向客户端返回成功。</p>
</blockquote>
<h3 id="Shard以及数据读写方式的设计">Shard以及数据读写方式的设计</h3><h4 id="不变性">不变性</h4><ul>
<li>写到磁盘的倒序索引是不变的：自从写到磁盘就再也不变。这会有很多好处：<ul>
<li>不需要添加锁。如果你从来不用更新索引，那么你就不用担心多个进程在同一时间改变索引。</li>
<li>一旦索引被内核的文件系统做了Cache，它就会待在那因为它不会改变。只要内核有足够的缓冲空间，绝大多数的读操作会直接从内存而不需要经过磁盘。这大大提升了性能。</li>
<li>其他的缓存(例如fiter cache)在索引的生命周期内保持有效，它们不需要每次数据修改时重构，因为数据不变。</li>
<li>写一个单一的大的倒序索引可以让数据压缩，减少了磁盘I/O的消耗以及缓存索引所需的RAM。</li>
</ul>
</li>
<li>当然，索引的不变性也有缺点。如果你想让新修改过的文档可以被搜索到，你必须重新构建整个索引。这在一个index可以容纳的数据量和一个索引可以更新的频率上都是一个限制。</li>
</ul>
<h4 id="动态更新索引">动态更新索引</h4><p>如何在不丢失不变形的好处下让倒序索引可以更改？答案是：使用不只一个的索引。 新添额外的索引来反映新的更改来替代重写所有倒序索引的方案。 Lucene引进了per-segment搜索的概念。一个segment是一个完整的倒序索引的子集，所以现在index在Lucene中的含义就是一个segments的集合，每个segment都包含一些提交点(commit point)。见Figure16。新的文档建立时首先在内存建立索引buffer，见Figure17。然后再被写入到磁盘的segment，见Figure18。</p>
<p><img src="/images/elk/3-1.png" alt="term"></p>
<p><img src="/images/elk/3-2.png" alt="term"></p>
<ul>
<li>一个per-segment的工作流程如下：<ul>
<li>新的文档在内存中组织，见Figure17。</li>
<li>每隔一段时间，buffer将会被提交：一个新的segment(一个额外的新的倒序索引)将被写到磁盘 一个新的提交点(commit point)被写入磁盘，将包含新的segment的名称。 磁盘fsync，所有在内核文件系统中的数据等待被写入到磁盘，来保障它们被物理写入。</li>
<li>新的segment被打开，使它包含的文档可以被索引。</li>
<li>内存中的buffer将被清理，准备接收新的文档。</li>
</ul>
</li>
<li>当一个新的请求来时，会遍历所有的segments。词条分析程序会聚合所有的segments来保障每个文档和词条相关性的准确。通过这种方式，新的文档轻量的可以被添加到对应的索引中。</li>
</ul>
<h4 id="删除和更新">删除和更新</h4><ul>
<li>segments是不变的，所以文档不能从旧的segments中删除，也不能在旧的segments中更新来映射一个新的文档版本。取之的是，每一个提交点都会包含一个.del文件，列举了哪一个segmen的哪一个文档已经被删除了。 当一个文档被”删除”了，它仅仅是在.del文件里被标记了一下。被”删除”的文档依旧可以被索引到，但是它将会在最终结果返回时被移除掉。</li>
<li>文档的更新同理：当文档更新时，旧版本的文档将会被标记为删除，新版本的文档在新的segment中建立索引。也许新旧版本的文档都会本检索到，但是旧版本的文档会在最终结果返回时被移除。</li>
</ul>
<h4 id="实时索引">实时索引</h4><ul>
<li>在上述的per-segment搜索的机制下，新的文档会在分钟级内被索引，但是还不够快。 瓶颈在磁盘。将新的segment提交到磁盘需要fsync来保障物理写入。但是fsync是很耗时的。它不能在每次文档更新时就被调用，否则性能会很低。</li>
<li>现在需要一种轻便的方式能使新的文档可以被索引，这就意味着不能使用fsync来保障。 在ES和物理磁盘之间是内核的文件系统缓存。之前的描述中,Figure19,Figure20，在内存中索引的文档会被写入到一个新的segment。但是现在我们将segment首先写入到内核的文件系统缓存，这个过程很轻量，然后再flush到磁盘，这个过程很耗时。但是一旦一个segment文件在内核的缓存中，它可以被打开被读取。</li>
</ul>
<p><img src="/images/elk/3-3.png" alt="term"></p>
<p><img src="/images/elk/3-4.png" alt="term"></p>
<h4 id="更新持久化">更新持久化</h4><p>不使用fsync将数据flush到磁盘，我们不能保障在断电后或者进程死掉后数据不丢失。ES是可靠的，它可以保障数据被持久化到磁盘。 在2.6.2中，一个完全的提交会将segments写入到磁盘，并且写一个提交点，列出所有已知的segments。当ES启动或者重新打开一个index时，它会利用这个提交点来决定哪些segments属于当前的shard。 如果在提交点时，文档被修改会怎么样？不希望丢失这些修改：</p>
<ul>
<li>当一个文档被索引时，它会被添加到in-memory buffer，并且添加到Translog日志中，见Figure21.</li>
</ul>
<p><img src="/images/elk/3-5.png" alt="term"></p>
<ul>
<li>refresh操作会让shard处于Figure22的状态：每秒中，shard都会被refreshed，在in-memory buffer中的文档会被写入到一个新的segment，但没有fsync，in-memory buffer被清空。</li>
</ul>
<p><img src="/images/elk/3-6.png" alt="term"></p>
<ul>
<li>这个过程将会持续进行：新的文档将被添加到in-memory buffer和translog日志中，见Figure23</li>
</ul>
<p><img src="/images/elk/3-7.png" alt="term"></p>
<ul>
<li>一段时间后，当translog变得非常大时，索引将会被flush，新的translog将会建立，一个完全的提交进行完毕。见Figure24<ul>
<li>在in-memory中的所有文档将被写入到新的segment.</li>
<li>内核文件系统会被fsync到磁盘。</li>
<li>旧的translog日志被删除</li>
</ul>
</li>
</ul>
<p><img src="/images/elk/3-8.png" alt="term"></p>
<p>translog日志提供了一个所有还未被flush到磁盘的操作的持久化记录。当ES启动的时候，它会使用最新的commit point从磁盘恢复所有已有的segments，然后将重现所有在translog里面的操作来添加更新，这些更新发生在最新的一次commit的记录之后还未被fsync。</p>
<p>translog日志也可以用来提供实时的CRUD。当你试图通过文档ID来读取、更新、删除一个文档时，它会首先检查translog日志看看有没有最新的更新，然后再从响应的segment中获得文档。这意味着它每次都会对最新版本的文档做操作，并且是实时的。</p>
<h4 id="Segment合并">Segment合并</h4><ul>
<li>通过每隔一秒的自动刷新机制会创建一个新的segment，用不了多久就会有很多的segment。segment会消耗系统的文件句柄，内存，CPU时钟。最重要的是，每一次请求都会依次检查所有的segment。segment越多，检索就会越慢。</li>
<li>ES通过在后台merge这些segment的方式解决这个问题。小的segment merge到大的，大的merge到更大的。。。</li>
<li>这个过程也是那些被”删除”的文档真正被清除出文件系统的过程，因为被标记为删除的文档不会被拷贝到大的segment中。合并过程如Figure25：<ul>
<li>当在建立索引过程中，refresh进程会创建新的segments然后打开他们以供索引。</li>
<li>merge进程会选择一些小的segments然后merge到一个大的segment中。这个过程不会打断检索和创建索引。</li>
<li>Figure26，一旦merge完成，旧的segments将被删除：新的segment被flush到磁盘，一个新的提交点被写入，包括新的segment，排除旧的小的segments，新的segment打开以供索引旧的segments被删除。</li>
</ul>
</li>
</ul>
<p><img src="/images/elk/3-9.png" alt="term"></p>
<p><img src="/images/elk/3-10.png" alt="term"></p>
<p>merge大的segments会消耗大量的I/O和CPU，严重影响索引性能。默认，ES会节制merge过程来给留下足够多的系统资源。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/10/year-books/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eric Chang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric Chang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/10/year-books/" itemprop="url">
                  2017我的年度书单
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-10T00:00:00+08:00">
                2017-12-10
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/12/10/year-books/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/12/10/year-books/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="引言">引言</h3><ul>
<li>今年是工作的第一年，虽然非常忙，但仍然静下心读了几本书。</li>
<li>书籍相比于公众号、博客、各种手机APP等，在获取信息的效率方面确实比较逊色，但是读书的目的远远不仅是获取信息。读书、思考、认识、改变应当是一个有机统一的整体。书中的世界和我们眼中的世界有时是不同的，我想，这可能就是读书的意义所在吧。</li>
<li>读书本身并不是学习，学习有很多渠道，不一定非要读书。如果说读书可以促使人进步，我想，不如说由读书引发的思考使人进步。思考力已经成为在这个飞速发展和变化的社会生存的核心竞争力。</li>
<li>下面，分享我今年读的几本书，如果您对这些书籍或领域也感兴趣，欢迎邮件交流。</li>
</ul>
<h3 id="2017-我的书单">2017-我的书单</h3><ul>
<li>《经济学基础》<ul>
<li>作者：[美] 曼昆 </li>
<li>曼昆是美国著名经济学家、哈佛大学经济学教授，本书是美国乃至全球经济学和金融学专业的知名的教科书。</li>
<li>本书最大的特点是将深刻的经济学原理和普通人的生活相结合，深入浅出，用类比的思想讲解经济学的基本原理。</li>
<li>本书涉及了经济学最深刻的本质：经济为何能够成为人类社会生活的一部分？为什么要有经济和金融，它有没有替代品？经济为人性服务还是人性为经济服务？</li>
<li>如果您能将本书中的西方经济学思想和中国的具体实际相结合，您就会发现当今中国的各种经济现象的本源和基本的解决方案。大到国家层面的大政方针、小到我们每个人的财务支配，经济学原理就像一只无形的手支配着所有人的经济行为。</li>
<li>本书是经济学经典著作《国富论》的延伸和发展，将现代经济学、金融学和西方经济学的思想融为一体，非常值得认真阅读。</li>
</ul>
</li>
</ul>
<p><img src="/images/2017books/book1.jpg" alt="book1"></p>
<ul>
<li>《乌合之众》<ul>
<li>作者：[法] 居斯塔夫·勒庞 </li>
<li>作者勒庞是法国社会心理学家、社会学家、群体心理学创始人，本书是群体心理学的鼻祖。</li>
<li>虽然群体心理学和个体心理学所揭示的心理学基本原理在本质上高度一致，但是群体心理学在研究方法、外在表象、应用实践等方面与个体心理学有着很大的不同。</li>
<li>本书不是心理学教材，而是一本心理学专著，对于没有心理学背景的读者来说，可能不容易领会其中的内涵。建议在阅读本书前先阅读戴维·迈尔斯的《社会心理学》。</li>
<li>本书提出了几个较为深刻的问题，就连勒庞自己也没有给出完美的解答：为什么将个体放在群体中就会出现和个体单独存在时完全不同、甚至截然相反的心理表现？社会和群体存在和意义和价值是什么？不同种族、不同信仰、不同价值观的人如何合作？社会群体和家庭如何影响个体的心理发展？</li>
<li>如果您对心理学在群体中的表征看兴趣，可以阅读此书。</li>
</ul>
</li>
</ul>
<p><img src="/images/2017books/book2.jpg" alt="book2"></p>
<ul>
<li>《合作的进化》<ul>
<li>作者：[美] 罗伯特·阿克塞尔罗德 </li>
<li>本书很薄，一两周便能够通读完成；</li>
<li>不同于《乌合之众》，本书专注于行为心理学的研究和实践，而不是侧重群体心理学。</li>
<li>阅读完本书您会发现，人类的一切政治、经济、军事、科技、教育、娱乐活动无不暗含着行为心理学的基本原理，可以说行为心理学指导人类进行各种社会活动，社会活动本身反过来也影响人的行为。人的行为在一定程度上是可预测的。</li>
<li>如果您对博弈论感兴趣，建议将本书和博弈论相关书籍一起阅读，您会发现人类行为不知不觉也应用了博弈论的基本原理，并且对企业间、国家间的合作理解得更为深刻和透彻。</li>
</ul>
</li>
</ul>
<p><img src="/images/2017books/book3.jpg" alt="book3"></p>
<ul>
<li>《变态心理学》<ul>
<li>作者：[美] 德博拉 C.贝德尔 （Deborah C. Beidel） / 辛西娅 M. 布利克（Cynthia M. Bulik） / 梅琳达•斯坦利（Melinda A. Stanley） </li>
<li>本书讲解了非常态心理的基本原理，比如造成孤独症、焦虑症、抑郁症的原因和基本治疗方法。虽然只有心理学相关专业才需要这些知识，但是我还是完整阅读本书，对非常态心理有了基本的理解。</li>
<li>本书不仅包含理论研究，而且还包含了大量生动的例子和临床实践，便于读者了解问题的表象和本质原因。</li>
<li>本书中还有很多概念我不太理解，需要再次阅读其他变态心理学著作配合理解。</li>
</ul>
</li>
</ul>
<p><img src="/images/2017books/book4.jpg" alt="book4"></p>
<ul>
<li>《聪明的投资者》<ul>
<li>作者：[美] 本杰明·格雷厄姆 </li>
<li>本书作者本杰明·格雷厄姆是美国经济学家和投资思想家、价值投资理论奠基人、巴菲特的老师。</li>
<li>本书是价值投资的最为经典的著作，没有之一。</li>
<li>如果您对投资感兴趣，或者准备成为股东，强烈推荐阅读此书。</li>
<li>本书理论部分不多，对于大多数章节，都直接给出作者的观点或者结论，比如投资的基本原则和注意事项、公司或股票的选择原则、如何在股市中盈利和止损等。</li>
<li>本书并没有讲解太多技术面的操作技巧，如果需要了解技术面，不建议阅读本书。</li>
</ul>
</li>
</ul>
<p><img src="/images/2017books/book5.jpg" alt="book5"></p>
<ul>
<li>《人人都是经营者》<ul>
<li>作者：[中] 刁东平 </li>
<li>阿米巴经营模式的核心，是经营哲学、组织结构设计、内部市场、经营会计、人才培养、内部运行等等一整套理论的有机整合，作者认为这是比较适合中国企业的、但尚未在中国企业中广泛应用的一种经营模式。</li>
<li>我个人认为，阿米巴经营模式适用于那种资金流动性大、具有较充足的流动资金、处于朝阳产业并想要扩大生产的中型企业。准备上市的企业也可以参考运用。</li>
<li>任何一种模式都无法代替“实事求是”四个字，应当根据企业的实际情况，使用适合自己的模式。</li>
</ul>
</li>
</ul>
<p><img src="/images/2017books/book6.jpg" alt="book6"></p>
<ul>
<li>《巴菲特之道》<ul>
<li>作者：[美] 罗伯特·哈格斯特朗 </li>
<li>想了解投资大师巴菲特？就读这本书！</li>
<li>本书介绍了巴菲特的个人经历，以及如果从一位投资小白成长为投资大师的传奇经历，从这段经历中，我们也可以看出巴菲特的投资思想的变迁。</li>
<li>虽说成功不可复制，但是参考巴菲特成功的经历，多多少少有所启发、有所借鉴。</li>
</ul>
</li>
</ul>
<p><img src="/images/2017books/book7.jpg" alt="book7"></p>
<ul>
<li>《看见》<ul>
<li>作者：[中] 柴静</li>
<li>本书给了读者看中国的另一只眼睛。</li>
<li>本书中所写的都是记者柴静的采访经历，看起来都是一些小事，但却能反映最真实的中国的现状。本书书名为《看见》，的确，读完本书后，我看见了一些以前不曾看见的东西，对中国的改革、发展有了更深刻的认识，对发展中遇到的问题和解决方法有了更深刻的认识。</li>
<li>历史就是一个和另一个的《看见》所书写的，《看见》不仅是为了看见，更是为了改变和进步。</li>
</ul>
</li>
</ul>
<p><img src="/images/2017books/book8.jpg" alt="book8"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/me.png"
               alt="Eric Chang" />
          <p class="site-author-name" itemprop="name">Eric Chang</p>
           
              <p class="site-description motion-element" itemprop="description"><a href="http://www.yinshuisiyuan.net">www.yinshuisiyuan.net</a></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">100</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">51</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/changsiyuan" target="_blank" title="github">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/2803286360" target="_blank" title="weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.linkedin.com/profile/preview?locale=zh_CN&trk=prof-0-sb-preview-primary-button" target="_blank" title="linkedin">
                  
                    <i class="fa fa-fw fa-linkedin"></i>
                  
                  linkedin
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:changsiyuan2011@126.com" target="_blank" title="mail">
                  
                    <i class="fa fa-fw fa-envelope"></i>
                  
                  mail
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.ruanyifeng.com/home.html" title="阮一峰" target="_blank">阮一峰</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://azure.microsoft.com/en-us/?v=17.14" title="Azure" target="_blank">Azure</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" title="Python" target="_blank">Python</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434501245426ad4b91f2b880464ba876a8e3043fc8ef000" title="Nodejs" target="_blank">Nodejs</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Eric Chang</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


<a rel="license" href="http://creativecommons.org/licenses/by/3.0/cn/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by/3.0/cn/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by/3.0/cn/">知识共享署名 3.0 中国大陆许可协议</a>进行许可。
  
  <script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v1/st.js','_st');

  _st('install','1BK1VZMDEA-ktxiBz_9B');
</script>

<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1258423514'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1258423514%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>




        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"ericchang"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  
















  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>





  

  

  

  

</body>
</html>
