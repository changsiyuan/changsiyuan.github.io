<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="www.yinshuisiyuan.net">
<meta property="og:type" content="website">
<meta property="og:title" content="Eric Chang's Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Eric Chang's Blog">
<meta property="og:description" content="www.yinshuisiyuan.net">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Eric Chang's Blog">
<meta name="twitter:description" content="www.yinshuisiyuan.net">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> Eric Chang's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  











  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1258423514&web_id=1258423514" language="JavaScript"></script>
  </div>






  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Eric Chang's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-feeling">
          <a href="/tags/feeling" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-coffee"></i> <br />
            
            生活
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/tags/me" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/18/2018-7-18-Architecture-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eric Chang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric Chang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/07/18/2018-7-18-Architecture-7/" itemprop="url">
                  Architecture（七）旁路缓存策略
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-18T00:00:00+08:00">
                2018-07-18
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/07/18/2018-7-18-Architecture-7/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/07/18/2018-7-18-Architecture-7/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="引言">引言</h3><ul>
<li>本文介绍数据库中的旁路缓存策略；</li>
</ul>
<h3 id="旁路缓存策略">旁路缓存策略</h3><ul>
<li>旁路缓存策略（cache aside pattern）是一种数据库结合缓存的设计模式；</li>
<li>基本架构：<ul>
<li>数据库有主数据库（用于写）、从数据库（用于读），另有缓存用于提升读写效率；</li>
</ul>
</li>
</ul>
<h3 id="策略概述">策略概述</h3><ul>
<li>读请求：<ul>
<li>先读缓存，如果不命中，再读从数据库；</li>
<li>如果缓存不命中，读从数据库后，写入缓存，方便下次命中；</li>
</ul>
</li>
<li>写请求：<ul>
<li>先写主数据库，再淘汰缓存；原因：数据总是以数据库为准，而不是以缓存为准，先写作为标准的一方；</li>
<li>淘汰缓存，而不是更新缓存；原因：如果更新而不淘汰缓存，则A\B两个进程并行写时，A写主数据库-&gt;B写主数据库-&gt;B更新缓存-&gt;A更新缓存，则业务期望的缓存为B写入的，但事实缓存中留存A写入的；</li>
</ul>
</li>
</ul>
<h3 id="存在的问题">存在的问题</h3><ul>
<li>由于主数据库和从数据库不能及时同步，且读请求总是从从数据库中读并更新缓存，导致缓存始终和从数据库一致，即缓存旧数据的时候，主数据库已经是新数据了；</li>
<li>解决方案：当主数据库同步到从数据库时，清除缓存。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/17/2018-7-17-Architecture-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eric Chang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric Chang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/07/17/2018-7-17-Architecture-6/" itemprop="url">
                  Architecture（六）数据库架构设计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-17T00:00:00+08:00">
                2018-07-17
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/07/17/2018-7-17-Architecture-6/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/07/17/2018-7-17-Architecture-6/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="引言">引言</h3><ul>
<li>本文介绍数据库中的架构设计；</li>
<li>通常，单机是无法满足大系统对数据库的读写要求的，必须用集群的方式来解决；</li>
<li>引入集群意味着提升了系统的复杂度，使系统变得复杂和不好维护；</li>
<li>通常采用数据库负载均衡策略、读写分离策略、分库分表策略等加以优化；</li>
</ul>
<h3 id="负载均衡">负载均衡</h3><ul>
<li>扩展性强：当系统要更高数据库处理速度时，只要简单地增加数据库服务器就可以得到扩展；</li>
<li>可维护性：当某节点发生故障时，系统会自动检测故障并转移故障节点的应用，保证数据库的持续工作；</li>
<li>安全性：<ul>
<li>因为数据会同步的多台服务器上，可以实现数据集的冗余，通过多份数据来保证安全性；</li>
<li>将数据库放到了内网之中，更好地保护了数据库的安全性；</li>
</ul>
</li>
<li>易用性：对应用来说完全透明，集群暴露出来的就是一个IP(1) 不能够按照Web服务器的处理能力分配负载；</li>
<li>缺点：负载均衡器(控制端)故障，会导致整个数据库系统瘫痪；</li>
</ul>
<h3 id="读写分离">读写分离</h3><ul>
<li>当读和写的频率相差很多时（ebay的读写比率是260:1），为了提升效率，减少磁盘IO压力，采取读写分离；</li>
<li>实现原理：<ul>
<li>数据库服务器搭建主从集群，一主一从、一主多从都可以；</li>
<li>数据库主机负责读写操作，从机只负责读操作；</li>
<li>数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了所有的业务数据；</li>
<li>业务服务器将写操作发给数据库主机，将读操作发给数据库从机；</li>
</ul>
</li>
<li><p>主从机数据不一致的解决：</p>
<ul>
<li>数据不一致：当数据写入主服务器后，要在下次同步后才能查询到；</li>
<li>读从机失败后再读一次主机；</li>
<li><p>关键业务(账号、转账等)读写操作全部指向主机，非关键业务采用读写分离；</p>
<p><img src="/images/Architecture/Architecture12.png" alt="term"></p>
</li>
</ul>
</li>
</ul>
<h3 id="分库分表">分库分表</h3><h4 id="分数据库">分数据库</h4><ul>
<li>是指按功能模块拆分到不同的数据库，比如分为订单库、商品库、用户库；</li>
<li>join只适用于同一数据库的不同表联合查询，拆分后不同数据库之间无法用join语句进行查询，只能分几次查询；</li>
<li>事务是同一数据库中的概念，要想在不同数据库之间实现事务的回滚，只能用查询log回滚的方式；</li>
<li>成本高，拆分到不同的数据库意味着需要建立多个备份数据库；</li>
</ul>
<h4 id="分数据库表_-_垂直(纵向)拆分">分数据库表 - 垂直(纵向)拆分</h4><ul>
<li>原先是一个表中包含所有10个字段；</li>
<li>现在将查询频率特别高的字段分离到另外的表中（比如婚恋网站的name, sex, age三个字段），其他字段（如个人介绍destribution等）留在原表；</li>
<li>优点：查询性能提升，如果只查询重要字段，无需将其他字段也查出来，速度很快；</li>
<li>缺点：如果要查出所有字段，必须经过两次查询；</li>
</ul>
<h4 id="分数据库表_-_水平(横向)拆分">分数据库表 - 水平(横向)拆分</h4><ul>
<li>将同一个表的数据进行分块保存到不同的数据库中，这些数据库中的表结构完全相同；</li>
<li>顺序路由：<ul>
<li>如可以按订单的日前按年份才分，2003年的放在db1中，2004年的db2,以此类推；</li>
<li>缺点是数据分布不均，可能2003年的订单有100W，2008年的有500W；</li>
</ul>
</li>
<li>hash路由：<ul>
<li>对user_id进行hash（或者如果user_id是数值型的话直接使用user_id的值也可），然后用一个特定的数字，比如应用中需要将一个数据库切分成4个数据库的话，我们就用4这个数字对user_id的hash值进行取模运算，决定存在哪个表中；</li>
<li>如果现在想将4个表变成5个表，改变膜值，则所有的数据都需要改变位置，很麻烦；</li>
</ul>
</li>
<li>配置路由：<ul>
<li>就是建立一个DB，这个DB单独保存user_id到DB的映射关系，每次访问数据库的时候都要先查询一次这个数据库，以得到具体的DB信息，然后才能进行我们需要的查询操作；</li>
<li>优点：灵活性强，一对一关系；</li>
<li>缺点：每次查询之前都要多一次查询，会造成一定的性能损失；</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/16/2018-7-16-Architecture-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eric Chang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric Chang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/07/16/2018-7-16-Architecture-5/" itemprop="url">
                  Architecture（五）微服务概述
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-16T00:00:00+08:00">
                2018-07-16
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/07/16/2018-7-16-Architecture-5/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/07/16/2018-7-16-Architecture-5/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="引言">引言</h3><ul>
<li>本文介绍微服务架构。</li>
</ul>
<h3 id="微服务特点">微服务特点</h3><ul>
<li>对服务来说：<ul>
<li>服务小，松耦合：服务面向一个独立的业务逻辑，SOA（service oriented architecture）；</li>
<li>独立的进程；</li>
<li>轻量级通信：用https协议通信，用json数据格式；</li>
</ul>
</li>
<li>对团队来说：<ul>
<li>独立开发：不同团队无需相同技术栈，每个团队维护自己的数据源；</li>
<li>独立部署：不需要过多协调不同团队进度；</li>
<li>康威法则：设计系统的组织，其产生的设计等同于组织之内、组织之间的沟通结构；</li>
</ul>
</li>
<li>弊端：<ul>
<li>技术栈众多；</li>
<li>分布式系统，数据只能保证最终一致；</li>
<li>运维和测试复杂；</li>
</ul>
</li>
</ul>
<h3 id="实践建议">实践建议</h3><ul>
<li>何时使用：<ul>
<li>系统复杂性较低时不使用微服务，使用单块应用，因为微服务所需的基础设施成本高，业务不复杂时微服务的优势无法体现出来；</li>
<li>系统复杂性提升时，逐步将单块应用拆解为微服务；</li>
</ul>
</li>
<li>拆分粒度：<ul>
<li>微服务拆分粒度过粗，则体现不出微服务的价值；</li>
<li>拆分过细又导致：维护、测试成本上升，效率下降；服务调用链太长，问题定位不方便，性能也会下降；</li>
<li>一般一个微服务由2-3个人负责最为合适；每个人能够全面理解系统；能够相互讨论避免出错；</li>
</ul>
</li>
<li>自动化：<ul>
<li>随着微服务的增多，自动化工具必须提供，否则维护成本太高；</li>
</ul>
</li>
</ul>
<h3 id="如何拆分">如何拆分</h3><ul>
<li>根据业务逻辑拆分；</li>
<li>根据服务成熟度拆分：成熟服务，可能会变化的服务；</li>
<li>根据可靠性需求拆分：必须保证99.999%可靠的核心服务，保证99%可靠就可以的非核心服务；</li>
<li>根据性能需求拆分：将性能要求高或者性能压力大的模块拆分出来，避免性能压力大的服务影响其他服务；</li>
</ul>
<h3 id="微服务需要考虑">微服务需要考虑</h3><p><img src="/images/Architecture/Architecture10.png" alt="term"></p>
<h3 id="微服务和SOA的区别">微服务和SOA的区别</h3><ul>
<li><strong>Class</strong> Microservice <em>implements</em> SOA；</li>
</ul>
<p><img src="/images/Architecture/Architecture11.png" alt="term"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/15/2018-7-15-Architecture-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eric Chang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric Chang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/07/15/2018-7-15-Architecture-4/" itemprop="url">
                  Architecture（四）负载均衡
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-15T00:00:00+08:00">
                2018-07-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/07/15/2018-7-15-Architecture-4/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/07/15/2018-7-15-Architecture-4/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="引言">引言</h3><ul>
<li>本文介绍几种负载均衡架构及算法。</li>
</ul>
<h3 id="总体策略">总体策略</h3><ul>
<li>DNS负载均衡用于实现地理级别的负载均衡；</li>
<li>硬件负载均衡用于实现集群级别的负载均衡；</li>
<li>软件负载均衡用于实现机器级别的负载均衡；</li>
</ul>
<p><img src="/images/Architecture/Architecture7.png" alt="term"></p>
<h3 id="硬件负载均衡">硬件负载均衡</h3><ul>
<li>类似路由器、交换机；</li>
<li>优点：<ul>
<li>支持各种负载均衡算法；</li>
<li>支持100万并发（一般软件负载均衡也就支持10万并发）；</li>
<li>很多设备同时支持负载均衡、防火墙、防DDOS攻击功能；</li>
</ul>
</li>
<li>缺点：<ul>
<li>价格高昂；</li>
</ul>
</li>
</ul>
<h3 id="软件负载均衡">软件负载均衡</h3><ul>
<li>优点：<ul>
<li>便宜；</li>
<li>维护和部署简单（安装Ngnix软件即可）；</li>
</ul>
</li>
<li>缺点：<ul>
<li>并发量远小于硬件负载均衡，Linux服务器上装一个Nginx大概能到5万每秒；</li>
<li>一般不具备防火墙、防DDOS攻击等功能；</li>
</ul>
</li>
</ul>
<p><img src="/images/Architecture/Architecture8.png" alt="term"></p>
<h3 id="DNS负载均衡">DNS负载均衡</h3><ul>
<li>实现地理级别的负载均衡；</li>
<li>DNS服务器将域名解析为最靠近用户的主机的IP地址，提升访问速度；</li>
<li>缺点：<ul>
<li>DNS缓存不能及时更新，有可能定位到一个已经移走的主机；</li>
<li>除了映射IP地址，没有提供其他的负载均衡算法和策略；</li>
</ul>
</li>
</ul>
<p><img src="/images/Architecture/Architecture9.png" alt="term"></p>
<h3 id="均衡算法">均衡算法</h3><ul>
<li>轮询：<ul>
<li>负载均衡系统收到请求后，按照顺序轮流分配到服务器上；</li>
<li>算法简单，没有考虑机器的状态；</li>
</ul>
</li>
<li>加权轮询：<ul>
<li>分给32核机器的概率是分给16核机器的概率的两倍；</li>
<li>考虑了机器性能，但无法根据机器状态动态调整；</li>
</ul>
</li>
<li>负载最低优先：<ul>
<li>根据及其具体状态决定负载均衡策略；</li>
<li>考虑：机器连接数、机器的HTTP连接数、CPU占用率、IO占用率；</li>
</ul>
</li>
<li>性能最佳优先：<ul>
<li>根据及其具体状态决定负载均衡策略；</li>
<li>考虑：服务器响应时间；</li>
</ul>
</li>
<li>Hash：<ul>
<li>对源IP地址hash决定任务分配到哪台服务器；</li>
<li>对session ID进行hash决定任务分配到哪台服务器，可以保证同一个会话的包都发送到同一台服务器处理；</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/10/2018-7-10-Architecture-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eric Chang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric Chang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/07/10/2018-7-10-Architecture-3/" itemprop="url">
                  Architecture（三）基本架构
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-10T00:00:00+08:00">
                2018-07-10
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/07/10/2018-7-10-Architecture-3/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/07/10/2018-7-10-Architecture-3/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="引言">引言</h3><ul>
<li>本文介绍几种基本架构及其优缺点</li>
</ul>
<h3 id="CAP原理">CAP原理</h3><ul>
<li>独裁者架构：<ul>
<li>优点：只有一个决策者，不会混乱；决策者随时掌控所有机器状态（上报者发送信条给决策者），实现统一调度；决策机器不存储数据，其他机器存储；</li>
<li>缺点：一旦决策者宕机，集群群龙无首；</li>
</ul>
</li>
</ul>
<p><img src="/images/Architecture/Architecture3.png" alt="term"></p>
<ul>
<li>主备协商：<ul>
<li>优点：主机备机都存数据；从机平时不提供数据，只在主机出问题时升级为主机；主机坏了马上切换到备机；</li>
<li>缺点：一旦主备机之间的通讯中断，则数据不同步。备机连不上主机，如果备机认为主机损坏，则自己升级为主机，如果主机实际上没有坏，外部用户会以为这个系统有两个主机，造成混乱。如果备机认为主机没有损坏，则自己不会升级为主机，如果主机实际上坏了，外部用户会以为这个系统没有主机，造成混乱。</li>
</ul>
</li>
</ul>
<p><img src="/images/Architecture/Architecture4.png" alt="term"></p>
<ul>
<li>主从协商：<ul>
<li>优点：从机正常情况下也是要提供读的操作；主从复制在主机故障时，读操作相关的业务可以继续运行；不浪费从机资源；</li>
<li>缺点：可能数据不一致；</li>
</ul>
</li>
</ul>
<p><img src="/images/Architecture/Architecture5.png" alt="term"></p>
<ul>
<li>民主选举：<ul>
<li>介绍：只有一个管理者；多个独立个体自由交换信息；个体通过一定规则的选举生成管理节点；获得多数票者取胜；</li>
<li>缺点：如果个体间部分通讯中断，则系统很有可能分裂为多个小集群，如果每个小集群都选举出一个管理者，则造成混乱，解决方法是规定投票节点数必须超过系统总节点数一半；</li>
</ul>
</li>
</ul>
<p><img src="/images/Architecture/Architecture6.png" alt="term"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/21/2018-6-21-Architecture-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eric Chang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric Chang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/06/21/2018-6-21-Architecture-2/" itemprop="url">
                  Architecture（二）CAP原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-21T00:00:00+08:00">
                2018-06-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/21/2018-6-21-Architecture-2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/06/21/2018-6-21-Architecture-2/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="引言">引言</h3><ul>
<li>本文介绍了CAP原理；</li>
</ul>
<h3 id="CAP原理">CAP原理</h3><ul>
<li>在一个分布式系统中，Consistency（数据一致性）、 Availability（服务可用性）、Partition tolerance（分区容错性），三者不可兼得；</li>
<li>一般来说，分布式系统优先实现P和A，C用最终一致性代替；</li>
</ul>
<h3 id="详细解释">详细解释</h3><ul>
<li>一致性：All nodes see the same data at the same time；</li>
<li>可用性：A non-failing node will return a reasonable response within a reasonable amount of time (no error or timeout)；</li>
<li>分区容错性：出现消息丢失或者分区错误时系统能够继续运行；</li>
</ul>
<h3 id="使用案例">使用案例</h3><ul>
<li>保证CP牺牲A：当系统不同节点间通讯中断、不能及时同步数据时，为了保证数据一致，此时对用户请求返回error错误信息，即系统暂时不可用；</li>
</ul>
<p><img src="/images/Architecture/Architecture1.png" alt="term"></p>
<ul>
<li>保证AP牺牲C：有可能向用户返回旧数据，即脏读；</li>
</ul>
<p><img src="/images/Architecture/Architecture2.png" alt="term"></p>
<ul>
<li>保证AC牺牲P：系统中只有一个节点，已经不是分布式系统；</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/16/2018-4-16-Architecture-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eric Chang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric Chang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/16/2018-4-16-Architecture-1/" itemprop="url">
                  Architecture（一）架构简介
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-16T00:00:00+08:00">
                2018-04-16
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/04/16/2018-4-16-Architecture-1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/04/16/2018-4-16-Architecture-1/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="引言">引言</h3><ul>
<li>架构的设计在软件设计中极为重要，一个好的架构设计能够成倍提升开发和运维效率、提升产品的交付能力；</li>
<li>架构设计的思路和软件编程有很大不同，这不仅仅体现在所需知识的不同、而且思维模式和设计理念也各不相同；</li>
<li>在工作之余，我认真学习了极客时间的<a href="https://time.geekbang.org/column/81" target="_blank" rel="external">从0开始学架构</a>课程，受益匪浅；</li>
<li>接下来我会用若干篇幅的博客展示一下学习笔记，欢迎大家指教；</li>
<li>本文对架构设计的原则和目的加以总结；</li>
</ul>
<h3 id="架构设计的目的">架构设计的目的</h3><ul>
<li>目的：解决软件系统复杂性带来的问题；</li>
<li>核心：balance；<ul>
<li>平衡希望系统高性能、高扩展性和时间成本、开发成本之间的矛盾；</li>
<li>对各种设计的优缺点做取舍；</li>
</ul>
</li>
</ul>
<h3 id="架构设计原则">架构设计原则</h3><ul>
<li><strong>合适优于业界领先</strong>：很适合别的系统的架构，不一定适合当前项目，不是每个系统都需要架构设计；</li>
<li><strong>简单优于复杂</strong>：架构设计不是为了片面追求系统的高可用性、高扩展性、高性能，而是最适合业务的实际情况；</li>
<li><strong>演化优于一步到位</strong>：架构是演化出来的，而不是设计出来的，谁都不可能在刚开始开发的时候、业务需求不明确的时候设计出完整的架构；</li>
</ul>
<h3 id="架构设计需要考虑">架构设计需要考虑</h3><ul>
<li>高性能：<ul>
<li>单机：充分利用CPU、disk、memory、IO等资源；</li>
<li>集群：如何扩展单机的处理能力，满足业务需求，比如春节发红包、双十一等；</li>
</ul>
</li>
<li>高可用：<ul>
<li>保证服务不间断正常运行；</li>
<li>应对：硬件故障，软件故障、网络故障，外部故障（水灾地震）；</li>
<li>保证高可用的核心：冗余；</li>
</ul>
</li>
<li>可扩展性：<ul>
<li>正确预测变化、完美封装变化；</li>
<li>所有的预测都存在出错的可能性；</li>
<li>适度的预测而不是完美的预测；</li>
</ul>
</li>
<li>安全性；</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/18/2018-1-18-ElasticSearch-Intro/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eric Chang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric Chang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/18/2018-1-18-ElasticSearch-Intro/" itemprop="url">
                  ElasticSearch原理简介
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-18T00:00:00+08:00">
                2018-01-18
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/01/18/2018-1-18-ElasticSearch-Intro/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/01/18/2018-1-18-ElasticSearch-Intro/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="引言">引言</h3><ul>
<li>ELK是重要的日志分析系统，在开源的日志分析系统中独占鳌头，最近公司业务用ELK分析告警日志，故系统研究了Elasticsearch的工作原理。</li>
<li>本文是转载的<a href="http://www.shaheng.me/blog/2015/06/elasticsearch--.html" target="_blank" rel="external">一篇文章</a>加上我自己的整理和分析，某些内容和ELK官网重复，在此感谢作者的整理。</li>
</ul>
<h3 id="基本概念">基本概念</h3><ul>
<li>简介：<ul>
<li>ElasticSearch(以下简称ES)是一个基于Lucene构建的开源(open-source)，分布式(distributed)，RESTful，实时(real-time)的搜索与分析(analytics)引擎。</li>
<li>它可以让你在浏览数据时具备非常快的速度和优秀的可扩展性。它用于全文索引、结构化数据索引、数据分析以及三者的结合。</li>
<li>它可以运行在你的笔记本上，或者扩展至数百台的服务器节点上来处理PB级的数据。 ES建立在Lucene的基础之上，但是Lucene仅仅是一个库，如果要发挥它的优势，你必须使用它然后再结合自己的开发来构造一个具体的应用。</li>
<li>更坏的是你必须了解Lucene才能更好的使用它，但是Lucene本身就很复杂。所以ES意在取Lucene的优点，隐蔽其复杂性来构造一个简洁易用的RESTful风格的全文搜索引擎。</li>
</ul>
</li>
<li>与关系型数据库的名词对照</li>
</ul>
<table>
<thead>
<tr>
<th>SQL database</th>
<th>No-sql database</th>
</tr>
</thead>
<tbody>
<tr>
<td>database</td>
<td>database</td>
</tr>
<tr>
<td>table</td>
<td>collection</td>
</tr>
<tr>
<td>row</td>
<td>document</td>
</tr>
<tr>
<td>column</td>
<td>field</td>
</tr>
<tr>
<td>primary key</td>
<td>primary key</td>
</tr>
</tbody>
</table>
<ul>
<li><p>ElasticSearch专用名词解释：</p>
<ul>
<li>document：一行数据；</li>
<li>index：一个database，是多个document的集合（和sql数据库的索引的概念不同），在kibana上显示为一组日志；</li>
<li>shard：ELK的底层存储是file，shared包含一个或多个file，是数据最小存储单元，一个index被划分为若干shared分片，一个shared可以备份到其他节点上（备份的份数可以自定义）；</li>
<li>node：物理节点；</li>
<li>cluster：集群；</li>
</ul>
</li>
<li><p>面向文档(Document Oriented)</p>
<ul>
<li>在应用程序中的对象(Objects)，不仅仅是keys和values的罗列，更多的是，他们是由更为复杂的数据结构组成的数据构成的。迟早你会将这些对象存储到DataBases(这里指更广义的持久层)。如果你要将这些已经通过复杂的结构体组织好的对象存储到传统的ROWS-COLUMNS的关系型数据库里无疑等于压榨你的财富：因为你必须将这些已经组织好了的复杂结构扁平化来适应传统数据库的表结构(通常是一个列一个字段)，然后以后每次在你要使用这个数据的时候再重组它们。</li>
<li>ES面向文档，这就意味着你可以存储完整的对象或者文档。ES不仅存储它们，并且对它们的每一个文档的内容做了索引以便可以查询到它们。在ES中，你是对文档进行的建索引、查询、排序、过滤，而不是对关系型数据的一行数据。这就是ES处理数据的一个最基本的不同点，这也是ES为什么能处理全文索引的关键。</li>
</ul>
</li>
<li><p>精确索引VS全文索引</p>
<ul>
<li>在ES中的数据可以分为两类：精确值(exact values)以及全文(full text)。 精确值：例如日期类型date，若date其有两个值:2014-09-15与2014，那么这两个值不相等。又例如字符串类型foo与Foo不相等。 全文：通常是人类语言写的文本，例如一段tweet信息、email的内容等。</li>
<li>精确值很容易被索引：一个值要么相当要么不等。 索引全文值就需要很多功夫。例如我们不仅要想：这个文档符合我们的查询吗？还要想：这个文档有多符合我们的查询？换句话说就是：这个文档跟我们的查询关联大吗？我们很少精确的去匹配整个全文，我们最想要的是去匹配全文文本的内部信息。除此，我们还希望搜索能够理解我们的意图;</li>
<li>例如,如果你搜索UK，我们需要包含United Kingdom的文本也会被匹配。如果你搜索jump，那么包含jumped,jumps,jumping,更甚者leap的文本会被匹配。</li>
<li>为了更方便的进行全文索引，ES首先要先分析文本，然后使用分析过的文本去创建倒序索引。</li>
</ul>
</li>
<li><p>倒序索引&amp;文本分析</p>
<ul>
<li>ES使用倒序索引来加速全文索引。一个倒序索引由两部分组成：在文档中出现的所有不同的词；对每个词，它所出现的文档的列表。 例如：如果我们有两个文档，每一个文档有一个content字段，包含的内容如下：</li>
</ul>
</li>
</ul>
<blockquote>
<p>1.The quick brown fox jumped over the lazy dog<br>2.Quick brown foxes leap over lazy dogs in summer</p>
</blockquote>
<p>要创建一个倒序索引，首先要将content分割成单独的词(称为terms or tokens)，创建一个所有terms的列表，然后罗列每一个term出现的文档。此过程称为tokenization。如下图：</p>
<p><img src="/images/elk/1-1.png" alt="term"></p>
<p>现在，如果我们想要搜索 quick brown，我们仅仅只需要找每一个term出现的文档即可。如下图：</p>
<p><img src="/images/elk/1-2.png" alt="term"></p>
<p>每一个文档都匹配到了，但是第一个比第二个要匹配的多。如果我们使用一个简单的相似性算法仅仅只计算匹配的数量，那么我们可以称第一个文档要比第二个匹配的好(与我们的查询更有关联)。<br>但是现在的倒序索引有一些问题：</p>
<blockquote>
<p>Quick与quick是两个不同的term，但是搜索的用户会认为它们应该是一样的term才是合理的。<br>fox和foxes，dog和dogs是一样的词根，应该列为同一个term。 jumped和leap虽然词根不一样，但是意义却相同。</p>
</blockquote>
<p>如果改善了上面的问题，那么倒序索引应该如下图：</p>
<p><img src="/images/elk/1-3.png" alt="term"></p>
<p>但是此时如果用户搜索Quick还会失败，因为term不含精确值Quick。但是，如果我们对QueryString使用与上述改善步骤相同的策略，那么用户搜索的Quick将会被转换为quick，此过程称为normalization。那么将会成功匹配。 对content的处理tokenization和normalization称为analysis过程。ES有很多种内置的analyzer处理这些。</p>
<h3 id="Elasticsearch设计原理">Elasticsearch设计原理</h3><h4 id="一个空的集群">一个空的集群</h4><p><img src="/images/elk/2-1.png" alt="term"></p>
<ul>
<li>如果我们启动了一个节点，没有索引没有数据，那么看起来就像上图一样。 一个节点Node运行着ES的实例，一个集群由一个或多个使用着同样名字(cluster.name)的节点组成，分享数据和负载。 当Node从集群中添加或删除时，集群会重组自己，使数据平摊的更均匀。</li>
<li>集群中需要有一台master节点。master的作用是掌管集群的管理工作： 例如创建和删除索引。 从集群中添加或删除一台节点。 master节点无需掌管文档级的变更和索引。这也意味着在只有一台master的情况下，随着负载的增加master不会成为瓶颈。 所有的节点都可能变成master。</li>
<li>作为user，我们可以与任何一台节点通信，包括master。每一台节点都知道每一个文档的位置并且可以将user的请求路由到文档所在的节点，并且这台节点负责接收它路由到的node or nodes的响应，并且将数据组织起来返回给用户。这些对用户都是透明的。</li>
</ul>
<h4 id="创建一个索引—index,shard,cluster">创建一个索引—index,shard,cluster</h4><ul>
<li>将数据添加到ES的前提是，我们需要一个索引(名词):index——一个存储与这个索引相对应数据的地方。实际上，index仅仅只是一个命名空间来指向一个或多个实际的物理分片(shard)。</li>
<li>一个分片(shard)是一个比较低层的工作单元来处理这个索引(index)的所有数据的一个切片(slice)。一个shard实际上是一个Lucene实例，在它的能力范围内拥有完整的搜索功能(在处理它自己拥有的数据时有所有的功能)。我们所有文档的索引indexed(动词)和存储工作都是在shard上，但这是透明的，我们不需要直接和shard通信，而是和我们创建的index(名词)通信。</li>
<li>shards是ES将数据分布式在你的集群的关键。想象下shards是数据的容器，文档存储在shards里，而shards被分配在集群的每一个节点Node里。当你的集群规模增长和降低时，ES会自动的在Nodes间迁移shards以保持集群的负载均衡。</li>
<li>shard的分类与作用：<ul>
<li>shard可分为primary shard和replica shard。</li>
<li>在一个index里的每一个文档都属于一个单独的primary shard，所以primary shard的数量决定了你最大能存储的数据量(对应于一个index)。</li>
<li>注意：shard是归属与index的，而不是cluster的。</li>
</ul>
</li>
<li>replica shard是primary shard的拷贝。replica有两个作用：   <ul>
<li>冗余容灾</li>
<li>提供读请求服务，例如搜索或读取文档primary shard的数量在索引创建时确定后不能修改，replica可以在任何时候修改。 例： 见Figure2，在2.1的集群上创建一个index，拥有3个primary shards以及1个replica shards。</li>
</ul>
</li>
</ul>
<p><img src="/images/elk/2-2.png" alt="term"></p>
<p>由于只有一台Node，而Primary shard的Replicas与其在同一台节点上毫无意义，所以集群没有初始化replicas，这时添加另外一台Node。见Figure3，每一个primary shard初始化了一个replica。</p>
<p><img src="/images/elk/2-3.png" alt="term"></p>
<h4 id="水平扩容">水平扩容</h4><p>当我们继续添加一台节点时，Node1和Node2中的各取一个shard移动到了Node3.见Figure4</p>
<p><img src="/images/elk/2-4.png" alt="term"></p>
<p>这样，我们每一台Node上只有两个shard。这就意味着每一台Node的硬件资源(CPU,RAM,I/O)将会被更少的shards共享，提高了每一个shard的性能。在这个案例中，6个shards最多可使用6台Node，这样每个shard就可以使用100%的node硬件资源。<br>现在我们修改replica的数量到2，如Figure5</p>
<p><img src="/images/elk/2-5.png" alt="term"></p>
<p>这样我们就有了一个3primary shards，6replica shards的Cluster。我们可将Node提高到9台。水平扩容了集群性能。</p>
<h4 id="容灾">容灾</h4><p>ES可以容下当节点宕机情况下的异常。例如现在我们杀掉Node1节点。见Figure6</p>
<p><img src="/images/elk/2-6.png" alt="term"></p>
<p>我们杀掉的是master节点。一个Cluster必须要有master以保证集群的功能正常。所以集群要做的第一件事是选择一个新的master：Node2. 当我们杀掉1节点时，Primary shards 1和2丢失了。如果丢失了primary shard，index(名词)将不能正常的工作。此时P1和P2的拷贝存在Node2和Node3上。所以此时新升级的master(Node2)将做的第一件事就是将NODE2和NODE3上的replica shard1和replica shard2升级为primary shard。此时如果我们杀掉NODE2，整个集群的容灾过程同理，还是可以正常运行。</p>
<p>这时，如果我们重启了NODE1，cluster将会重新分配缺少的两个replica shards(现在每个primary shard只有2个replicas，配置是3个，缺少2个)。如果NODE1的数据是旧的，那么它将会继续利用它们，NODE1只会从现在的Primary Shards拷贝这期间更改的数据。</p>
<h3 id="分布式文档存储">分布式文档存储</h3><h4 id="Shards文档路由">Shards文档路由</h4><p>当你对一个文档建立索引时，它仅存储在一个primary shard上。ES是怎么知道一个文档应该属于哪个shard？当你创建一个新的文档时，ES是怎么知道应该把它存储至shard1还是shard2？ 这个过程不能随机无规律的，因为以后我们还要将它取出来。它的路由算法是：</p>
<blockquote>
<p>shard = hash(routing) % numberofprimary_shards</p>
</blockquote>
<p>routing的值可以是文档的id，也可以是用户自己设置的一个值。hash将会根据routing算出一个数值然后%primaryshards的数量。这也是为什么primary_shards在index创建时就不能修改的原因。</p>
<p>问题：当看到这里时，产生了一个问题:ES为什么要这样设计路由算法，这样就强制使primaryshards不可变，不利于以后index的扩容，除非事前就要对数据规模有所评估来设计可扩展的index。为什么不能使用一致性hash解决primaryshards改变时的情况呢？</p>
<h4 id="Primary/Replica_Shards的交互">Primary/Replica Shards的交互</h4><p>假如我们有Figure8的集群。我们可以向这个集群的任何一台NODE发送请求，每一个NODE都有能力处理请求。每一个NODE都知道每一个文档所在的位置所以可以直接将请求路由过去。下面的例子，我们将所有的请求都发送到NODE1。</p>
<p><img src="/images/elk/2-7.png" alt="term"></p>
<p>注：最好的实践方式是轮询所有的NODE来发送请求，以达到请求负载均衡。</p>
<h4 id="写操作">写操作</h4><p>创建、索引、删除文档都是写操作，这些操作必须在primary shard完全成功后才能拷贝至其对应的replicas上。见Figure9。</p>
<p><img src="/images/elk/2-8.png" alt="term"></p>
<blockquote>
<p>1.客户端向Node1发送写操作的请求。<br>2.Node1使用文档的_id来决定这个文档属于shard0，然后将请求路由至NODE3，P0所在的位置。<br>3.Node3在P0上执行了请求。如果请求成功，则将请求并行的路由至NODE1 NODE2的R0上。当所有的replicas报告成功后，NODE3向请求的node(NODE1)发送成功报告，NODE1再报告至Client。<br>当客户端收到执行成功后，操作已经在Primary shard和所有的replica shards上执行成功了。</p>
</blockquote>
<h4 id="读操作">读操作</h4><p>一个文档可以在primary shard和所有的replica shard上读取。见Figure10</p>
<p><img src="/images/elk/2-9.png" alt="term"></p>
<blockquote>
<p>1.客户端发送Get请求到NODE1。<br>2.NODE1使用文档的_id决定文档属于shard 0.shard 0的所有拷贝存在于所有3个节点上。这次，它将请求路由至NODE2。<br>3.NODE2将文档返回给NODE1，NODE1将文档返回给客户端。 对于读请求，请求节点(NODE1)将在每次请求到来时都选择一个不同的replica。<br>shard来达到负载均衡。使用轮询策略轮询所有的replica shards。</p>
</blockquote>
<h4 id="更新操作">更新操作</h4><p>更新操作，结合了以上的两个操作：读、写。见Figure11</p>
<p><img src="/images/elk/2-10.png" alt="term"></p>
<blockquote>
<p>1.客户端发送更新操作请求至NODE1<br>2.NODE1将请求路由至NODE3，Primary shard所在的位置<br>3.NODE3从P0读取文档，改变source字段的JSON内容，然后试图重新对修改后的数据在P0做索引。如果此时这个文档已经被其他的进程修改了，那么它将重新执行3步骤，这个过程如果超过了retryon_conflict设置的次数，就放弃。<br>4.如果NODE3成功更新了文档，它将并行的将新版本的文档同步到NODE1和NODE2的replica shards重新建立索引。一旦所有的replica<br>shards报告成功，NODE3向被请求的节点(NODE1)返回成功，然后NODE1向客户端返回成功。</p>
</blockquote>
<h3 id="Shard以及数据读写方式的设计">Shard以及数据读写方式的设计</h3><h4 id="不变性">不变性</h4><ul>
<li>写到磁盘的倒序索引是不变的：自从写到磁盘就再也不变。这会有很多好处：<ul>
<li>不需要添加锁。如果你从来不用更新索引，那么你就不用担心多个进程在同一时间改变索引。</li>
<li>一旦索引被内核的文件系统做了Cache，它就会待在那因为它不会改变。只要内核有足够的缓冲空间，绝大多数的读操作会直接从内存而不需要经过磁盘。这大大提升了性能。</li>
<li>其他的缓存(例如fiter cache)在索引的生命周期内保持有效，它们不需要每次数据修改时重构，因为数据不变。</li>
<li>写一个单一的大的倒序索引可以让数据压缩，减少了磁盘I/O的消耗以及缓存索引所需的RAM。</li>
</ul>
</li>
<li>当然，索引的不变性也有缺点。如果你想让新修改过的文档可以被搜索到，你必须重新构建整个索引。这在一个index可以容纳的数据量和一个索引可以更新的频率上都是一个限制。</li>
</ul>
<h4 id="动态更新索引">动态更新索引</h4><p>如何在不丢失不变形的好处下让倒序索引可以更改？答案是：使用不只一个的索引。 新添额外的索引来反映新的更改来替代重写所有倒序索引的方案。 Lucene引进了per-segment搜索的概念。一个segment是一个完整的倒序索引的子集，所以现在index在Lucene中的含义就是一个segments的集合，每个segment都包含一些提交点(commit point)。见Figure16。新的文档建立时首先在内存建立索引buffer，见Figure17。然后再被写入到磁盘的segment，见Figure18。</p>
<p><img src="/images/elk/3-1.png" alt="term"></p>
<p><img src="/images/elk/3-2.png" alt="term"></p>
<ul>
<li>一个per-segment的工作流程如下：<ul>
<li>新的文档在内存中组织，见Figure17。</li>
<li>每隔一段时间，buffer将会被提交：一个新的segment(一个额外的新的倒序索引)将被写到磁盘 一个新的提交点(commit point)被写入磁盘，将包含新的segment的名称。 磁盘fsync，所有在内核文件系统中的数据等待被写入到磁盘，来保障它们被物理写入。</li>
<li>新的segment被打开，使它包含的文档可以被索引。</li>
<li>内存中的buffer将被清理，准备接收新的文档。</li>
</ul>
</li>
<li>当一个新的请求来时，会遍历所有的segments。词条分析程序会聚合所有的segments来保障每个文档和词条相关性的准确。通过这种方式，新的文档轻量的可以被添加到对应的索引中。</li>
</ul>
<h4 id="删除和更新">删除和更新</h4><ul>
<li>segments是不变的，所以文档不能从旧的segments中删除，也不能在旧的segments中更新来映射一个新的文档版本。取之的是，每一个提交点都会包含一个.del文件，列举了哪一个segmen的哪一个文档已经被删除了。 当一个文档被”删除”了，它仅仅是在.del文件里被标记了一下。被”删除”的文档依旧可以被索引到，但是它将会在最终结果返回时被移除掉。</li>
<li>文档的更新同理：当文档更新时，旧版本的文档将会被标记为删除，新版本的文档在新的segment中建立索引。也许新旧版本的文档都会本检索到，但是旧版本的文档会在最终结果返回时被移除。</li>
</ul>
<h4 id="实时索引">实时索引</h4><ul>
<li>在上述的per-segment搜索的机制下，新的文档会在分钟级内被索引，但是还不够快。 瓶颈在磁盘。将新的segment提交到磁盘需要fsync来保障物理写入。但是fsync是很耗时的。它不能在每次文档更新时就被调用，否则性能会很低。</li>
<li>现在需要一种轻便的方式能使新的文档可以被索引，这就意味着不能使用fsync来保障。 在ES和物理磁盘之间是内核的文件系统缓存。之前的描述中,Figure19,Figure20，在内存中索引的文档会被写入到一个新的segment。但是现在我们将segment首先写入到内核的文件系统缓存，这个过程很轻量，然后再flush到磁盘，这个过程很耗时。但是一旦一个segment文件在内核的缓存中，它可以被打开被读取。</li>
</ul>
<p><img src="/images/elk/3-3.png" alt="term"></p>
<p><img src="/images/elk/3-4.png" alt="term"></p>
<h4 id="更新持久化">更新持久化</h4><p>不使用fsync将数据flush到磁盘，我们不能保障在断电后或者进程死掉后数据不丢失。ES是可靠的，它可以保障数据被持久化到磁盘。 在2.6.2中，一个完全的提交会将segments写入到磁盘，并且写一个提交点，列出所有已知的segments。当ES启动或者重新打开一个index时，它会利用这个提交点来决定哪些segments属于当前的shard。 如果在提交点时，文档被修改会怎么样？不希望丢失这些修改：</p>
<ul>
<li>当一个文档被索引时，它会被添加到in-memory buffer，并且添加到Translog日志中，见Figure21.</li>
</ul>
<p><img src="/images/elk/3-5.png" alt="term"></p>
<ul>
<li>refresh操作会让shard处于Figure22的状态：每秒中，shard都会被refreshed，在in-memory buffer中的文档会被写入到一个新的segment，但没有fsync，in-memory buffer被清空。</li>
</ul>
<p><img src="/images/elk/3-6.png" alt="term"></p>
<ul>
<li>这个过程将会持续进行：新的文档将被添加到in-memory buffer和translog日志中，见Figure23</li>
</ul>
<p><img src="/images/elk/3-7.png" alt="term"></p>
<ul>
<li>一段时间后，当translog变得非常大时，索引将会被flush，新的translog将会建立，一个完全的提交进行完毕。见Figure24<ul>
<li>在in-memory中的所有文档将被写入到新的segment.</li>
<li>内核文件系统会被fsync到磁盘。</li>
<li>旧的translog日志被删除</li>
</ul>
</li>
</ul>
<p><img src="/images/elk/3-8.png" alt="term"></p>
<p>translog日志提供了一个所有还未被flush到磁盘的操作的持久化记录。当ES启动的时候，它会使用最新的commit point从磁盘恢复所有已有的segments，然后将重现所有在translog里面的操作来添加更新，这些更新发生在最新的一次commit的记录之后还未被fsync。</p>
<p>translog日志也可以用来提供实时的CRUD。当你试图通过文档ID来读取、更新、删除一个文档时，它会首先检查translog日志看看有没有最新的更新，然后再从响应的segment中获得文档。这意味着它每次都会对最新版本的文档做操作，并且是实时的。</p>
<h4 id="Segment合并">Segment合并</h4><ul>
<li>通过每隔一秒的自动刷新机制会创建一个新的segment，用不了多久就会有很多的segment。segment会消耗系统的文件句柄，内存，CPU时钟。最重要的是，每一次请求都会依次检查所有的segment。segment越多，检索就会越慢。</li>
<li>ES通过在后台merge这些segment的方式解决这个问题。小的segment merge到大的，大的merge到更大的。。。</li>
<li>这个过程也是那些被”删除”的文档真正被清除出文件系统的过程，因为被标记为删除的文档不会被拷贝到大的segment中。合并过程如Figure25：<ul>
<li>当在建立索引过程中，refresh进程会创建新的segments然后打开他们以供索引。</li>
<li>merge进程会选择一些小的segments然后merge到一个大的segment中。这个过程不会打断检索和创建索引。</li>
<li>Figure26，一旦merge完成，旧的segments将被删除：新的segment被flush到磁盘，一个新的提交点被写入，包括新的segment，排除旧的小的segments，新的segment打开以供索引旧的segments被删除。</li>
</ul>
</li>
</ul>
<p><img src="/images/elk/3-9.png" alt="term"></p>
<p><img src="/images/elk/3-10.png" alt="term"></p>
<p>merge大的segments会消耗大量的I/O和CPU，严重影响索引性能。默认，ES会节制merge过程来给留下足够多的系统资源。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/10/year-books/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eric Chang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric Chang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/10/year-books/" itemprop="url">
                  2017我的年度书单
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-10T00:00:00+08:00">
                2017-12-10
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/12/10/year-books/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/12/10/year-books/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="引言">引言</h3><ul>
<li>今年是工作的第一年，虽然非常忙，但仍然静下心读了几本书。</li>
<li>书籍相比于公众号、博客、各种手机APP等，在获取信息的效率方面确实比较逊色，但是读书的目的远远不仅是获取信息。读书、思考、认识、改变应当是一个有机统一的整体。书中的世界和我们眼中的世界有时是不同的，我想，这可能就是读书的意义所在吧。</li>
<li>读书本身并不是学习，学习有很多渠道，不一定非要读书。如果说读书可以促使人进步，我想，不如说由读书引发的思考使人进步。思考力已经成为在这个飞速发展和变化的社会生存的核心竞争力。</li>
<li>下面，分享我今年读的几本书，如果您对这些书籍或领域也感兴趣，欢迎邮件交流。</li>
</ul>
<h3 id="2017-我的书单">2017-我的书单</h3><ul>
<li>《经济学基础》<ul>
<li>作者：[美] 曼昆 </li>
<li>曼昆是美国著名经济学家、哈佛大学经济学教授，本书是美国乃至全球经济学和金融学专业的知名的教科书。</li>
<li>本书最大的特点是将深刻的经济学原理和普通人的生活相结合，深入浅出，用类比的思想讲解经济学的基本原理。</li>
<li>本书涉及了经济学最深刻的本质：经济为何能够成为人类社会生活的一部分？为什么要有经济和金融，它有没有替代品？经济为人性服务还是人性为经济服务？</li>
<li>如果您能将本书中的西方经济学思想和中国的具体实际相结合，您就会发现当今中国的各种经济现象的本源和基本的解决方案。大到国家层面的大政方针、小到我们每个人的财务支配，经济学原理就像一只无形的手支配着所有人的经济行为。</li>
<li>本书是经济学经典著作《国富论》的延伸和发展，将现代经济学、金融学和西方经济学的思想融为一体，非常值得认真阅读。</li>
</ul>
</li>
</ul>
<p><img src="/images/2017books/book1.jpg" alt="book1"></p>
<ul>
<li>《乌合之众》<ul>
<li>作者：[法] 居斯塔夫·勒庞 </li>
<li>作者勒庞是法国社会心理学家、社会学家、群体心理学创始人，本书是群体心理学的鼻祖。</li>
<li>虽然群体心理学和个体心理学所揭示的心理学基本原理在本质上高度一致，但是群体心理学在研究方法、外在表象、应用实践等方面与个体心理学有着很大的不同。</li>
<li>本书不是心理学教材，而是一本心理学专著，对于没有心理学背景的读者来说，可能不容易领会其中的内涵。建议在阅读本书前先阅读戴维·迈尔斯的《社会心理学》。</li>
<li>本书提出了几个较为深刻的问题，就连勒庞自己也没有给出完美的解答：为什么将个体放在群体中就会出现和个体单独存在时完全不同、甚至截然相反的心理表现？社会和群体存在和意义和价值是什么？不同种族、不同信仰、不同价值观的人如何合作？社会群体和家庭如何影响个体的心理发展？</li>
<li>如果您对心理学在群体中的表征看兴趣，可以阅读此书。</li>
</ul>
</li>
</ul>
<p><img src="/images/2017books/book2.jpg" alt="book2"></p>
<ul>
<li>《合作的进化》<ul>
<li>作者：[美] 罗伯特·阿克塞尔罗德 </li>
<li>本书很薄，一两周便能够通读完成；</li>
<li>不同于《乌合之众》，本书专注于行为心理学的研究和实践，而不是侧重群体心理学。</li>
<li>阅读完本书您会发现，人类的一切政治、经济、军事、科技、教育、娱乐活动无不暗含着行为心理学的基本原理，可以说行为心理学指导人类进行各种社会活动，社会活动本身反过来也影响人的行为。人的行为在一定程度上是可预测的。</li>
<li>如果您对博弈论感兴趣，建议将本书和博弈论相关书籍一起阅读，您会发现人类行为不知不觉也应用了博弈论的基本原理，并且对企业间、国家间的合作理解得更为深刻和透彻。</li>
</ul>
</li>
</ul>
<p><img src="/images/2017books/book3.jpg" alt="book3"></p>
<ul>
<li>《变态心理学》<ul>
<li>作者：[美] 德博拉 C.贝德尔 （Deborah C. Beidel） / 辛西娅 M. 布利克（Cynthia M. Bulik） / 梅琳达•斯坦利（Melinda A. Stanley） </li>
<li>本书讲解了非常态心理的基本原理，比如造成孤独症、焦虑症、抑郁症的原因和基本治疗方法。虽然只有心理学相关专业才需要这些知识，但是我还是完整阅读本书，对非常态心理有了基本的理解。</li>
<li>本书不仅包含理论研究，而且还包含了大量生动的例子和临床实践，便于读者了解问题的表象和本质原因。</li>
<li>本书中还有很多概念我不太理解，需要再次阅读其他变态心理学著作配合理解。</li>
</ul>
</li>
</ul>
<p><img src="/images/2017books/book4.jpg" alt="book4"></p>
<ul>
<li>《聪明的投资者》<ul>
<li>作者：[美] 本杰明·格雷厄姆 </li>
<li>本书作者本杰明·格雷厄姆是美国经济学家和投资思想家、价值投资理论奠基人、巴菲特的老师。</li>
<li>本书是价值投资的最为经典的著作，没有之一。</li>
<li>如果您对投资感兴趣，或者准备成为股东，强烈推荐阅读此书。</li>
<li>本书理论部分不多，对于大多数章节，都直接给出作者的观点或者结论，比如投资的基本原则和注意事项、公司或股票的选择原则、如何在股市中盈利和止损等。</li>
<li>本书并没有讲解太多技术面的操作技巧，如果需要了解技术面，不建议阅读本书。</li>
</ul>
</li>
</ul>
<p><img src="/images/2017books/book5.jpg" alt="book5"></p>
<ul>
<li>《人人都是经营者》<ul>
<li>作者：[中] 刁东平 </li>
<li>阿米巴经营模式的核心，是经营哲学、组织结构设计、内部市场、经营会计、人才培养、内部运行等等一整套理论的有机整合，作者认为这是比较适合中国企业的、但尚未在中国企业中广泛应用的一种经营模式。</li>
<li>我个人认为，阿米巴经营模式适用于那种资金流动性大、具有较充足的流动资金、处于朝阳产业并想要扩大生产的中型企业。准备上市的企业也可以参考运用。</li>
<li>任何一种模式都无法代替“实事求是”四个字，应当根据企业的实际情况，使用适合自己的模式。</li>
</ul>
</li>
</ul>
<p><img src="/images/2017books/book6.jpg" alt="book6"></p>
<ul>
<li>《巴菲特之道》<ul>
<li>作者：[美] 罗伯特·哈格斯特朗 </li>
<li>想了解投资大师巴菲特？就读这本书！</li>
<li>本书介绍了巴菲特的个人经历，以及如果从一位投资小白成长为投资大师的传奇经历，从这段经历中，我们也可以看出巴菲特的投资思想的变迁。</li>
<li>虽说成功不可复制，但是参考巴菲特成功的经历，多多少少有所启发、有所借鉴。</li>
</ul>
</li>
</ul>
<p><img src="/images/2017books/book7.jpg" alt="book7"></p>
<ul>
<li>《看见》<ul>
<li>作者：[中] 柴静</li>
<li>本书给了读者看中国的另一只眼睛。</li>
<li>本书中所写的都是记者柴静的采访经历，看起来都是一些小事，但却能反映最真实的中国的现状。本书书名为《看见》，的确，读完本书后，我看见了一些以前不曾看见的东西，对中国的改革、发展有了更深刻的认识，对发展中遇到的问题和解决方法有了更深刻的认识。</li>
<li>历史就是一个和另一个的《看见》所书写的，《看见》不仅是为了看见，更是为了改变和进步。</li>
</ul>
</li>
</ul>
<p><img src="/images/2017books/book8.jpg" alt="book8"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/15/2017-6-15-DevOps/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eric Chang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric Chang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/15/2017-6-15-DevOps/" itemprop="url">
                  我理解的DevOps
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-15T00:00:00+08:00">
                2017-06-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DevOps/" itemprop="url" rel="index">
                    <span itemprop="name">DevOps</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/06/15/2017-6-15-DevOps/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/06/15/2017-6-15-DevOps/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="引言">引言</h3><ul>
<li>DevOps是一种重要的软件开发模式；</li>
<li>我所在的团队正在进行DevOps转型；</li>
<li>DevOps极大地提升了开发效率；</li>
<li>本文介绍了我对DevOps的理解；</li>
</ul>
<h3 id="什么是DevOps">什么是DevOps</h3><ul>
<li>DevOps是一种软件开发人员（Research and Dev，RD）和IT运维运营技术人员（Ops）和质量检测（QA）之间沟通合作的模式；</li>
<li>DevOps的根本目的是快速频繁的、小步的、自动化便捷的监控和审计的、云端和虚拟化的、可视化的部署，满足“每天部署10次”或者“快速解决bug并上线”的要求；</li>
<li>DevOps是敏捷开发、持续交付的基础；</li>
<li>DevOps模式和传统的瀑布模型相对应；</li>
</ul>
<h3 id="我们需要维护什么？">我们需要维护什么？</h3><ul>
<li>以我所在的团队为例，我们需要维护的内容如下：<ul>
<li>需要维护的环境分为：开发环境，测试环境，准生产环境，生产环境；</li>
<li>每个环境包含若干个scope，每个scope都是整个系统的一部分，由不同的团队进行开发；</li>
<li>使用microsoft微服务架构，每个scope中都有若干service，每个service之间可能还存在相互依赖关系；</li>
<li>每个service都需要若干resource，这些resource包括但不限于：</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>RabbitMQ；</li>
<li>Service Fabric；</li>
<li>IoTHub；</li>
<li>EventHub；</li>
<li>ELK；</li>
<li>Consule；</li>
<li>KeyVault；</li>
<li>MongoDB； </li>
<li>Postgresql；</li>
<li>Cassandra；</li>
<li>Storm；</li>
<li>Redis；</li>
</ul>
</blockquote>
<h3 id="如果没有DevOps，我们怎样工作？">如果没有DevOps，我们怎样工作？</h3><ul>
<li>没有流水线Pipeline：<ul>
<li>开发过程变得非常痛苦，会经常忘记对代码进行单元测试和集成测试；</li>
<li>开发完成的服务，打包后不知道放在何处，别人需要引用时很不方便；</li>
<li>代码质量得不到保证，很多代码没有经过“单元测试覆盖率检测”和“代码重复率检测”，代码可维护性变差；</li>
<li>随着开发的深入进行，开发人员的主要精力不在是编写新的代码，而是处理bug和维护旧的代码，使开发效率逐渐降低；</li>
</ul>
</li>
<li>没有自动化环境部署：<ul>
<li>在开发者完成一个微服务的开发后，不知道将自己开发的服务部署到什么环境上去测试；</li>
<li>开发者在测试自己的代码时，会时常发现所依赖的资源没有准备好，比如测试环境缺少MongoDB等资源；</li>
<li>运维人员不能显式的看到自己维护了多少资源，每种资源都在被哪些环境、哪些service引用；</li>
<li>运维人员不能显式的看到资源的使用情况及使用量；</li>
<li>经理不能有效的进行成本控制；</li>
</ul>
</li>
<li>没有自动化监控系统：<ul>
<li>运维人员不能在机器、硬件、软件出现故障时得到及时的警告，导致机器挂掉了都还不知道；</li>
<li>不能灵活调配各种资源的使用，导致某些资源极度紧缺、某些资源却有富余；</li>
</ul>
</li>
<li>手动，而不是自动：<ul>
<li>从下面的图片可以看出，只需手工运行5条命令的情况下，成功部署的概率就已跌至86%，如需手工运行55条命令，成功部署的概率将跌至22%，如需手工运行100条命令，成功部署的概率将趋近于0（仅2%）！</li>
</ul>
</li>
</ul>
<p><img src="/images/DevOps/DevOps.png" alt="DevOps"></p>
<h3 id="为什么要有DevOps">为什么要有DevOps</h3><ul>
<li>不知道目前发布、部署的进展情况；</li>
<li>没有一套明确的发布、部署流程，急上线时容易出问题，出了问题也没有预案来解决；</li>
<li>自动化程度不够；</li>
</ul>
<h3 id="DevOps工具链">DevOps工具链</h3><ul>
<li>编码：代码开发和审阅，版本控制工具、代码合并工具；</li>
<li>构建：持续集成工具、构建状态统计工具；</li>
<li>测试：通过测试和结果确定绩效的工具；</li>
<li>打包：成品仓库、应用程序部署前暂存；</li>
<li>发布：变更管理、发布审批、发布自动化；</li>
<li>配置：基础架构配置和部署，基础架构即代码工具；</li>
<li>监视：应用程序性能监视、最终用户体验；</li>
</ul>
<h3 id="DevOps的多维度目标">DevOps的多维度目标</h3><ul>
<li>团队维度：拟合开发和运维的鸿沟，支持位于全球多个地点的、包含外包人员的、混合开发/测试/基础设施的团队；</li>
<li>技术维度：拟合多类型的分布式的硬件平台和上面部署的多种应用、多种需求的鸿沟；</li>
<li>需求维度：平衡软件开发过程中对软件用户需求变化、追求稳定性、追求开发效率、降低check-in风险这几个目标；</li>
<li>市场维度：解决软件迭代慢和较高的用户需求的矛盾；</li>
<li>终极目标：从时间和空间两个维度，合理统筹并高效使用现有资源，实现组织目标，最大限度满足用户需求；</li>
</ul>
<h3 id="DevOps需要遵循的基本原则">DevOps需要遵循的基本原则</h3><ul>
<li>以人为本，一切工具都是为人服务；</li>
<li>需求细分，及时开发，及时验证；</li>
<li>减少开发的分支，尽量在主干上开发，避免合并分支造成的开销和时间浪费；另外，分支太多的时候不可能做到持续集成；</li>
<li>减少代码积压，代码积压越多、越多的需求和开发成果得不到验证、效率就越低、下次部署的风险就越大；</li>
<li>代码和配置相分离，尽量降低他们在逻辑或者物理上的耦合；</li>
<li>尽早生成二进制包，而不是使用源代码，并确保二进制包不被篡改；</li>
<li>二进制包应当和环境无关；</li>
<li>确保部署流程是幂等的；</li>
<li>对生产和测试环境的修改只能由程序，而不是人完成；</li>
</ul>
<h3 id="环境管理">环境管理</h3><ul>
<li>环境必须遵循：快速部署和响应（使用docker或者其他虚拟化技术能够更容易做到这一点），可恢复，可支持，可审计；</li>
<li>环境配置项目：<ul>
<li>操作系统和配置；</li>
<li>中间件和软件栈及配置：数据库，消息系统，队列；</li>
<li>基础设施软件：代码管理，目录服务，监控；</li>
<li>外部集成：外部系统和服务；</li>
<li>网络：路由，防火墙，交换机，DNS；</li>
<li>团队：开发团队和infra团队之间的协调分工；</li>
</ul>
</li>
<li>自动化的环境部署；</li>
<li>测试环境应当和生产环境尽量一致；</li>
<li>环境的配置文件也应当进行版本控制；</li>
</ul>
<h3 id="监控">监控</h3><ul>
<li>监控的内容：<ul>
<li>硬件，物理设备，路由器，代理；</li>
<li>操作系统；</li>
<li>中间件；</li>
<li>应用程序；</li>
<li>日志；</li>
</ul>
</li>
<li>如何监控：<ul>
<li>清晰的信息展示；</li>
<li>及时的告警；</li>
<li>可视化的状态呈现；</li>
</ul>
</li>
</ul>
<h3 id="常用DevOps利器">常用DevOps利器</h3><ul>
<li><a href="https://jenkins.io/" target="_blank" rel="external">Jenkins</a>：开源的持续集成工具；</li>
<li><a href="https://www.sonarqube.org/" target="_blank" rel="external">SonarQube</a>：开源的代码质量管理系统；</li>
<li><a href="https://puppet.com/" target="_blank" rel="external">Puppet</a>：开源的软件自动化配置和部署工具；</li>
<li><a href="https://www.docker.com/" target="_blank" rel="external">Docker</a>：让应用程序布署在软件容器下的工作可以自动化进行；</li>
</ul>
<h3 id="总结：DevOps到底是什么？">总结：DevOps到底是什么？</h3><ul>
<li>高效的流水线开发/测试/上线；</li>
<li>自动化的环境部署和管理；</li>
<li>良好和及时的监控/告警/可视化/反馈/日志；</li>
<li>开发团队、运维团队、用户之间良好的沟通协作，快速解决问题的能力；</li>
<li>完整的文档；</li>
<li>任一模块的幂等和可恢复；</li>
<li>良好的审计和评估，良好的成本管理；</li>
<li>整个系统稳定且灵活，高度自动化；</li>
<li>总而言之，DevOps的核心只有三个词：高效、自动、监控；</li>
</ul>
<h3 id="参考">参考</h3><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzIzNjUxMzk2NQ==&amp;mid=2247485035&amp;idx=1&amp;sn=d8dbc8e682dc9f634263b9ba1178daa9" target="_blank" rel="external">DevOps的真谛到底是什么？</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" target="_blank" rel="external">持续集成是什么？</a></li>
<li><a href="http://exceedhl.thoughtworkers.org/cd/cd.html" target="_blank" rel="external">持续交付概述</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%9C%8B%E6%9D%BF%E7%AE%A1%E7%90%86" target="_blank" rel="external">看板管理</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/me.png"
               alt="Eric Chang" />
          <p class="site-author-name" itemprop="name">Eric Chang</p>
           
              <p class="site-description motion-element" itemprop="description"><a href="http://www.yinshuisiyuan.net">www.yinshuisiyuan.net</a></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">99</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">50</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/changsiyuan" target="_blank" title="github">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/2803286360" target="_blank" title="weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.linkedin.com/profile/preview?locale=zh_CN&trk=prof-0-sb-preview-primary-button" target="_blank" title="linkedin">
                  
                    <i class="fa fa-fw fa-linkedin"></i>
                  
                  linkedin
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:changsiyuan2011@126.com" target="_blank" title="mail">
                  
                    <i class="fa fa-fw fa-envelope"></i>
                  
                  mail
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.ruanyifeng.com/home.html" title="阮一峰" target="_blank">阮一峰</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://azure.microsoft.com/en-us/?v=17.14" title="Azure" target="_blank">Azure</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" title="Python" target="_blank">Python</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434501245426ad4b91f2b880464ba876a8e3043fc8ef000" title="Nodejs" target="_blank">Nodejs</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Eric Chang</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


<a rel="license" href="http://creativecommons.org/licenses/by/3.0/cn/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by/3.0/cn/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by/3.0/cn/">知识共享署名 3.0 中国大陆许可协议</a>进行许可。
  
  <script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v1/st.js','_st');

  _st('install','1BK1VZMDEA-ktxiBz_9B');
</script>

<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1258423514'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1258423514%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>




        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"ericchang"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  
















  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>





  

  

  

  

</body>
</html>
